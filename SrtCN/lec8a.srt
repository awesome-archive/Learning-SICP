1
00:00:00,000 --> 00:00:02,672
Learning-SICP学习小组
倾情制作

2
00:00:18,270 --> 00:00:19,680
教授：上节课中 我们学习了
PROFESSOR: The last time we began having a look

3
00:00:19,728 --> 00:00:21,264
如何构造语言
at how languages are constructed.

4
00:00:22,416 --> 00:00:25,888
核心点就是 像Lisp这样的求值器
Remember the main point that an evaluator for, LISP, say,

5
00:00:26,080 --> 00:00:27,580
有两个主要部分
has two main elements.

6
00:00:27,580 --> 00:00:28,400
一个是EVAL
There is EVAL,

7
00:00:31,040 --> 00:00:37,424
EVAL接受一个表达式EXP和环境ENV
and EVAL's job is to take in an expression and an environment

8
00:00:38,912 --> 00:00:44,448
然后返回一个过程和相关的实际参数
and turn that into a procedure and some arguments

9
00:00:45,424 --> 00:00:47,056
并把它们传递给APPLY
and pass that off to APPLY.

10
00:00:49,410 --> 00:00:51,296
APPLY接收这些过程和实际参数
And APPLY takes the procedure in the arguments,

11
00:00:51,696 --> 00:00:55,120
通常来说 APPLY会返回另一个表达式
turns that back into, in a general case, another expression

12
00:00:55,392 --> 00:00:57,712
返回一个在其它环境中求值的表达式
to be evaluated in another environment

13
00:00:57,744 --> 00:01:00,000
表达式就像这样在EVAL-APPLY之间传递
and passes that off to EVAL, which passes it to APPLY,

14
00:01:00,272 --> 00:01:01,440
这就是整个元循环
and there's this whole big circle

15
00:01:01,470 --> 00:01:02,944
表达式在这里面循环往复
where things go around and around and around

16
00:01:03,024 --> 00:01:06,560
直到最后求值为基本数据或基本过程
until you get either to some very primitive data or to a primitive procedure.

17
00:01:07,740 --> 00:01:09,248
这个循环要做的就是
See, what this cycle has to do with

18
00:01:09,440 --> 00:01:12,576
把语言中的组合手段
is unwinding the means of combination

19
00:01:12,590 --> 00:01:14,368
和抽象手段展开
and the means of abstraction in the language.

20
00:01:15,020 --> 00:01:17,728
比如说在Lisp中 你有一个过程
So for instance, you have a procedure in LISP--

21
00:01:17,744 --> 00:01:20,528
定义过程是为了
a procedure is a general way of saying,

22
00:01:20,540 --> 00:01:22,576
让表达式的计算过程
I want to be able to evaluate this expression

23
00:01:22,672 --> 00:01:24,410
适用于任意的参数
for any value of the arguments,

24
00:01:25,760 --> 00:01:27,184
这就是这里面发生的事情
and that's sort of what's going on here.

25
00:01:27,670 --> 00:01:28,510
这就是APPLY做的事
That's what APPLY does.

26
00:01:28,510 --> 00:01:30,688
当一个带参数的一般性表达式进入以后
It says the general thing coming in with the arguments

27
00:01:30,720 --> 00:01:32,704
它将其归约为过程体的表达式
reduces to the expression that's the body,

28
00:01:33,056 --> 00:01:34,720
如果归约得到的是复合表达式
and then if that's a compound expression

29
00:01:34,832 --> 00:01:36,464
或者是另外的过程应用
or another procedure application,

30
00:01:36,784 --> 00:01:38,448
那么这个循环就会不断地进行
the thing will go around and around the circle.

31
00:01:40,336 --> 00:01:44,080
这基本上就是 -- 大部分解释器的基本结构了
Anyway, that's sort of the basic structure of gee, pretty much any interpreter.

32
00:01:45,200 --> 00:01:46,256
另外一点就是
The other thing that you saw

33
00:01:46,288 --> 00:01:47,660
一旦你有了一个解释器
once you have the interpreter in your hands,

34
00:01:47,696 --> 00:01:49,870
你就有了操作这门语言的所有能力
you have all this power to start playing with the language.

35
00:01:49,870 --> 00:01:51,520
因此你可以让它成为动态作用域
So you can make it dynamically scoped,

36
00:01:51,840 --> 00:01:54,560
你也可以引入正则序求值
or you can put in normal order evaluation,

37
00:01:54,590 --> 00:01:56,480
你也可以为语言添加新的形式
or you can add new forms to the language,

38
00:01:56,860 --> 00:01:57,504
想怎么样都行
whatever you like.

39
00:01:57,584 --> 00:01:58,624
或者更一般地说
Or more generally,

40
00:01:58,768 --> 00:02:01,328
这种元语言抽象的概念
there's this notion of metalinguistic abstraction,

41
00:02:02,640 --> 00:02:06,016
它告诉我们 作为一名软件工程师
which says that part of your perspective

42
00:02:07,616 --> 00:02:10,528
从广义的“工程师”的角度来看
as an engineer, as a software engineer, but as an engineer in general

43
00:02:11,392 --> 00:02:13,888
有时你可以通过发明新的语言
is that you can gain control of complexity

44
00:02:14,960 --> 00:02:17,168
来获得控制复杂度的能力
by inventing new languages sometimes.

45
00:02:18,010 --> 00:02:20,816
一种思考计算机程序设计的方法就是
See, one way to think about computer programming

46
00:02:21,552 --> 00:02:26,270
它只是偶然地让计算机执行某事儿
is that it only incidentally has to do with getting a computer to do something.

47
00:02:26,440 --> 00:02:28,976
计算机程序的主要工作却是
Primarily what a computer program has to do with,

48
00:02:29,008 --> 00:02:32,520
用来表达和交换想法
it's a way of expressing ideas with communicating ideas.

49
00:02:33,168 --> 00:02:34,048
有时
And sometimes

50
00:02:34,896 --> 00:02:36,624
当我们想要表达新的想法时
when you want to communicate new kinds of ideas,

51
00:02:36,656 --> 00:02:38,736
我们就想要发明新的模式来表达它们
you'd like to invent new modes of expressing that.

52
00:02:39,824 --> 00:02:44,992
那么 今天我们就将按照这个框架来创建新语言
Well, today we're going to apply this framework to build a new language.

53
00:02:45,730 --> 00:02:48,000
一旦我们了解了解释器的基本结构
See, once we have the basic idea of the interpreter,

54
00:02:48,032 --> 00:02:50,272
我们就可以按意愿来构造任意的语言
you can pretty much go build any language that you like.

55
00:02:50,830 --> 00:02:53,216
比如说 我们可以构造Pascal（的解释器）
So for example, we can go off and build Pascal.

56
00:02:54,370 --> 00:02:55,152
以及
And...

57
00:02:56,170 --> 00:02:58,192
我们需要操心语法的表示与解析
gee, we would worry about syntax and parsing

58
00:02:58,192 --> 00:03:00,510
还有一大堆的编译器优化
and various kinds of compiler optimizations,

59
00:03:01,120 --> 00:03:03,296
还有一些人会这样做
and there are people who make honest livings doing that,

60
00:03:03,856 --> 00:03:07,600
但是就在我们所讨论的抽象层次来说
but at the level of abstraction that we're talking,

61
00:03:08,048 --> 00:03:10,992
一个Pascal语言的解释器看起来
a Pascal interpreter would not look very different at all

62
00:03:12,032 --> 00:03:13,760
跟Gerry教授上节课所讲的大同小异
from what you saw Gerry do last time.

63
00:03:15,024 --> 00:03:18,960
但是今天 我们要构建一门与众不同的语言
Instead of that, we'll spend today building a really different language,

64
00:03:20,510 --> 00:03:22,816
这门语言
a language that encourages you

65
00:03:23,056 --> 00:03:26,040
不推荐你用过程式的思维来思考程序设计
to think about programming not in terms of procedures,

66
00:03:26,240 --> 00:03:27,648
而是用一种非常不同的方式
but in a really different way.

67
00:03:29,090 --> 00:03:31,024
今天的课程呢
And the lecture today is

68
00:03:31,744 --> 00:03:34,640
将会在两个层次中同时进行
going to be at two levels simultaneously.

69
00:03:34,810 --> 00:03:35,520
一方面
On the one hand,

70
00:03:35,904 --> 00:03:37,710
我会向大家介绍这门语言是如何使用的
I'm going to show you what this language looks like,

71
00:03:38,960 --> 00:03:41,080
另一方面呢 我会带领大家实现这门语言
and on the other hand, I'll show you how it's implemented.

72
00:03:41,320 --> 00:03:42,960
我们将会用Lisp来实现
And we'll build an implementation in LISP

73
00:03:42,992 --> 00:03:43,900
并观察它的运行原理
and see how that works.

74
00:03:44,048 --> 00:03:48,256
你应该在两个层次上学到知识
And you should be drawing lessons on two levels.

75
00:03:48,688 --> 00:03:53,000
首先要认识到 语言之间可以有多么地“不同”
The first is to realize just how different a language can be.

76
00:03:53,790 --> 00:03:58,144
如果你认为Fortran和Lisp算是天差地别的话
So if you think that the jump from Fortran to LISP is a big deal,

77
00:03:58,240 --> 00:03:59,360
那就小巫见大巫了
you haven't seen anything yet.

78
00:04:01,560 --> 00:04:03,680
其次
And secondly,

79
00:04:03,776 --> 00:04:06,544
甚至于在这门与众不同的语言中
you'll see that even with such a very different language,

80
00:04:07,360 --> 00:04:09,520
这门既不讨论函数
which will turn out to not have procedures at all

81
00:04:09,920 --> 00:04:11,648
也没有过程的语言中
and not talk about functions at all,

82
00:04:12,200 --> 00:04:15,720
其中也有基本的EVAL-APPLY循环
there will still be this basic cycle of eval and apply

83
00:04:16,192 --> 00:04:19,984
也就是对组合手段和抽象手段的展开
that's unwinds the means of combination and the means an abstraction.

84
00:04:20,950 --> 00:04:24,688
第三点 是一个不太重要但非常优雅的技术技巧
And then thirdly, as kind of a minor but elegant technical point,

85
00:04:24,890 --> 00:04:28,528
就是如何巧妙地使用流来避免回溯
you'll see a nice use of streams to avoid backtracking.

86
00:04:32,330 --> 00:04:34,400
好吧 我说过这门语言与众不同
OK, well, I said that this language is very different.

87
00:04:35,860 --> 00:04:36,640
为了解释这点
To explain that,

88
00:04:37,050 --> 00:04:42,816
让我们回到这门课最初的理念上
let's go back to the very first idea that we talked about in this course,

89
00:04:43,260 --> 00:04:46,544
就是要区别
and that was the idea of the distinction between

90
00:04:46,720 --> 00:04:49,520
数学中“陈述性”的知识
the declarative knowledge of mathematics--

91
00:04:50,192 --> 00:04:54,144
比如平方根的定义就是一条数学事实
the definition of a square root as a mathematical truth--

92
00:04:55,488 --> 00:04:59,568
而计算机科学讨论的是“如何做”的知识
and the idea that computer science talks about the how to knowledge--

93
00:04:59,760 --> 00:05:04,592
“什么是平方根”和“如何计算平方根”是不同的
contrast that definition of square root with a program to compute a square root.

94
00:05:05,970 --> 00:05:07,072
我们是从这里开始的
That's where we started off.

95
00:05:08,512 --> 00:05:09,520
如果我们能够通过某种方式
Well, wouldn't it be great

96
00:05:09,888 --> 00:05:12,160
弥合这种差距 岂不是更好么？
if you could somehow bridge this gap

97
00:05:12,810 --> 00:05:16,432
我们创建一门这样的语言
and make a programming language which sort of did things,

98
00:05:16,672 --> 00:05:21,610
以声明式的方式、用数学事实来完成计算
but you talked about it in terms of truth, in declarative terms?

99
00:05:22,380 --> 00:05:25,504
你用这种该语言来指定事实
So that would be a programming language in which you specify facts.

100
00:05:27,690 --> 00:05:28,880
你告诉它
You tell it what is.

101
00:05:28,880 --> 00:05:29,968
什么是事实
You say what is true.

102
00:05:30,950 --> 00:05:33,072
而当你需要一个答案时
And then when you want an answer,

103
00:05:33,216 --> 00:05:36,384
语言已经自动地内建了
somehow the language has built into it automatically

104
00:05:37,600 --> 00:05:39,456
有关于“如何做”的一般性知识
general kinds of how to knowledge

105
00:05:39,472 --> 00:05:40,640
这样它就可以根据你给出的事实
so it can just take your facts

106
00:05:40,896 --> 00:05:42,832
自行地演进这些方法
and it can evolve these methods on its own

107
00:05:43,312 --> 00:05:46,128
通过你给定的事实和某种一般性的逻辑规则
using the facts you gave it and maybe some general rules of logic.

108
00:05:49,330 --> 00:05:50,544
就比如说
So for instance,

109
00:05:52,064 --> 00:05:55,120
我会告诉程序下述事实
I might go up to this program and start telling it some things.

110
00:05:56,000 --> 00:06:07,080
我告诉它 (SON-OF ADAM ABEL)
So I might tell it that the son of Adam is Abel.

111
00:06:08,920 --> 00:06:16,512
同时告诉它 (SON-OF ADAM CAIN)
And I might tell it that the son of Adam is Cain.

112
00:06:17,660 --> 00:06:25,088
以及 (SON-OF CAIN ENOCH)
And I might tell it that the son of Cain is Enoch.

113
00:06:27,792 --> 00:06:34,896
还有 (SON-OF ENOCH IRAD)
And I might tell it that the son of Enoch is Irad,

114
00:06:37,024 --> 00:06:40,720
以及《创世纪》章节中的其它人物
and all through the rest of our chapter whatever of Genesis,

115
00:06:41,152 --> 00:06:43,184
最后终止于ADAH
which ends up ending in Adah, by the way,

116
00:06:43,328 --> 00:06:46,784
这些是从ADAH到CAIN的家谱
and this shows the genealogy of Adah from Cain.

117
00:06:48,440 --> 00:06:50,672
总之 一旦你指明了这些事实
Anyway, once you tell it these facts,

118
00:06:52,352 --> 00:06:53,408
你就可以提出问题
you might ask it things.

119
00:06:53,510 --> 00:06:55,056
你可以对语言系统发问
You might go up to your language and say,

120
00:06:56,064 --> 00:06:59,296
谁是ADAM的孩子？
who's the son of Adam?

121
00:07:00,420 --> 00:07:04,912
可以很容易地想到一个通用搜索程序
And you can very easily imagine having a little general purpose search program

122
00:07:05,520 --> 00:07:06,960
它会遍历所有的事实
which would be able to go through

123
00:07:07,008 --> 00:07:09,260
然后回答：“哦 有两个答案”
and in response to that say, oh yeah, there are two answers:

124
00:07:09,296 --> 00:07:10,448
ABEL是ADAM的孩子
the son of Adam is Abel

125
00:07:10,688 --> 00:07:12,176
CAIN也是ADAM的孩子
and the son of Adam is Cain.

126
00:07:14,140 --> 00:07:14,976
你也可以这样问
Or you might say,

127
00:07:15,070 --> 00:07:16,890
基于同样的事实
based on the very same facts,

128
00:07:18,048 --> 00:07:19,952
CAIN是谁的孩子？
who is Cain the son of?

129
00:07:21,950 --> 00:07:27,024
你们就会想到生成另外一个略微不同的搜索程序
And then you can imagine generating another slightly different search program

130
00:07:27,920 --> 00:07:29,216
它也会遍历所有的事实
which would be able to go through

131
00:07:29,450 --> 00:07:33,056
检查谁的孩子是CAIN
and checked for who is Cain, and son of,

132
00:07:33,520 --> 00:07:34,440
发现结果是ADAM
and come up with Adam.

133
00:07:35,890 --> 00:07:36,992
你也可以问
Or you might say,

134
00:07:38,016 --> 00:07:41,408
CAIN和ENOCH之间是什么关系？
what's the relationship between Cain and Enoch?

135
00:07:42,070 --> 00:07:45,088
又会生成另一个略微不同的搜索程序
And again, a minor variant on that search program.

136
00:07:46,340 --> 00:07:48,160
得到的结果是亲子关系（SON-OF）
You could figure out that it said son of.

137
00:07:52,880 --> 00:07:54,928
在这个非常简单的例子中
But even here in this very simple example,

138
00:07:56,144 --> 00:07:58,448
我们发现 即使是单条事实
what you see is that a single fact,

139
00:07:58,816 --> 00:08:01,520
比如说 (SON-OF ADAM CAIN)
see, a single fact like the son of Adam is Cain

140
00:08:02,848 --> 00:08:05,520
可以被用来回答不同种类的问题
can be used to answer different kinds of questions.

141
00:08:06,520 --> 00:08:08,128
你可以问CAIN是谁的孩子？
You can say, who's Cain the son of,

142
00:08:08,144 --> 00:08:10,928
你也可以问ADAM的孩子是谁？
or you can say who's the son of Adam,

143
00:08:10,944 --> 00:08:12,864
你也可以问ADAM和CAIN之间的关系是什么？
or you can say what's the relation between Adam and Cain?

144
00:08:12,880 --> 00:08:14,480
这些由不同的传统程序
Those are different questions

145
00:08:15,536 --> 00:08:18,544
所解答的不同的问题
being run by different traditional procedures

146
00:08:18,688 --> 00:08:20,720
都基于同样的事实
all based on the same fact.

147
00:08:22,752 --> 00:08:25,920
这正是这种程序设计风格的威力所在
And that's going to be the essence of the power of this programming style,

148
00:08:26,912 --> 00:08:29,504
也就是一条陈述性知识
that one piece of declarative knowledge

149
00:08:30,040 --> 00:08:34,016
可以作为大量关于“如何做”的各种知识的基础
can be used as the basis for a lot of different kinds of how-to knowledge,

150
00:08:34,816 --> 00:08:37,088
这跟我们正在编写的过程是不同的
as opposed to the kinds of procedures we're writing

151
00:08:37,152 --> 00:08:39,552
我们编写的过程描述了输入
where you sort of tell it what input you're giving in

152
00:08:39,616 --> 00:08:40,656
以及想要的输出
and what answer you want.

153
00:08:41,490 --> 00:08:44,704
比如说 我们的平方根程序可以完美地回答
So for instance, our square root program can perfectly well answer the question,

154
00:08:44,768 --> 00:08:47,168
144的平方根是多少？
what's the square root of 144?

155
00:08:48,900 --> 00:08:49,776
但从原理上来说
But in principle,

156
00:08:49,824 --> 00:08:52,830
平方根的数学定义告诉了你另外的东西
the mathematical definition of square root tells you other things.

157
00:08:52,848 --> 00:08:56,430
就比如说 17是谁的平方根
Like it could say, what is 17 the square root of?

158
00:08:57,590 --> 00:08:59,712
这就需要另外一个程序来解答
And that would be have to be answered by a different program.

159
00:09:01,920 --> 00:09:03,504
因此 数学定义
So the mathematical definition,

160
00:09:03,980 --> 00:09:05,120
或者更一般地说
or in general, the

161
00:09:05,536 --> 00:09:10,300
你给定的事实 对于问题是没有偏向性的
the facts that you give it are somehow unbiased as to what the question is.

162
00:09:10,900 --> 00:09:12,816
而我们倾向于编写专门的程序
Whereas the programs we tend to write specifically

163
00:09:12,830 --> 00:09:14,208
因为它们是关于“如何做”的知识
because they are how-to knowledge

164
00:09:14,240 --> 00:09:16,368
倾向于寻找特定的答案
tend to be looking for a specific answer.

165
00:09:17,568 --> 00:09:20,120
所以这是我们正在讨论的一个特点
So that's going to be one characteristic of what we're talking about.

166
00:09:21,810 --> 00:09:22,608
然而我们可以更进一步
We can go on.

167
00:09:23,480 --> 00:09:27,520
想象一下 我们可以向语言给定一些事实
We can imagine that we've given our language some sort of facts.

168
00:09:27,710 --> 00:09:29,616
现在 我们给它一些推理规则
Now let's give it some rules of inference.

169
00:09:30,020 --> 00:09:31,360
比如说
We can say, for instance,

170
00:09:31,952 --> 00:09:36,192
这里 我们先用某种语法表示
if the-- make up some syntax here--

171
00:09:36,448 --> 00:09:41,536
如果(SON-OF ?X ?Y)成立
if the son of x is y--

172
00:09:41,680 --> 00:09:45,210
在这里 我用问号来标识变量
I'll put question marks to indicate variables here--

173
00:09:45,616 --> 00:09:56,060
如果(SON-OF ?X ?Y)和(SON-OF ?Y ?Z)都成立
if the son of x is y and the son of y is z,

174
00:09:58,960 --> 00:10:08,464
那么就有(GRANSON ?X ?Z)
then the grandson of x is z.

175
00:10:09,320 --> 00:10:13,408
想象一下 如果把这条规则告诉机器
So I can imagine telling my machine that rule

176
00:10:15,008 --> 00:10:17,280
那么我们就可以这么来询问
and then being able to say, for instance,

177
00:10:17,440 --> 00:10:18,688
谁是ADAM的孙子？
who's the grandson of Adam?

178
00:10:20,610 --> 00:10:23,648
或者说 IRAD是谁的孙子？
Or who is Irad the grandson of?

179
00:10:24,790 --> 00:10:29,088
或者从这些信息中尽可能地推断出所有的祖孙关系
Or deduce all grandson relationships you possibly can from this information.

180
00:10:31,136 --> 00:10:35,600
我们可以想象 语言知道如何自动求解
We can imagine somehow the language knowing how to do that automatically.

181
00:10:40,224 --> 00:10:45,200
好吧 我再举一个更具体一点的例子
Ok, Let me give you maybe a little bit more concrete example.

182
00:10:45,776 --> 00:10:51,952
这是个用来合并两个有序表的过程
Here's a procedure that merges two sorted lists.

183
00:10:53,920 --> 00:11:00,272
X和Y是两个由数字构成的表
So x and y are two, say, lists of numbers,

184
00:11:00,304 --> 00:11:04,208
我们可以认为它们是严格升序的表
lists of distinct numbers, if you like, that are in increasing order.

185
00:11:04,768 --> 00:11:07,530
MERGE会把这两个表
And what merge does is take two such lists

186
00:11:07,712 --> 00:11:10,384
合并成一个有序的表
and combine them into a list where everything's in increasing order,

187
00:11:11,210 --> 00:11:15,000
这个程序非常简单
and this is a pretty easy programs

188
00:11:15,024 --> 00:11:16,144
你们可以轻松地写出来
that you ought to be able to write.

189
00:11:16,390 --> 00:11:18,640
也就是 如果X为空 那么结果就是Y
It says, if x is empty, the answer is y.

190
00:11:18,860 --> 00:11:20,464
如果Y为空 那结果就是X
If y is empty, the answer is x.

191
00:11:21,180 --> 00:11:22,990
否则的话 就要比较为首的两个元素
Otherwise, you compare the first two elements.

192
00:11:22,990 --> 00:11:24,464
取出X中的第一个元素
So you pick out the first thing in x

193
00:11:24,848 --> 00:11:26,016
以及Y中的第一个元素
and the first thing in y,

194
00:11:26,810 --> 00:11:31,680
把它们当中谁是最小的那一个
and then depending on which of those first elements is less,

195
00:11:32,832 --> 00:11:36,608
CONS在递归地调用MERGE的结果上
you stick the lower one on to the result a recursively merging,

196
00:11:37,872 --> 00:11:39,920
要么就是(MERGE (CDR X) Y)
either chopping the first one off x

197
00:11:40,112 --> 00:11:41,616
要么就是(MERGE X (CDR Y))
or chopping the first one off y.

198
00:11:42,400 --> 00:11:43,960
这是标准的程序
That's a standard kind of program.

199
00:11:46,470 --> 00:11:48,416
我们来考察下其中的逻辑
Let's look at the logic.

200
00:11:48,620 --> 00:11:49,792
先不考虑程序
Let's forget about the program

201
00:11:50,288 --> 00:11:52,768
来看看这个过程所基于的逻辑
and look at the logic on which that procedure is based.

202
00:11:53,820 --> 00:11:55,008
这其中的逻辑是
See, there's some logic which says,

203
00:11:55,024 --> 00:11:57,210
如果第一个元素较小
gee, if the first one is less,

204
00:11:57,536 --> 00:12:00,000
那么最后的结果就是把它
then we get the answer by sticking something onto the

205
00:12:00,160 --> 00:12:02,128
跟递归MERGE的结果CONS起来
the result of recursively merging the rest.

206
00:12:02,848 --> 00:12:04,096
让我们试着把
So let's try and be explicit about

207
00:12:04,240 --> 00:12:06,416
使这个程序运作的逻辑说清楚一点
what that logic is that's making the program work.

208
00:12:08,304 --> 00:12:09,440
这是一部分
So here's one piece.

209
00:12:10,130 --> 00:12:11,536
这段程序
Here's the piece of the program which

210
00:12:12,640 --> 00:12:15,264
递归地剥离X
recursively chops down x

211
00:12:15,664 --> 00:12:17,824
如果X中的首元素较小的话
if the first thing in x is smaller.

212
00:12:19,980 --> 00:12:22,544
如果要显式地指出其中的逻辑的话
And if you want to be very explicit about what the logic is there,

213
00:12:23,450 --> 00:12:26,496
它其实就是演绎推理
what's really going on is a deduction,

214
00:12:26,720 --> 00:12:32,384
其中 如果知道表CDR-X和表Y
which says, if you know that some list, that we'll call cdr of x, and y

215
00:12:33,290 --> 00:12:35,440
能够通过MERGE-TO-FORM形成Z
merged to form z,

216
00:12:37,840 --> 00:12:41,520
并且还知道A比Y中的第一个元素小
And you know that a is less than the first thing in y.

217
00:12:43,600 --> 00:12:48,520
那么你就知道 如果你把A和CDR-X给CONS起来
then you know that if you put a onto the cdr of x.

218
00:12:49,740 --> 00:12:51,850
得到的结果和Y一起
and that result and y

219
00:12:52,608 --> 00:12:54,992
可以通过MERGE-TO-FORM形成Z
merge-to-form a onto z.

220
00:12:55,820 --> 00:12:58,096
这就是它所基于的逻辑
And what that is, that's the underlying piece of logic--

221
00:12:58,720 --> 00:12:59,952
我没有把它写成程序
I haven't written it as a program,

222
00:12:59,968 --> 00:13:02,000
我把它写成了某种演绎
I wrote it a sort of deduction

223
00:13:02,032 --> 00:13:04,896
正是属于这个特定子句的
that sits underneath this particular clause

224
00:13:05,216 --> 00:13:07,264
它告诉我们可以在这里使用递归
that says we can use the recursion there.

225
00:13:09,410 --> 00:13:12,784
同样地 这里还有些句子来补全其中的逻辑
And then similar, here's the other clause just to complete it.

226
00:13:14,000 --> 00:13:15,872
其它的句子都是基于这些逻辑
The other clause is based on this piece of logic,

227
00:13:15,920 --> 00:13:18,352
由于它们大部分是相同的 我就不细讲了
which is almost the same and I won't go through it,

228
00:13:19,008 --> 00:13:20,352
然后就是终止条件
and then there's the end cases

229
00:13:20,416 --> 00:13:22,016
是用来检查NULL的
where we tested for null,

230
00:13:22,032 --> 00:13:24,048
其基本想法是 对于任意的X
and that's based on the idea that for any x,

231
00:13:24,510 --> 00:13:27,200
X和空表可以通过MERGE-TO-FORM形成X
x and the empty list merge to form an x,

232
00:13:28,048 --> 00:13:30,864
而空表可以和任意的Y通过MERGE-TO-FORM形成Y
or for any y, the empty list and y merge to form y.

233
00:13:33,360 --> 00:13:38,128
这就是一段过程的代码
OK, so there's a piece of procedure

234
00:13:38,432 --> 00:13:40,112
以及它所基于的逻辑
and the logic on which it's based.

235
00:13:41,740 --> 00:13:42,976
请注意其中的巨大差异
And notice a big difference.

236
00:13:45,104 --> 00:13:50,528
过程看起来是像这样的：
The procedure looked like this:

237
00:13:50,656 --> 00:13:52,288
首先这有一个盒子
it said there was a box--

238
00:13:52,860 --> 00:13:55,392
我们到目前为止所做的事都有这样的特征
and all the things we've been doing have the characteristic

239
00:13:55,408 --> 00:13:57,690
我们有一个盒子 有东西进去 也有东西出来
we have boxes and things going in and things going out--

240
00:13:58,080 --> 00:13:59,610
这儿有个MERGE盒子
there was this box called merge,

241
00:14:01,296 --> 00:14:03,856
输入是X和Y
and in came an x and y,

242
00:14:04,448 --> 00:14:05,376
输出ANS
and out came an answer.

243
00:14:07,632 --> 00:14:09,488
这是我们所编写的程序的特征
That's the character of the procedure that we wrote.

244
00:14:13,024 --> 00:14:14,660
但是规则并不像这样
These rules don't look like that.

245
00:14:14,660 --> 00:14:16,768
规则讨论的是关系
These rules talk about a relation.

246
00:14:17,920 --> 00:14:24,160
也就是在幻灯片中我称作MERGE-TO-FORM的关系
There's some sort of relation that in those slides I called mrege-to-form.

247
00:14:25,370 --> 00:14:28,768
每当我说X和Y通过MERGE-TO-FORM形成Z
So I said x and y merge to form z,

248
00:14:29,008 --> 00:14:32,336
这个是一个函数
and somehow this is not -- this is a function.

249
00:14:32,610 --> 00:14:32,850
对吧？
Right?

250
00:14:32,850 --> 00:14:34,416
ANS是X和Y的函数
The answer is a function of x and y,

251
00:14:34,592 --> 00:14:38,192
而我这里得到的是三个东西之间的关系
and here what I have is a relation between three things.

252
00:14:39,720 --> 00:14:41,328
我不会指明
And I'm not going to specify

253
00:14:42,096 --> 00:14:43,770
哪个是输入 哪个是输出
which is the input and which is the output.

254
00:14:44,200 --> 00:14:47,408
我之所以这么说 是因为原理上
And the reason I want to say that is because in principle,

255
00:14:48,640 --> 00:14:50,832
我们可以用同样的逻辑规则
we could use exactly those same logic rules

256
00:14:50,848 --> 00:14:52,448
来回答相当多的问题
answer a lot of different questions.

257
00:14:54,570 --> 00:14:56,304
比如 我们可以问
So we can say, for instance-- giving

258
00:14:56,720 --> 00:14:59,050
想象一下 如果把这些逻辑规则输入机器
imagine giving our machine those rules of logic.

259
00:14:59,050 --> 00:15:01,200
不是输入程序 而是其中依赖的逻辑
Not the program, the underlying rules of logic.

260
00:15:01,400 --> 00:15:03,120
那么 它也就应该回答--
Then it ought to be able to say--

261
00:15:04,752 --> 00:15:05,520
我们可以问它
we could ask it--

262
00:15:06,736 --> 00:15:19,184
(1 3 7)和(2 4 8)可以通过MERGE-TO-FORM形成什么？
1, 3, 7 and 2, 4, 8 merge to form what?

263
00:15:20,910 --> 00:15:23,424
机器能够回答这样的问题
And that's a question it ought to be able to answer.

264
00:15:23,880 --> 00:15:27,360
这同样也是我们的Lisp程序所回答的问题
That's exactly the same question that our Lisp procedure answered.

265
00:15:28,180 --> 00:15:30,144
但这同样的规则
But the exact same rules

266
00:15:30,896 --> 00:15:34,800
也能够回答像这样的问题：
should also be able to answer a question like this:

267
00:15:36,192 --> 00:15:43,248
(1 3 7)和什么能够通过MERGE-TO-FORM形成(1 2 3 4 7 8)
1, 3, 7 and what merged to form 1, 2, 3, 4, 7, 8?

268
00:15:45,560 --> 00:15:47,808
同样的逻辑规则也能够回答这个
The same rules of logic can answer this,

269
00:15:47,840 --> 00:15:49,904
但我们编写的过程却无法回答这个问题
although the procedure we wrote can't answer that question.

270
00:15:50,800 --> 00:15:52,336
又或者 我们可以问
Or we might be able to say what

271
00:15:53,710 --> 00:16:01,120
什么和什么能通过MERGE-TO-FORM
what and what else merge to form--

272
00:16:04,288 --> 00:16:12,688
哪两个东西可以通过MERGE-TO-FORM形成(1 2 3 4 7 8)？
what and what else merge to form 1, 2, 3, 4, 7, 8?

273
00:16:13,780 --> 00:16:15,344
机器能够进行遍历
And the thing should be able to go through,

274
00:16:15,840 --> 00:16:17,312
如果它能应用这些逻辑规则的话
if it really can apply that logic,

275
00:16:17,792 --> 00:16:22,540
就能够推断出这个问题所有的2^6种答案
and deduce all, whatever is, 2 to the sixth answers to that question.

276
00:16:25,600 --> 00:16:27,690
因为可以分别是 (1)和其余的
Cause it could be 1 and the rester, or it could be 1, 2 and the rest.

277
00:16:27,696 --> 00:16:28,752
也可以是 (1 2)和其余的
or it could be 1, 2 and the rester.

278
00:16:28,790 --> 00:16:31,536
也可以是(1 3 7)和其余的
Or it could be 1 and 3 and 7 and the rest.

279
00:16:32,016 --> 00:16:33,264
有一大堆的答案
There's a whole bunch of answers.

280
00:16:33,410 --> 00:16:37,760
但原理上来说 逻辑能推断出所有的答案
And in principle, the logic should be enough to deduce that.

281
00:16:38,550 --> 00:16:42,032
因此这里面就有两个巨大的不同
So there are going to be two big differences

282
00:16:44,048 --> 00:16:46,000
在我们所编写的程序中
in the kind of program we're going to look at

283
00:16:46,540 --> 00:16:48,192
不只是Lisp程序
and not only Lisp,

284
00:16:48,208 --> 00:16:50,560
基本上是你们目前编写过的所有程序
but essentially all the programming you've probably done so far

285
00:16:52,032 --> 00:16:53,600
用你能叫出名字的程序语言所编写的程序
in pretty much any language you can think of.

286
00:16:54,150 --> 00:16:57,792
首先 我们并不准备计算一个函数
The first is, we're not going to be computing functions.

287
00:17:00,620 --> 00:17:02,016
我们将要讨论的东西
We're not going to be talking about

288
00:17:02,624 --> 00:17:04,410
并不具有输入和输出
about things that take input and output.

289
00:17:04,410 --> 00:17:05,824
我们讨论的是关系
We're going to be talking about relations.

290
00:17:06,890 --> 00:17:10,000
也就是说 原理上 关系是没有方向性的
And that means in principle, these relations don't have directionality.

291
00:17:11,080 --> 00:17:15,056
所以你指明用来回答这个问题的知识
So the knowledge that you specify to answer this question,

292
00:17:16,460 --> 00:17:18,416
也同样应该能够反过来
should be same, that same knowledge

293
00:17:18,432 --> 00:17:21,800
让你回答其它的这些问题
also allow you to answer these other questions and conversely.

294
00:17:26,608 --> 00:17:29,408
其次则是
And the second issue is that

295
00:17:29,616 --> 00:17:31,232
因为我们讨论的是关系
since we're talking about relations,

296
00:17:32,320 --> 00:17:34,448
关系的答案并不唯一
these relations don't necessarily have one answer.

297
00:17:35,610 --> 00:17:37,008
所以在第三个问题中
So that third question down there

298
00:17:37,020 --> 00:17:38,360
并没有特定的答案
doesn't have a particular answer,

299
00:17:38,400 --> 00:17:39,584
它有很多的答案
it has a whole bunch of answers.

300
00:17:42,270 --> 00:17:44,640
这就是我们的目标
Well, that's where we're going.

301
00:17:44,640 --> 00:17:45,904
顺便说一下
This style of programming,

302
00:17:46,720 --> 00:17:49,216
这种程序设计风格被称作逻辑式程序设计
by the way, is called logic programming,

303
00:17:50,224 --> 00:17:51,584
原因是显而易见的
for kind of obvious reasons.

304
00:17:56,160 --> 00:18:00,384
用逻辑式进行程序设计的那群人之间
And people who do logic programming say that --

305
00:18:00,400 --> 00:18:03,150
流传着几句箴言
they have this little phrase--

306
00:18:03,168 --> 00:18:04,672
他们把逻辑式程序设计的要点归纳为
they say the point of logic programming

307
00:18:04,768 --> 00:18:09,008
用逻辑来表达 什么算是“真的”
is that you use logic to express what is true,

308
00:18:10,096 --> 00:18:13,888
用逻辑来检测 是否是“真的”
you use logic to check whether something is true,

309
00:18:14,672 --> 00:18:17,248
用逻辑来找出这些“真的”
and you use logic to find out what is true.

310
00:18:19,200 --> 00:18:22,096
最为大家所熟知的逻辑式程序设计语言
The best known logic programming language,

311
00:18:22,976 --> 00:18:24,784
你们可能也听过 -- 叫做Prolog
as you probably know, is called Prolog.

312
00:18:25,780 --> 00:18:28,880
今天早上我们将要实现的这门语言
The language that we're going to implement this morning

313
00:18:29,824 --> 00:18:32,320
是一种查询语言
is something we call the query language,

314
00:18:32,480 --> 00:18:34,416
它基本上就是Prolog的本质了
and it essentially has the essence of prolog.

315
00:18:35,320 --> 00:18:36,736
它可以完成相同的工作
It can do about the same stuff,

316
00:18:37,290 --> 00:18:38,736
虽然它比Prolog慢得多
although it's a lot slower

317
00:18:38,736 --> 00:18:40,010
这是因为我们是通过Lisp来解释的
because we're going to implement it in LISP

318
00:18:41,904 --> 00:18:44,368
而非构造一个专门的编译器
rather than building a particular compiler.

319
00:18:44,464 --> 00:18:46,624
对它的解释 将运行在Lisp解释器之上
We're going to interpret it on top of the LISP interpreter.

320
00:18:47,510 --> 00:18:49,840
除此之外 它可以完成与Prolog相同的事儿
But other than that, it can do about the same stuff as prolog.

321
00:18:49,888 --> 00:18:52,784
不但同样的能力 也有同样的局限
It has about the same power and about the same limitations.

322
00:18:55,088 --> 00:18:56,176
好吧 先解答一下疑惑
All right, let's break for question.

323
00:19:00,430 --> 00:19:02,848
学生：您能再重复一下
AUDIENCE: Yes, could you please repeat what the three

324
00:19:03,488 --> 00:19:06,090
用逻辑去寻找的三件事么？
things you use logic programming to find?

325
00:19:06,720 --> 00:19:09,840
就是那些 找出什么为真 知道什么是真 等等
In other words, to find what is true, learn what is true-- what is the?

326
00:19:09,840 --> 00:19:10,520
教授：好的
PROFESSOR: Right.

327
00:19:10,560 --> 00:19:15,744
这算是程序员的某种“教义问答”
Sort of a logic programmer's little catechism.

328
00:19:15,850 --> 00:19:19,160
我们用逻辑来表达怎么算是“真的”
You use logic to express what is true,

329
00:19:20,800 --> 00:19:21,792
就像这些规则一样
like these rules.

330
00:19:22,610 --> 00:19:25,568
我们用逻辑来检测某事是否是“真的”
You use logic to check whether something is true,

331
00:19:25,600 --> 00:19:27,760
但在这里我没有回答这个问题
and that's the kind of question I didn't answer here.

332
00:19:28,550 --> 00:19:29,296
我可以问
I might say--

333
00:19:29,680 --> 00:19:32,144
在这里我可以这样来问
another question I could put down here is to say,

334
00:19:33,264 --> 00:19:36,560
(1 3 7)和(2 4 8)是否能够
is it true that 1, 3, 7 and 2, 4, 8

335
00:19:36,910 --> 00:19:40,380
通过MERGE-TO-FORM形成(1 2 6 19)
merge to form 1, 2, 6, 10

336
00:19:41,120 --> 00:19:44,688
同样的逻辑规则会告诉我们不行
And that same logic should be enough to say no.

337
00:19:45,690 --> 00:19:47,936
这里 我使用逻辑来检测是否为真
So I use logic to check what is true,

338
00:19:48,288 --> 00:19:50,480
然后 我们也可以使用逻辑来找出为真的东西
and then you also use logic to find out what's true.

339
00:20:04,464 --> 00:20:05,168
休息一下吧
Let's break.

340
00:20:06,130 --> 00:20:17,024
[音乐]
[JESU, JOY OF MAN'S DESIRING]

341
00:20:17,050 --> 00:20:20,688
《计算机程序的构造和解释》

342
00:20:47,590 --> 00:20:51,024
讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授

343
00:20:51,070 --> 00:20:55,600
《计算机程序的构造和解释》

344
00:20:55,630 --> 00:21:00,688
逻辑式程序设计

345
00:21:03,248 --> 00:21:04,976
教授：让我们继续来看一看
PROFESSOR: OK, let's go ahead and

346
00:21:05,840 --> 00:21:08,448
这个查询语言及其操作
take a look at this query language and operation.

347
00:21:10,520 --> 00:21:11,840
首先需要注意到
The first thing you might notice,

348
00:21:12,240 --> 00:21:14,144
当我建立好那个小型的圣经数据库后
when I put up that little biblical database,

349
00:21:14,160 --> 00:21:17,240
我们就能够针对一系列的事实
is that it's nice to be able to ask this language questions

350
00:21:17,488 --> 00:21:19,920
以关系的方式来向这个语言提问
in relation to some collection of facts.

351
00:21:21,330 --> 00:21:25,152
因此 我们先来陈述一些事实
So let's start off and make a little collection of facts.

352
00:21:26,060 --> 00:21:29,680
这是波士顿一家高科技公司的
This is a tiny fragment of personnel records

353
00:21:30,080 --> 00:21:32,624
一小部分人事档案
for a Boston high tech company,

354
00:21:33,056 --> 00:21:36,800
这部分档案是Ben Bitdiddle的
and here's a piece of the personnel records of Ben Bitdiddle.

355
00:21:37,500 --> 00:21:41,952
Bitdiddle是这家公司的计算机向导
And Ben Bitdiddle is the computer wizard in this company,

356
00:21:42,848 --> 00:21:45,808
他是这家公司的低薪向导
he's the underpaid computer wizard in this company.

357
00:21:46,420 --> 00:21:48,784
他的上司是Oliver Warbucks
His supervisor is all Oliver Warbucks,

358
00:21:49,280 --> 00:21:50,704
这里是他的住址
and here's his address.

359
00:21:52,150 --> 00:21:56,544
我们按照这样的格式给出信息：职务、薪水、上司、住址
So the format is we're giving this information: job, salary, supervisor, address.

360
00:21:57,568 --> 00:21:59,250
还有一些其它的约定
And there are some other conventions.

361
00:21:59,250 --> 00:22:02,224
这里的COMPUTER表示BEN在计算机分部工作
Computer here means that Ben works in the computer division, and

362
00:22:02,768 --> 00:22:04,944
而他在这个分部的工作是向导
his position in the computer division is wizard.

363
00:22:05,660 --> 00:22:07,152
这里是其他人的
Here's somebody else.

364
00:22:07,168 --> 00:22:12,280
ALyssa P.Hacker是一名计算机程序员
Alyssa, Alyssa P. Hacker is a computer programmer,

365
00:22:13,360 --> 00:22:14,608
她的上司是Ben
and she works for Ben,

366
00:22:15,216 --> 00:22:16,544
而她住在Cambridge
and she lives in Cambridge.

367
00:22:17,550 --> 00:22:19,424
Ben手下的另外一个程序员
And there's another programmer who works for Ben

368
00:22:20,032 --> 00:22:21,440
叫做Lem E. Tweakit
who's Lem E. Tweakit.

369
00:22:22,820 --> 00:22:26,736
实习程序员 Louis Reasoner
And there's a programmer trainee, who is Louis Reasoner,

370
00:22:27,424 --> 00:22:28,624
在Alyssa手下工作
and he works for Alyssa.

371
00:22:30,100 --> 00:22:35,456
公司里的“大老板”不为任何人工作
And the big wheel of the company doesn't work for anybody.

372
00:22:36,816 --> 00:22:38,110
这就是Oliver Warbucks的档案了
Right, That's Oliver Warbucks.

373
00:22:38,110 --> 00:22:39,312
我们将要做的就是
Anyway, what we're going to do is

374
00:22:40,944 --> 00:22:43,664
对这个小型的世界提问
is ask questions about that little world.

375
00:22:44,970 --> 00:22:48,400
这将是我们进行逻辑运算的样本世界
And that'll be a sample world that we're going to do logic in.

376
00:22:51,420 --> 00:22:54,960
我再最后一次强调一下
Let me just write up here, for probably the last time,

377
00:22:55,600 --> 00:22:58,208
你们应该从这门课中学到的最重要的知识
what I said is the very most important thing you should get out of this course,

378
00:22:58,800 --> 00:23:01,664
也就是 当别人向你介绍语言时
and that is, when somebody tells you about a language,

379
00:23:02,256 --> 00:23:04,432
你要问：“它的基本元素是什么？”
you say, fine-- what are the primitives,

380
00:23:06,120 --> 00:23:07,790
组合的手段有哪些？
what are the means of combination,

381
00:23:14,704 --> 00:23:16,400
如何把基本元素组织在一起
how do you put the primitives together,

382
00:23:16,672 --> 00:23:19,376
然后把它们抽象出来？
and then how do you abstract them,

383
00:23:19,968 --> 00:23:21,936
如何抽象这些复合元素
how do you abstract the compound pieces

384
00:23:24,688 --> 00:23:27,584
以便于你能够复用它们构造更复杂的东西？
so you can use them as pieces to make something more complicated?

385
00:23:29,024 --> 00:23:30,816
我已经强调过很多次了
And we've said this a whole bunch of times already,

386
00:23:31,168 --> 00:23:32,480
但还是值得重申一遍
but it's worth saying again.

387
00:23:35,008 --> 00:23:36,670
记住了么？我们开始了
OKay? Let's start.

388
00:23:36,670 --> 00:23:37,344
首先是基本元素
The primitives.

389
00:23:37,776 --> 00:23:39,440
这其中 只有唯一的基本元素
Well, there's really only one primitive,

390
00:23:40,960 --> 00:23:43,200
这门语言中的基本元素就是“查询”
and the primitive in this language is called a query.

391
00:23:44,144 --> 00:23:45,744
一条基本查询
A primitive query.

392
00:23:46,810 --> 00:23:48,256
我们先来看几条基本查询
Let's look at some primitive queries.

393
00:23:51,824 --> 00:23:53,024
首先 这条查询问的是
Alright. Job x.

394
00:23:53,100 --> 00:23:54,816
“谁是计算机程序员？”
Who is a computer programmer?

395
00:23:55,550 --> 00:23:59,888
或者可以解释为：找出数据库中
Or find every fact in the database

396
00:24:01,552 --> 00:24:06,144
所有JOB栏为COMPUTER PROGRAMMER的事实
that matches job of the x is computer programmer.

397
00:24:06,640 --> 00:24:08,016
这里有一些小语法
And you see a little syntax here.

398
00:24:08,470 --> 00:24:10,592
不带问号的都是字面量
Things without question marks are meant to be literal,

399
00:24:11,280 --> 00:24:13,152
?X表示X是变量
question mark x means that's a variable,

400
00:24:13,312 --> 00:24:15,568
而这条查询会匹配 比如说 --
and this thing will match, for example,

401
00:24:16,032 --> 00:24:19,008
Alyssa P. Hacker 是程序员
the fact that Alyssa P. Hacker is a computer programmer,

402
00:24:19,280 --> 00:24:21,930
其中X为Alyssa P. Hacker这条事实
or x is Alyssa P. Hacker.

403
00:24:26,820 --> 00:24:29,984
或者更一般地 我可以在一条查询中引入两个变量
Or more generally, I could have something with two variables in it.

404
00:24:30,750 --> 00:24:31,456
我可以问
I could say,

405
00:24:31,600 --> 00:24:35,888
?X的JOB必须是COMPUTER ?TYPE
the job of x is computer something,

406
00:24:39,344 --> 00:24:41,392
也就是会匹配COMPUTER WIZARD
and that'll match computer wizard.

407
00:24:42,140 --> 00:24:44,288
所以这里?TYPE可能会匹配WIZARD
So there's something here: type will match wizard,

408
00:24:44,928 --> 00:24:46,464
也可能会匹配PROGRAMMER
or type will match programmer,

409
00:24:47,488 --> 00:24:50,370
而?X会匹配不同的东西
or x might match various certain things.

410
00:24:50,370 --> 00:24:52,240
但在我们的这个小例子中
So there are, in our little example,

411
00:24:52,256 --> 00:24:55,150
数据库中只有三条事实符合那条查询
only three facts in that database that match that query.

412
00:24:59,120 --> 00:25:02,080
把语法说得再清楚一点 同样的查询
Let's see, just to show you some syntax, the same query,

413
00:25:05,296 --> 00:25:08,096
同样的这条指定了?X的JOB的查询
this query doesn't match the job of x,

414
00:25:09,856 --> 00:25:11,792
并不能够与Lewis Reasoner匹配
doesn't match Lewis Reasoner,

415
00:25:11,840 --> 00:25:13,648
这是因为我这里所写的
the reason for that is when I write something here,

416
00:25:14,224 --> 00:25:17,744
表示要匹配的是由两个符号构成的表
what I mean is that this is going to be a list of two symbols,

417
00:25:19,968 --> 00:25:21,968
其中首元素必须为单词“COMPUTER”
of which the first is the word computer,

418
00:25:22,320 --> 00:25:23,808
而第二个可以匹配任意的东西
and the second can be anything.

419
00:25:25,080 --> 00:25:27,320
而Lewis这里的工作描述有三个符号
And Lewis's job description here has three symbols,

420
00:25:27,808 --> 00:25:28,832
因此不匹配
so it doesn't match.

421
00:25:30,340 --> 00:25:32,192
你们还需要知道的一种语法是
And just to show you a little bit of syntax,

422
00:25:35,040 --> 00:25:38,320
更具一般性的点记号
the more general thing I might want to type is a thing with a dot here,

423
00:25:40,176 --> 00:25:42,928
这个标准的表记号表示的是
and this is just standard list notation for saying,

424
00:25:43,040 --> 00:25:43,824
首先这是一个表
this is a list,

425
00:25:44,128 --> 00:25:47,320
它的首元素为单词“COMPUTER”
of which the first element is the word computers,

426
00:25:47,584 --> 00:25:50,224
而其余的部分 我们把它们称作?TYPE
and THE REST, is something that I'll call type.

427
00:25:53,730 --> 00:25:55,504
因此这条查询就会匹配上
So this one would match.

428
00:25:56,930 --> 00:25:59,312
Lewis的工作是COMPUTER PROGRAMMER TRAINEE
Lewis's job is computer programmer trainee,

429
00:25:59,440 --> 00:26:03,296
而?TYPE的值将会是这个表的CDR部分
and type here would be the cdr of this list.

430
00:26:03,328 --> 00:26:05,648
也就是表(PROGRAMMER TRAINEE)
It would be the list programmer trainee.

431
00:26:06,960 --> 00:26:10,460
Lisp源码读取器会自动完成对点记号的处理
And that kind of dot processing is done automatically by the LISP reader.

432
00:26:15,900 --> 00:26:17,760
让我们来实际操作一下
Well, let's actually try this.

433
00:26:17,760 --> 00:26:20,512
我将向语言系统输入这些查询
The idea is I'm going to type in queries in this language,

434
00:26:20,768 --> 00:26:21,824
然后得到结果
and answers will come out.

435
00:26:22,544 --> 00:26:24,480
让我们在计算机中试试
Let's look at this.

436
00:26:25,180 --> 00:26:26,512
我可以问
I can go up and say,

437
00:26:27,344 --> 00:26:28,880
谁在计算机分部工作？
who works in the computer division?

438
00:26:30,000 --> 00:26:38,224
(JOB ?X (COMPUTER . ?Y)
Job of x is computer dot y.

439
00:26:39,730 --> 00:26:41,488
哑变量的名字并不重要
Doesn't matter what I call the dummy variables.

440
00:26:42,768 --> 00:26:44,144
查询的结果是
It says the answers to that,

441
00:26:44,416 --> 00:26:45,680
有四条记录
and it's found four answers.

442
00:26:48,650 --> 00:26:50,096
我也可以问
Or I can go off and say,

443
00:26:50,560 --> 00:26:52,384
大家的上司都是谁？
tell me about everybody's supervisor.

444
00:26:52,816 --> 00:26:54,880
我输入一条基本查询
So I'll put in the query, the primitive query,

445
00:26:56,528 --> 00:26:59,390
(SUPERVISOR ?X ?Y)
the supervisor of x is y.

446
00:27:02,560 --> 00:27:05,424
这些都是我所知道的上下级关系
There are all the supervisor relationships I know.

447
00:27:05,540 --> 00:27:08,830
或者我也可以问：“谁住在Cambridge？”
Or I could go type in, who lives in Cambridge?

448
00:27:08,830 --> 00:27:09,472
我就这么输入：
So I can say,

449
00:27:10,240 --> 00:27:20,928
(ADDRESS ?X (CAMBRIDGE . ?T))
the address of x is Cambridge dot anything.

450
00:27:25,090 --> 00:27:26,896
只有一个人住在Cambridge
And only one person lives in Cambridge.

451
00:27:30,820 --> 00:27:32,170
这些就是基本查询
OK, so those are primitive queries.

452
00:27:32,170 --> 00:27:34,960
你们看到的这些 就是与系统的基础交互
And you see what happens to basic interaction with the system

453
00:27:35,296 --> 00:27:39,248
你输入一条查询 他输出所有可能的查询
is you type in a query, and it types out all possible answers.

454
00:27:39,620 --> 00:27:40,656
换句话说 也就是
Or another way to say that:

455
00:27:40,670 --> 00:27:44,160
它找出这些变量所有可能的值
it finds out all the possible values of those variables

456
00:27:44,192 --> 00:27:45,872
不管它是叫X、Y还是T
x and y or t or whatever I've called them,

457
00:27:46,096 --> 00:27:52,080
然后它输出的是用所有可行值实例化该条查询的结果
and it types out all ways of taking that query and instantiating it--

458
00:27:52,920 --> 00:27:55,168
也就是规则系统那一课讲的“实例化”
remember that from the rule system lecture--

459
00:27:55,168 --> 00:27:58,830
用变量所有可能的值来实例化查询
instantiates the query with all possible values for those variables

460
00:27:59,008 --> 00:28:00,352
然后输出所有的结果
and then types out all of them.

461
00:28:01,000 --> 00:28:03,350
当然 还有不同的呈现结果的方式
And there are a lot of ways you can arrange a logic language.

462
00:28:03,350 --> 00:28:06,010
比如说 Prolog就有些不一样
Prolog, for instance, does something slightly different.

463
00:28:06,010 --> 00:28:07,440
它并不向你返回查询
Rather than typing back your query,

464
00:28:07,760 --> 00:28:10,784
Prolog会输出X=这个 Y=那个
prolog would type out, x equals this and y equals that,

465
00:28:10,976 --> 00:28:12,944
又或者X=这个 Y=那个
or x equals this and y equals that.

466
00:28:13,660 --> 00:28:15,488
这是使用界面层次的差别
And that's a very surface level thing,

467
00:28:15,712 --> 00:28:17,050
你可以根据你的喜好来决定
you can decide what you like.

468
00:28:18,976 --> 00:28:19,584
我们继续
OK.

469
00:28:21,008 --> 00:28:22,688
也就是说 这个语言中的基本元素
Alright. So the primitives in this language?

470
00:28:23,390 --> 00:28:24,570
只有一个 对吧？
Only one, right?

471
00:28:24,570 --> 00:28:27,230
也就是基本查询
Primitive query.

472
00:28:31,312 --> 00:28:32,560
来看看组合的手段
Means of combination.

473
00:28:34,330 --> 00:28:37,680
我们来考察一下这个语言中的复合查询
Let's look at some compound queries in this language.

474
00:28:39,770 --> 00:28:40,464
比如这条
Here's one.

475
00:28:41,790 --> 00:28:42,512
这条查询是说
This one says,

476
00:28:45,056 --> 00:28:48,224
列举出所有在计算机分部工作的人
tell me all the people who work in the computer division.

477
00:28:49,810 --> 00:28:52,000
在计算机分部工作的人
Tell me all the people who work in the computer division

478
00:28:52,544 --> 00:28:53,960
以及他们的上司
together with their supervisors.

479
00:28:56,800 --> 00:28:58,832
我使用AND来编写这条查询
Where I write that is the query is and.

480
00:29:00,220 --> 00:29:04,064
(AND (JOB ?X (COMPUTER . ?Y))
And the job of the x is computer something or other.

481
00:29:04,920 --> 00:29:06,832
(JOB ?X (COMPUTER . ?Y))
And job of x is computer dot y.

482
00:29:07,560 --> 00:29:10,032
并且(SUPERVISOR ?X ?Z)
And the supervisor of x is z.

483
00:29:11,440 --> 00:29:14,160
找出所有在计算机分部工作的人 -- 对应这条
Tell me all the people in the computer division-- that's this--

484
00:29:14,304 --> 00:29:15,888
以及它们的上司
together with their supervisors.

485
00:29:16,460 --> 00:29:17,824
注意这条查询中
And notice in this query

486
00:29:18,672 --> 00:29:22,416
我引入了三个变量 ?X ?Y 以及 ?Z
I have three variables-- x, y, and z.

487
00:29:23,584 --> 00:29:28,656
并且 这两个?X应该匹配同样的东西
And this x is supposed to be the same as that x.

488
00:29:29,450 --> 00:29:31,168
?X被约束在了计算机分部中
So x works in the computer division,

489
00:29:31,312 --> 00:29:33,008
并且?X的上司是?Z
and the supervisor of x is z.

490
00:29:34,810 --> 00:29:35,808
我们再来看一条
Let's try another one.

491
00:29:37,250 --> 00:29:39,280
AND算是一种组合手段
So one means of combination is and.

492
00:29:41,440 --> 00:29:43,968
哪些人的薪水超过$30,000？
Who are all the people who make more than $30,000?

493
00:29:45,712 --> 00:29:51,712
(AND (SALARY ?P ?A)
And the salary of some person p is some amount a.

494
00:29:54,590 --> 00:29:57,456
而关于?A的要求则是
And when I go and look at a,

495
00:29:57,488 --> 00:30:00,128
(LISP-VALUE > ?A 300000)
a is greater than $30,000.

496
00:30:00,600 --> 00:30:03,232
这里的LISP-VALUE是一个接口
And LISP value here is a little piece of interface

497
00:30:04,304 --> 00:30:10,048
用来连接查询语言与其底层的Lisp
that interfaces the query language to the underlying LISP.

498
00:30:10,600 --> 00:30:12,720
LISP-VALUE让你能够在查询
And what the LISP value allows you to do

499
00:30:12,752 --> 00:30:16,912
中调用任意的Lisp谓词
call any LISP predicate inside a query.

500
00:30:17,180 --> 00:30:20,112
因为我要用Lisp中的谓词> 所以我用LISP-VALUE
So here I'm using the LISP predicate greater than, so I say LISP value.

501
00:30:21,020 --> 00:30:21,750
所以这里我用了AND
This I say and.

502
00:30:21,750 --> 00:30:24,480
因此这样就查询出了薪水超过$30000的人
So all the people whose salary is greater than $30,000.

503
00:30:28,190 --> 00:30:30,032
或者这条更复杂的查询
Or here's a more complicated one.

504
00:30:31,270 --> 00:30:35,024
告诉我所有那些 在计算机分部中工作
Tell me all the people who work in the computer division

505
00:30:36,256 --> 00:30:39,360
但他的上司不在计算机分部工作的人
who do not have a supervisor who works in the computer division.

506
00:30:42,790 --> 00:30:45,510
(AND (JOB ?X (COMPUTER . ?Y))
and x works in the computer division.

507
00:30:45,510 --> 00:30:47,328
表示?X在计算机分部工作
The job of x is computer dot y.

508
00:30:47,780 --> 00:30:49,248
但是呢
And it's not the case

509
00:30:50,496 --> 00:30:54,256
?X的上司?Z
that both x has a supervisor z

510
00:30:55,376 --> 00:30:57,872
?Z的JOB不是形如(COMPUTER ...)一类的
and the job of z is computer something or other.

511
00:30:59,620 --> 00:31:00,352
同样的
All right, so again,

512
00:31:00,512 --> 00:31:02,384
这两个?X应该是一致的
this x has got to be that x,

513
00:31:03,200 --> 00:31:05,760
而这两个?Z也应该是一致的
and this z is going to be that z.

514
00:31:09,390 --> 00:31:11,380
你又了解了另一种组合手段 -- NOT
And then you see another means a combination, not.

515
00:31:17,712 --> 00:31:18,672
好了 再让我们来试试这些
All right, well, let's look at that.

516
00:31:20,880 --> 00:31:22,080
它同样起效
It works the same way.

517
00:31:22,400 --> 00:31:24,128
我可以问计算机：
I can go up to the machine and say

518
00:31:26,896 --> 00:31:35,400
(AND (JOB ?X (COMPUTER . ?Y)))
and the job of the x is computer dot y.

519
00:31:38,848 --> 00:31:45,952
另一个条件是(SUPERVISOR ?X ?Z)
And the supervisor of x is z.

520
00:31:46,832 --> 00:31:49,536
我把这条查询输入进去
And I typed that in like a query.

521
00:31:51,072 --> 00:31:52,976
计算机返回给我们的
And what it types back,

522
00:31:54,000 --> 00:31:58,736
计算机利用所有可能的答案把我的查询实例化了
what you see are the queries I typed in instantiated by all possible answers.

523
00:31:58,930 --> 00:32:00,080
你会发现有很多的答案
And then you see there are a lot of answers.

524
00:32:01,696 --> 00:32:02,144
好
All right.

525
00:32:02,190 --> 00:32:04,048
之所以把这门语言称作“逻辑语言”
So the means of combination in this language--

526
00:32:05,216 --> 00:32:06,608
是因为这门语言中的组合手段
and this is why it's called a logic language--

527
00:32:06,640 --> 00:32:09,472
都是逻辑运算
are logical operations.

528
00:32:09,800 --> 00:32:15,680
组合的手段有AND和NOT
Means of combinations are things like AND and NOT

529
00:32:15,968 --> 00:32:17,920
以及我还没有告诉你的OR
and there's one I didn't show you, which is OR.

530
00:32:18,490 --> 00:32:20,368
我还告诉过你LISP-VALUE
And then I showed you LISP value,

531
00:32:20,720 --> 00:32:24,480
当然 虽然它不是一个逻辑运算
which is a, not logic, of course,

532
00:32:24,512 --> 00:32:26,896
但是这个特殊的小技巧把它跟Lisp连接在了一起
but is a little special hack to interface that to LISP

533
00:32:27,344 --> 00:32:28,752
让你获得了更多的力量
so you can get more power.

534
00:32:29,250 --> 00:32:30,672
这些就是组合手段
Those are the means of combination.

535
00:32:32,592 --> 00:32:33,984
好 接着是抽象手段
OK, the means of abstraction.

536
00:32:34,160 --> 00:32:35,216
我们想要的是
What we'd like to do--

537
00:32:38,272 --> 00:32:41,248
想让我们回过头来看上一张幻灯片
let's go back for second and look at that last slide.

538
00:32:42,260 --> 00:32:44,256
我们想要把一些非常复杂的东西
We might like to take very complicated thing,

539
00:32:44,460 --> 00:32:48,000
比如不与上司在同一部门工作
the idea that someone works in a division

540
00:32:48,016 --> 00:32:50,090
的人的这种概念
but does not have a supervisor in the division.

541
00:32:52,400 --> 00:32:55,104
像以前一样 给它命名
And as before, name that.

542
00:32:56,090 --> 00:32:58,128
如果在某个分部工作的人
Well, if someone works in a division

543
00:32:58,176 --> 00:33:00,250
他的上司却不在那个分部工作
and does not have a supervisor who works in that division,

544
00:33:00,480 --> 00:33:01,936
这就意味着他是个“大腕”
that means that person is a big shot.

545
00:33:02,750 --> 00:33:05,136
这样 我们就定义一条规则指明
So let's make a rule that

546
00:33:06,432 --> 00:33:09,168
如果?X是某个部门的BIGSHOT
somebody x is a big shot in some department

547
00:33:10,912 --> 00:33:14,688
如果他在该部门工作
if x works in the department

548
00:33:16,048 --> 00:33:20,080
并且他的上司不在该部门工作
and it's not the case that x has a supervisor who works in the department.

549
00:33:21,510 --> 00:33:22,940
因此这就是我们的抽象手段
So this is our means of abstraction.

550
00:33:22,940 --> 00:33:23,904
这是一条规则
This is a rule.

551
00:33:26,220 --> 00:33:27,580
规则由三部分构成
And a rule has three parts.

552
00:33:31,008 --> 00:33:32,480
关键字RULE表明这是一条规则
The thing that says it's a rule.

553
00:33:33,408 --> 00:33:35,488
接着是规则的结论
And then there's the conclusion of the rule.

554
00:33:37,530 --> 00:33:39,072
然后是规则的体
And then there's the body of the rule.

555
00:33:40,000 --> 00:33:41,888
你可以把它解读为这样的一段逻辑：
And you can read this as a piece of logic which says,

556
00:33:41,920 --> 00:33:45,150
如果你知道规则的体为真
if you know that the body of the rule is true,

557
00:33:46,400 --> 00:33:48,720
那么你就可以推导出结论为真
then you can conclude that the conclusion is true.

558
00:33:49,456 --> 00:33:53,280
或者说为了推断出?X是某个部门的“大腕”
Or in order to deduce that x is a big shot in some department,

559
00:33:53,792 --> 00:33:55,712
这些条件足够验证了
it's enough to verify that.

560
00:33:57,480 --> 00:33:58,820
这就是规则的形式
So that's what rules look like.

561
00:34:03,280 --> 00:34:06,160
让我们回过头来看看
Let's go back and look at that merge example

562
00:34:06,736 --> 00:34:07,920
课间休息前我举的那个例子
that I did before the break.

563
00:34:08,110 --> 00:34:10,688
我们来看看 如果用规则来描述会是什么样的
Let's look at how that would look in terms of rules.

564
00:34:11,440 --> 00:34:12,848
我会抽取出其中的逻辑
I'm going to take the logic I put up

565
00:34:13,088 --> 00:34:15,500
并将它们变为这种格式的规则
and just change it into a bunch of rules in this format.

566
00:34:18,739 --> 00:34:19,350
就有了下面的规则
We have a rule.

567
00:34:19,350 --> 00:34:20,960
这就是MERGE-TO-FORM的规则
Remember, there was this thing merge-to-form.

568
00:34:21,710 --> 00:34:22,976
这个规则是说
There is a rule that says,

569
00:34:26,288 --> 00:34:29,620
'()与?Y可以通过MERGE-TO-FORM形成?Y
the empty list and y merge to form y.

570
00:34:29,620 --> 00:34:30,870
这是规则的结论
This is the rule conclusion.

571
00:34:33,210 --> 00:34:35,744
需要注意的是 这个特定的规则没有体
And notice this particular rule has no body.

572
00:34:36,650 --> 00:34:37,664
在这门语言中
And in this language,

573
00:34:38,112 --> 00:34:40,864
没有体的规则总是真的
a rule with no body is something that is always true.

574
00:34:41,239 --> 00:34:42,510
你总是可以假设它们为真
You can always assume that's true.

575
00:34:45,190 --> 00:34:46,496
另一条规则说的是
And there was another piece of logic

576
00:34:46,640 --> 00:34:49,460
任意对象与空表进行MERGE-TO-FORM 得到的任然是原物
that said anything in the empty list merged to form the anything.

577
00:34:49,460 --> 00:34:50,128
就是这条
That's this.

578
00:34:50,900 --> 00:34:53,552
(MERGE-TO-FORM ?Y '() ?Y)
A rule y and the empty list merge to form y.

579
00:34:55,510 --> 00:34:58,400
它们对应了我们MERGE过程中的两个终止条件
Those corresponded to the two end cases in our merge procedure,

580
00:34:58,448 --> 00:34:59,776
但我们现在讨论的是逻辑
but now we're talking about logic,

581
00:35:00,416 --> 00:35:01,456
而非过程
not about procedures.

582
00:35:03,490 --> 00:35:04,480
我们还有另外一条规则
Then we had another rule,

583
00:35:04,832 --> 00:35:08,736
描述的是 如果你知道如何MERGE较短的表
which said if you know how shorter things merge,

584
00:35:08,912 --> 00:35:09,830
那么你就可以把它们结合在一起
you can put them together.

585
00:35:09,830 --> 00:35:14,160
这条规则说：如果你有表?X、?Y以及?Z
So this says, if you have a list x and y and z,

586
00:35:14,928 --> 00:35:17,616
如果你想推断出(?A . ?X)
and if you want to deduce that a dot x--

587
00:35:17,632 --> 00:35:19,088
这个记法表示(CONS ?A ?X)
this means cons a onto x,

588
00:35:19,488 --> 00:35:22,368
或者说首元素是'A、剩余元素是'X的表
or a list whose first thing is a and whose rest is x--

589
00:35:23,160 --> 00:35:27,400
由此 如果你想推断(MERGE-TO-FROM (?A . ?X) (?B . ?Y) (?B . ?Z))
so if you want to deduce that a dot x and b dot y merge to form b dot z--

590
00:35:30,360 --> 00:35:33,904
毋宁说如果你想要把表(?A ?X)和表(?B ?Y)合并得到
that would say you merge these two lists a x and b y

591
00:35:33,920 --> 00:35:35,856
一个以?B为首的表
and you're going to get something that starts with b--

592
00:35:36,768 --> 00:35:40,672
你想要推断出这个结果 就要满足
you can deduce that if you know that it's the case

593
00:35:40,910 --> 00:35:44,480
不但(MERGE-TP-FORM (?A . ?X) ?Y ?Z)
both that a dot x and y merge to form z

594
00:35:45,184 --> 00:35:47,248
并且(LISP-VALUE > ?A ?B)
and a is larger than b.

595
00:35:48,690 --> 00:35:50,592
因此当我在合并它们时 ?B会首先出现在表中
So when I merge them, b will come first in the list.

596
00:35:51,824 --> 00:35:54,912
这就是简单的把我之前写的伪代码
That's a little translation of the logic rule

597
00:35:55,248 --> 00:35:57,184
翻译成逻辑的语言
that I wrote in pseudo-English before.

598
00:35:57,960 --> 00:36:01,632
为了翻译完整 这还里有种情况
And then just for completeness, here's the other case.

599
00:36:02,880 --> 00:36:05,952
(MERGE-TO-FORM (?A . ?X) (?B . ?Y) (?A . ?Z))成立
a dot x and b dot y merge to form a dot z

600
00:36:06,080 --> 00:36:09,168
就需要(MERGE-TO-FORM ?X (?B . ?Y) ?Z)
if x and b dot y merged to form z and b is larger than a.

601
00:36:09,472 --> 00:36:11,008
和(LISP-VALUE > ?B ?A)都成立
and b is larger than a.

602
00:36:12,190 --> 00:36:15,984
我已经把这个用逻辑语言编写的小程序输入计算机了
So that's a little program that I've typed in in this language,

603
00:36:16,016 --> 00:36:17,070
现在让我们来试着运行一下
and now let's look at it run.

604
00:36:21,900 --> 00:36:23,904
由于我已经输入过MERGE-TO-FORM的规则了
So I typed in the merge rules before,

605
00:36:24,624 --> 00:36:25,776
我就可以
and I could say, ahh

606
00:36:27,040 --> 00:36:28,510
我可以像过程一样使用它
I could use this like a procedure.

607
00:36:28,510 --> 00:36:38,240
我可以问(MERGE-TO-FORM (1 3) (2 7) ?X)
I could say merge to form 1 and 3 and 2 and 7.

608
00:36:39,424 --> 00:36:41,552
这里 我把它当作一个Lisp过程来使用
So here I'm using it like the LISP procedure.

609
00:36:43,168 --> 00:36:44,976
它先会思考一会儿
Now it's going to think about that for a while

610
00:36:46,432 --> 00:36:47,568
然后应用这些规则
and apply these rules.

611
00:36:50,780 --> 00:36:51,920
它找到了一个答案
So it found an answer.

612
00:36:52,800 --> 00:36:54,544
现在它还要继续寻找其它的答案
Now it's going to see if there are any other answers

613
00:36:55,072 --> 00:36:57,328
因为它事先不知道这里答案只有一个
it doesn't know a priori there's only one answer.

614
00:36:57,810 --> 00:36:59,904
因此它就在这里检查所有的可能性
So it's sitting here checking all possibilities,

615
00:37:00,416 --> 00:37:02,544
确认没有后 输出'DONE'
and it says, no more. Done.

616
00:37:03,168 --> 00:37:05,072
这里 我把它们当作过程来使用
So there I've used those rules like a procedure.

617
00:37:05,210 --> 00:37:09,056
不过要注意 我还可以问不同类型的问题
Or remember the whole point is that I can ask different kinds of questions.

618
00:37:10,220 --> 00:37:11,072
我可以问
I could say

619
00:37:18,560 --> 00:37:24,590
(MERGE-TO-FORM (2 ?A)
merge to form, let's see, how about 2 and a.

620
00:37:24,590 --> 00:37:27,904
一个我已知是以2为首的二元表
Some list of two elements which I know starts with 2,

621
00:37:29,376 --> 00:37:31,264
而另外一个东西是未知的
and the other thing I don't know,

622
00:37:33,056 --> 00:37:35,040
用?X来表示这个未知的表
and x and some other list

623
00:37:36,480 --> 00:37:39,510
可以通过MERGE-TO-FORM形成(1 2 3 4)
merge to form a 1, 2, 3 and 4.

624
00:37:42,760 --> 00:37:44,112
现在它将思考这个问题
So now it's going to think about that.

625
00:37:44,590 --> 00:37:49,408
它会找到 -- 它找到了一种可能
It's got to find--  so it found one possibility.

626
00:37:49,520 --> 00:37:52,464
比如A=3 X=(1 4)
It said a could be 3, and x could be the list 1, 4.

627
00:37:53,720 --> 00:37:55,168
现在 它又要继续检查
And now, again, it's got to check

628
00:37:56,560 --> 00:37:57,712
因为它事先并不知道
because it doesn't a priori know

629
00:37:57,744 --> 00:38:00,300
这里并没有其它的可能了
that there aren't any other possibilities going on.

630
00:38:03,680 --> 00:38:06,576
或者 就像我说过的
Or like I said,

631
00:38:07,008 --> 00:38:09,840
我可以问
I could say something like merge to form,

632
00:38:10,544 --> 00:38:17,552
能够通过MERGE-TO-FORM形成(1 2 3 4 5)的?X和?Y分别是什么？
like, what and what else merge to form 1, 2, 3, 4, 5?

633
00:38:23,680 --> 00:38:25,536
语言系统又要思考这个问题
Now it's going to think about that.

634
00:38:28,490 --> 00:38:30,310
它可能会得到很多答案
And there are a lot of answers that it might get.

635
00:38:35,180 --> 00:38:38,576
这里我们就体会到了缓慢的代价
And what you see is here you're really paying the price of slowness.

636
00:38:42,210 --> 00:38:43,880
大概是有三种原因造成这样
And kind of for three reasons.

637
00:38:43,880 --> 00:38:46,224
首先 这门语言经过了两次解释
One is that this language is doubly interpreted.

638
00:38:47,630 --> 00:38:49,728
然而在真正的实现中
Whereas in a real implementation,

639
00:38:49,760 --> 00:38:52,048
你应该把这些编译成基本运算
you would go compile this down to primitive operations.

640
00:38:52,190 --> 00:38:53,872
其次就是
The other reason is that

641
00:38:53,888 --> 00:38:58,112
这个MERGE算法 是双重递归的
this particular algorithm for merges is doubly recursive.

642
00:38:58,380 --> 00:39:00,064
因此它需要花费很长的时间
So it's going to take a very long time.

643
00:39:01,020 --> 00:39:04,336
最后呢 它又要遍历所有的情况
And eventually, this is going to go through

644
00:39:04,592 --> 00:39:07,130
找出 -- 找出什么呢？
and find-- find what?

645
00:39:07,130 --> 00:39:08,730
所有的2^5种可行解
Two to the fifth possible answers.

646
00:39:12,140 --> 00:39:14,960
我们发现它们以某种相当随意的顺序输出
And you see they come out in some fairly arbitrary order,

647
00:39:15,008 --> 00:39:18,144
这取决于它们用什么样的顺序尝试这些规则
depending on which order it's going to be trying these rules.

648
00:39:20,160 --> 00:39:22,112
事实上 在后期制作本视频时
In fact, what we're going to do when they edit the videotape

649
00:39:22,400 --> 00:39:23,480
我们将加速这段
is speed all this up.

650
00:39:24,080 --> 00:39:26,600
我们就不再这里浪费时间了
Don't you like taking out these waits?

651
00:39:26,600 --> 00:39:28,272
课后你们可以自行尝试
And don't you wish you could do that in your demos?

652
00:39:29,488 --> 00:39:34,240
好吧 它还在运行
Anyway, it's still grinding there.

653
00:39:39,220 --> 00:39:41,120
总之 一共有32种可能
Anyway, there are 32 possibilities--

654
00:39:41,136 --> 00:39:42,630
我们就不等到输出所有的结果了
we won't wait for it to print out all of them.

655
00:39:47,850 --> 00:39:50,448
因此 这门语言中的抽象手段就是RULE
OK, so the needs of abstraction in this language are rules.

656
00:39:53,536 --> 00:39:58,016
我们用逻辑把事物组织在一起
So we take some bunch of things that are put together with logic

657
00:39:59,120 --> 00:40:00,080
并为它们命名
and we name them.

658
00:40:00,350 --> 00:40:03,410
你们可以认为这是为一组特定的逻辑模式命名
And you can think of that as naming a particular pattern of logic.

659
00:40:03,410 --> 00:40:04,544
你们可以把它想做
Or you can think of that as saying,

660
00:40:04,560 --> 00:40:06,750
如果我们想要推断出某个结论
if you want to deduce some conclusion,

661
00:40:07,904 --> 00:40:09,520
就可以应用这些逻辑规则
you can apply those rules of logic.

662
00:40:10,660 --> 00:40:13,200
这些就是这门语言中的三种要素
And those are three elements of this language.

663
00:40:13,420 --> 00:40:14,560
我们先休息一会儿
Let's break now,

664
00:40:14,608 --> 00:40:16,590
然后再来讨论如何实际实现
and then we'll talk about how it's actually implemented.

665
00:40:23,616 --> 00:40:28,848
学生：使用LISP-VALUE之类的基本过程会影响
AUDIENCE: Does using LISP value primitive or whatever interfere with your means

666
00:40:29,152 --> 00:40:30,640
查询的双向性吗？
both directions on a query?

667
00:40:31,770 --> 00:40:34,480
教授：这个问题 -- 你问的是
PROFESSOR: OK, that's a-- the question is,

668
00:40:35,088 --> 00:40:36,928
使用LISP-VALUE是否会影响
does using LISP value interfere

669
00:40:37,536 --> 00:40:40,090
双向地推断一条查询
with the ability to go both directions on the query?

670
00:40:40,090 --> 00:40:42,816
虽然我们还没有实际讨论具体实现
We haven't really talked about the implementation yet,

671
00:40:43,680 --> 00:40:45,520
但是它们确实会造成影响
but the answer is, yes, it can.

672
00:40:46,890 --> 00:40:50,208
通常来说 我们最后将会发现
In general, as we'll see at the end--

673
00:40:50,224 --> 00:40:52,170
虽然我不会讲得太细
although I really won't to go into details--

674
00:40:53,216 --> 00:40:59,360
当你使用NOT和LISP-VALUE时 会变得相当复杂
it's fairly complicated, especially when you use either not or LISP value--

675
00:40:59,550 --> 00:41:02,890
或者实际上 只要你用了除AND以外的东西
or actually, if you use anything besides only and,

676
00:41:04,128 --> 00:41:08,192
很难再说清楚这些东西是否会起效了
it becomes very complicated to say when these things will work.

677
00:41:08,208 --> 00:41:10,360
它们并不是在任何情况下都有效
They won't work quite in all situations.

678
00:41:10,360 --> 00:41:13,392
我会在下一堂课的最后讨论这个问题
I'll talk about that at the end of the second half today.

679
00:41:14,300 --> 00:41:15,840
但对于你的问题来说：答案是“会影响”
But the answer to your question is, yes,

680
00:41:16,192 --> 00:41:19,216
用LISP-VALUE一方面从Lisp中获得了巨大威力
by dragging in a lot more power from LISP value,

681
00:41:19,408 --> 00:41:23,776
另一方面你失去了逻辑式程序设计的重要威力
you lose some of the principal power of logic programming.

682
00:41:24,170 --> 00:41:25,568
这是你需要做出的取舍
That's a trade-off that you have to make.

683
00:41:28,480 --> 00:41:29,392
好吧 先休息一会儿
OK, let's take a break.

684
00:41:30,176 --> 00:41:37,392
MIT OpenCourseWare
http://ocw.mit.edu

685
00:41:37,408 --> 00:41:44,304
本项目主页
https://github.com/DeathKing/Learning-SICP

