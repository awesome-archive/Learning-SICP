1
00:00:00,000 --> 00:00:01,968
Learning-SICP学习小组
倾情制作

2
00:00:01,980 --> 00:00:04,560
翻译&&时间轴：杨启钊（windfarer）
压制&&特效：邓雄飞（Dysprosium）
校对：邓雄飞（Dysprosium）

3
00:00:04,560 --> 00:00:06,560
特别感谢：裘宗燕教授

4
00:00:06,656 --> 00:00:09,472
计算机程序的构造和解释

5
00:00:09,920 --> 00:00:13,632
赋值、状态和副作用
Assignment, State, and Side-effects

6
00:00:18,311 --> 00:00:22,000
教授：到目前为止 我们已经教了很多编程技巧
PROFESSOR: Well, so far we've invented enough programming

7
00:00:22,256 --> 00:00:24,064
来编写复杂程序了
to do some very complicated things.

8
00:00:24,768 --> 00:00:29,660
并且 到目前为止 关于编程你们学到了很多
And you surely learned a lot about programming at this point.

9
00:00:29,660 --> 00:00:31,488
你们已经学习了几乎所有的
You've learned almost all the most important tricks

10
00:00:31,860 --> 00:00:35,872
那些拥有大量经验的人 才能领悟的技巧
that usually don't get taught to people until they have had a lot of experience.

11
00:00:36,416 --> 00:00:40,080
例如 数据导向编程就是一个主要的技巧
For example, data directed programming is a major trick,

12
00:00:40,750 --> 00:00:43,152
昨天 你们也学习了一种解释型语言
and yesterday you also saw an interpreted language.

13
00:00:45,024 --> 00:00:48,460
我们所做的这一切
We did this all in a computer language,

14
00:00:48,544 --> 00:00:49,632
目前来讲
at this point,

15
00:00:49,888 --> 00:00:51,952
都是在一种没有赋值语句的计算机语言中完成的
where there was no assignment statement.

16
00:00:53,770 --> 00:00:58,176
对于你们中用过Basic或者Pascal的人
And presumably, for those of you who've seen your Basic or Pascal or whatever,

17
00:00:58,688 --> 00:01:01,232
可能会认为“赋值”是最重要的东西
that's usually considered the most important thing.

18
00:01:01,792 --> 00:01:03,820
今天我们将要做一些糟糕的事情
Well today, we're going to do something horrible.

19
00:01:03,820 --> 00:01:05,456
我们要把赋值语句加进来
We're going to add an assignment statement.

20
00:01:07,216 --> 00:01:09,140
既然在没有赋值语句的时候 我们都可以很好地完成工作
And since we can do all these wonderful things without it,

21
00:01:09,140 --> 00:01:10,176
为什么我们还要把它加进来呢？
why should we add it?

22
00:01:10,990 --> 00:01:12,432
为了理解它
An important thing to understand it

23
00:01:12,464 --> 00:01:15,710
我们今天首先要定下一个规则
is that today we're going to first of all, have a rule,

24
00:01:16,480 --> 00:01:17,930
而我们将一直遵守这个规则
which is going to always be obeyed,

25
00:01:17,930 --> 00:01:20,800
这是我们为语言引入新的特性的唯一原因
which is the only reason we ever add a feature to our language

26
00:01:21,536 --> 00:01:23,140
是因为我们有一个好的理由
is because there is a good reason.

27
00:01:23,936 --> 00:01:27,280
好的理由归结为能力
And the good reason is going to boil down to the ability,

28
00:01:27,424 --> 00:01:31,510
你现在获得了把问题分解为不同部分的能力
you now get an ability to break a problem into pieces that are different sets of pieces

29
00:01:31,510 --> 00:01:33,440
在没有相关能力之前可不行
then you could have broken it down without that,

30
00:01:34,384 --> 00:01:36,160
这让你有用来分解问题的另外方法
give you another means of decomposition.

31
00:01:38,304 --> 00:01:39,450
我们这就开始
However, let's just start.

32
00:01:39,450 --> 00:01:41,880
从回顾我们的
Let me quick begin by reviewing

33
00:01:41,880 --> 00:01:47,376
现在已经有的这种语言出发
the kind of language that we have now.

34
00:01:48,160 --> 00:01:50,448
我们之前写的是所谓的函数式程序
We've been writing what's called functional programs.

35
00:01:51,216 --> 00:01:52,528
函数式程序
And functional programs

36
00:01:53,040 --> 00:01:57,952
是一种对数学事实的编码
are a kind of encoding of mathematical truths.

37
00:01:58,880 --> 00:02:00,510
例如 当我们看到
For example, when we look at

38
00:02:00,510 --> 00:02:04,096
像幻灯片上这样阶乘过程时
the factorial procedure that you see on the slide here,

39
00:02:05,072 --> 00:02:06,624
基本上是两个子句
it's basically two clauses.

40
00:02:06,992 --> 00:02:08,640
如果n是1 则结果是1
If n is one, the result is one,

41
00:02:08,640 --> 00:02:11,200
否则返回n乘以n-1的阶乘
otherwise n times factorial n minus one.

42
00:02:11,200 --> 00:02:12,336
这是n的阶乘
That's factorial of n.

43
00:02:12,896 --> 00:02:14,272
它就是阶乘函数
Well, that is factorial of n.

44
00:02:14,832 --> 00:02:16,870
如果用一些其他的记号
And written down in some other obscure notation

45
00:02:16,870 --> 00:02:19,328
那些你在微积分课堂上学到的晦涩的符号来写
that you might have learned in calculus classes,

46
00:02:20,304 --> 00:02:22,110
用数理逻辑来写
Ahh.. mathematical logic,

47
00:02:22,110 --> 00:02:26,368
如果n等于1
what you see there is if n equals one,

48
00:02:27,136 --> 00:02:29,900
那么n的阶乘结果是1 否则
for the result of n factorial is one, otherwise,

49
00:02:29,900 --> 00:02:32,560
如果n大于1 则n的阶乘就是n * (n-1)!
greater than one, n factorial is n times n minus one factorial.

50
00:02:32,560 --> 00:02:33,552
数学事实
True statements,

51
00:02:34,928 --> 00:02:36,700
就是我们一直使用的那种语言
that's the kind of language we've been using.

52
00:02:37,008 --> 00:02:39,230
无论何时 我们遇到了这样的数学事实
And whenever we have true statements of that sort,

53
00:02:39,536 --> 00:02:46,656
有一种理解它们工作原理的方法
there is a kind of, a way of understanding how they work

54
00:02:47,408 --> 00:02:51,120
就是这些过程可以由代换演算而来
which is that such processes can be evolved by substitution.

55
00:02:51,296 --> 00:02:53,712
来看第二张幻灯片
And so we see on the second slide here,

56
00:02:54,992 --> 00:02:58,816
我们理解执行的过程
that the way we understand the execution

57
00:02:58,832 --> 00:03:03,500
隐含在表达式的顺序中
implied by those statements in arranged in that order,

58
00:03:04,040 --> 00:03:07,760
也就是你不断地将实际参数
is that you do successive substitutions of arguments

59
00:03:07,870 --> 00:03:10,880
代换到程序体的形式参数中
for formal parameters in the body of a procedure.

60
00:03:12,000 --> 00:03:14,512
这些基本上是一系列的等价代换
This is basically a sequence of equalities.

61
00:03:14,610 --> 00:03:17,250
4的阶乘是4乘以3的阶乘
Factorial four is four times factorial three.

62
00:03:17,250 --> 00:03:20,050
也就是4乘以3乘以2的阶乘
That is four times three times factorial of two

63
00:03:20,050 --> 00:03:21,010
以此类推
and so on.

64
00:03:21,232 --> 00:03:23,872
我们总是保持数学事实成立
We're always preserving truth.

65
00:03:25,232 --> 00:03:28,840
尽管我们正在讨论数学事实
Even though we're talking about true statements,

66
00:03:28,840 --> 00:03:31,960
可能有多种数学事实的组织方式
there might be more than one organization of these true statements

67
00:03:31,960 --> 00:03:35,120
用来描述一个特定的函数的计算
to describe the computation of a particular function,

68
00:03:36,320 --> 00:03:38,420
这个特定的函数的值的计算
the computation of the value of a particular function.

69
00:03:38,420 --> 00:03:40,928
所以 让我来看下这里的例子
So, for example, looking at the next one here.

70
00:03:41,488 --> 00:03:49,020
这有一个计算m与n之和的方法
Here is a way of looking at the sum of n and m.

71
00:03:49,536 --> 00:03:52,048
我们使用一个递归的过程来完成
And we did this one by a recursive process.

72
00:03:52,896 --> 00:03:58,160
也就是(1+ (+ (-1+ n) m))
It's the increment of the sum of the decrement of n and m.

73
00:04:00,080 --> 00:04:05,620
当然 这里也有相应的数理逻辑 解释了这个方法
And, of course, there is some piece of mathematical logic here that describes that.

74
00:04:06,176 --> 00:04:10,496
也就是((n-1)+m)+1
It's the increment of the sum of the decrement of n and m,

75
00:04:11,408 --> 00:04:12,224
跟之前那个一样
just like that.

76
00:04:13,104 --> 00:04:16,400
所以这儿并没有什么特殊的魔法
So there's nothing particularly magic about that.

77
00:04:16,416 --> 00:04:20,010
当然 如果我们可以再来看一个相同的迭代过程
And, of course, if we can also look at an iterative process for the same,

78
00:04:20,192 --> 00:04:24,920
计算同样的函数 但是进行逐步迭代的程序
a program that evolves an iterative process, for the same function.

79
00:04:25,264 --> 00:04:27,568
这两个程序将得到同样的结果
These are two things that compute the same answer.

80
00:04:30,080 --> 00:04:34,832
我们就可以认为这两个程序在数学上是等效的
And we have equivalent mathematical truths that are arranged there.

81
00:04:36,656 --> 00:04:39,936
你对这些数学事实的排序 决定了具体（计算）过程
And just the way you arrange those truths determine the particular process.

82
00:04:40,304 --> 00:04:43,424
我们对于这些数学事实的排序和选择 决定了过程发展的方式
In the way choose and arrange them determines the process that's evolved.

83
00:04:44,336 --> 00:04:48,600
因此我们可以灵活地讨论待计算的函数
So we have the flexibility of talking about both the function to be computed,

84
00:04:48,600 --> 00:04:50,192
以及计算该函数的所用的方法
and the method by which it's computed.

85
00:04:50,600 --> 00:04:52,600
这并不清晰 我们需要再深入一些
So it's not clear we need more.

86
00:04:53,616 --> 00:04:55,500
然而 今天我要来讲这个糟糕的东西
However, today I'm going to this awful thing.

87
00:04:55,500 --> 00:04:58,432
我要给大家介绍赋值操作
I'm going to introduce this assignment operation.

88
00:04:58,896 --> 00:05:00,416
这是什么？
Now, what is this?

89
00:05:02,896 --> 00:05:09,220
首先 在编程语言中有另一种语句
Well, first of all, there is going to be another kind of kind of statement, if you will,

90
00:05:09,220 --> 00:05:10,848
这种语句叫做SET!
in a programming language called Set!

91
00:05:12,410 --> 00:05:15,968
具有赋值操作的语句
And SET! -- Things that do things like assignment,

92
00:05:15,984 --> 00:05:17,850
我都会在后面加上一个感叹号
I'm going to put exclamation points after.

93
00:05:18,512 --> 00:05:20,960
这个感叹号代表什么意思呢？
We'll talk about what that means in a second.

94
00:05:20,960 --> 00:05:23,010
这个感叹号 与问号类似
The exclamation point, again like question mark,

95
00:05:23,010 --> 00:05:25,880
是我们给名字随意加的符号
is an arbitrary thing we attach to the symbol which is the name,

96
00:05:25,880 --> 00:05:27,880
它对于系统来说没有意义
has no significance to the system.

97
00:05:28,080 --> 00:05:30,210
它唯一的意义就是告诉我们
The only significance is to me and you

98
00:05:30,400 --> 00:05:34,416
注意这里是某种赋值操作
to alert you that this is an assignment of some sort.

99
00:05:35,880 --> 00:05:40,064
但是我们要给某个变量赋一个值
But we're going to set a variable to a value.

100
00:05:43,744 --> 00:05:45,130
这意味着
And what that's going to mean

101
00:05:45,130 --> 00:05:48,288
在某个时间点发生了一些事情
is that there is a time at which something happens.

102
00:05:48,656 --> 00:05:49,616
这是一个时间点
Here's a time.

103
00:05:49,860 --> 00:05:52,144
如果时间以这个方向流动
If I have time going this way,

104
00:05:53,504 --> 00:05:54,820
这是个时间轴
it's a time axis.

105
00:05:55,008 --> 00:05:57,820
时间在平面上由上到下地流逝
Time progresses by walking down the page.

106
00:05:58,704 --> 00:06:00,920
赋值是第一个
Then an assignment is the first thing we have

107
00:06:00,920 --> 00:06:04,304
使过去和未来之间产生差别的事物
that produces the difference between a before and an after.

108
00:06:06,592 --> 00:06:08,720
我们之前写的所有程序
All the other programs that we've written,

109
00:06:09,184 --> 00:06:10,680
都不包含赋值
that have no assignments in them,

110
00:06:10,680 --> 00:06:13,120
这些程序以怎样的顺序进行执行都没关系
the order in which they were evaluated didn't matter.

111
00:06:14,704 --> 00:06:15,960
但是赋值比较特殊
But assignment is special,

112
00:06:15,960 --> 00:06:17,696
它使时间中产生了一个时间点
it produces a moment in time.

113
00:06:17,960 --> 00:06:24,736
因此在SET!出现之前和之后中间有一个时间点
So there is a moment before the set occurs and after,

114
00:06:27,616 --> 00:06:32,704
使得在这个时间点之后
such that after this moment in time,

115
00:06:33,600 --> 00:06:43,760
变量有了一个值 即VALUE
the variable has the value, value.

116
00:06:49,232 --> 00:06:51,504
与这个变量之前的值无关
Independent of what value it had before,

117
00:06:52,800 --> 00:06:55,792
SET!改变了它的值
set! changes the value of the variable.

118
00:06:57,696 --> 00:06:58,750
在此之前
Until this moment,

119
00:06:58,750 --> 00:07:01,504
什么都没有发生改变
we had nothing that changed.

120
00:07:03,216 --> 00:07:04,112
举例来说
So, for example,

121
00:07:04,848 --> 00:07:06,230
我们可以想到的一件事是
one of the things we can think of

122
00:07:06,230 --> 00:07:09,420
我们写的一些过程 比如阶乘的程序
is that the procedures we write for something like factorial

123
00:07:09,648 --> 00:07:12,752
事实上与数学中的阶乘函数完全相同
are in fact pretty much identical to the function factorial.

124
00:07:13,776 --> 00:07:16,448
比如说4的阶乘 如果我写FACT(4)
Factorial of four, if I write fact4,

125
00:07:17,232 --> 00:07:19,152
无论它的上下文是怎样的
independent of what context it's in,

126
00:07:19,696 --> 00:07:21,290
无论我写几遍
and independent of how many times I write it,

127
00:07:21,290 --> 00:07:22,352
我总能得到同样的结果
I always get the same answer.

128
00:07:23,290 --> 00:07:24,128
结果永远是24
It's always 24.

129
00:07:25,376 --> 00:07:28,928
它是参数到到结果的唯一映射
It's a unique map from the argument to the answer.

130
00:07:30,304 --> 00:07:32,656
迄今为止 我们之前写的所有程序都是这样的
And all the programs we've written so far are like that.

131
00:07:33,520 --> 00:07:36,032
然而 当引入赋值后 一切就不同了
However, once I have assignment, that isn't true.

132
00:07:36,960 --> 00:07:38,160
举个例子
So, for example,

133
00:07:39,184 --> 00:07:48,528
如果我将COUNT定义为1
if I were to define count to be one.

134
00:07:50,000 --> 00:07:52,416
然后定义一个过程
And then I'm going to define also a procedure,

135
00:07:55,168 --> 00:07:56,832
一个叫做DEMO的简单过程
a simple procedure called demo,

136
00:07:59,520 --> 00:08:03,840
它接受参数X 并执行下面的操作
which takes argument x and does the following operations.

137
00:08:03,840 --> 00:08:09,620
首先将X修改为X+1
It first sets x to x plus one.

138
00:08:09,620 --> 00:08:11,776
我的天啊！ 这看起来就像FORTRAN是吧？
My gosh, this looksjust like FORTRAN, right--

139
00:08:13,168 --> 00:08:14,176
只是用了些有趣的语法
in a funny syntax.

140
00:08:16,800 --> 00:08:21,376
然后返回(+ X COUNT)
And then add to x count,

141
00:08:22,144 --> 00:08:24,144
哦 我刚犯了个错
Oh, I just made a mistake.

142
00:08:24,384 --> 00:08:25,232
我的意思是
I want to say,

143
00:08:25,472 --> 00:08:27,120
(SET! COUNT (1+ COUNT))
set! count to one plus count.

144
00:08:30,370 --> 00:08:31,792
就是我在这里定义的这个
It's this thing defined here.

145
00:08:34,416 --> 00:08:36,512
然后X和COUNT相加
And then add and said plus x count.

146
00:08:40,352 --> 00:08:42,064
然后就可以试着运行这个过程了
Then I can try this procedure.

147
00:08:42,480 --> 00:08:43,200
让我们运行它
Let's run it.

148
00:08:43,920 --> 00:08:47,220
假设我可以输入
So, suppose I get a prompt and I say,

149
00:08:47,488 --> 00:08:48,688
输入(DEMO 3)
demo 3

150
00:08:52,192 --> 00:08:53,200
这里发生了什么？
Well, what happens here?

151
00:08:53,740 --> 00:08:55,280
发生的第一件事情是
The first thing that happens

152
00:08:55,536 --> 00:08:56,890
COUNT现在是1
is count is currently one.

153
00:08:56,890 --> 00:08:58,400
现在 这是一个时间点
Currently, there is a time.

154
00:08:59,120 --> 00:09:00,290
我们在讨论时间点
We're talking about time.

155
00:09:00,624 --> 00:09:01,744
X的值为3
x gets three.

156
00:09:02,928 --> 00:09:04,032
在这个时刻
At this moment,

157
00:09:04,672 --> 00:09:07,536
COUNT增加了 所以COUNT是2
I say, oh yes, count is incremented, so count is two.

158
00:09:09,024 --> 00:09:10,448
2加3等于5
two plus three is five.

159
00:09:10,800 --> 00:09:12,432
所以结果是5
So the answer I get out is five.

160
00:09:14,480 --> 00:09:21,584
然后我再一次 输入(DEMO 3)
Then I say, demo of say, three again.

161
00:09:23,600 --> 00:09:24,560
结果是什么？
Okay, What do I get?

162
00:09:24,830 --> 00:09:27,408
现在COUNT是2 它不再是1了
Well, now count is two, it's not one anymore,

163
00:09:28,912 --> 00:09:30,352
因为我让COUNT加1了
because I have incremented it.

164
00:09:30,920 --> 00:09:32,640
但现在我执行这个过程
But now I go through this process,

165
00:09:32,720 --> 00:09:33,664
X的值为3
three goes into x,

166
00:09:34,176 --> 00:09:37,408
COUNT变为1+COUNT 因此现在是3了
count becomes one plus count, so that's three now.

167
00:09:38,080 --> 00:09:39,620
这两个相加是6
The sum of those two is six,

168
00:09:39,620 --> 00:09:40,944
所以结果是6
so the answer is six.

169
00:09:41,920 --> 00:09:43,030
我们可以发现
And what we see

170
00:09:43,030 --> 00:09:44,720
同样的表达式
is the same expression

171
00:09:45,088 --> 00:09:46,640
因为时间节点的不同
leads to two different answers,

172
00:09:48,752 --> 00:09:49,968
得到了不同的结果
depending upon time.

173
00:09:52,080 --> 00:09:53,744
所以DEMO不是函数
So demo is not a function,

174
00:09:54,176 --> 00:09:56,128
或者说它并没有计算一个数学意义上的函数
does not compute a mathematical function.

175
00:09:59,888 --> 00:10:02,096
事实上 你可以知道这是为什么
In fact, you could also see why now, of course,

176
00:10:02,848 --> 00:10:06,416
因为这里是第一处代换模型失效的地方
this is the first place where the substitution model isn't going to work.

177
00:10:07,728 --> 00:10:09,552
它给代换模型判了死刑
This kills the substitution model dead.

178
00:10:11,280 --> 00:10:13,824
有些关于引用的一些小问题
You know, with quotation there were some little problems

179
00:10:13,856 --> 00:10:17,180
哲学家可能注意到 特别是与代换有关时
that a philosopher might notice with substitutions,

180
00:10:17,180 --> 00:10:19,872
因为当你在引用中进行代换时
because you have to worry about what deductions you can make

181
00:10:20,912 --> 00:10:22,128
需要考虑你可以得到什么样的推论
when you substitute into quotes,

182
00:10:22,340 --> 00:10:23,920
如果你能够使用代换的话
if you're allowed to do that at all.

183
00:10:25,088 --> 00:10:25,600
但是
But

184
00:10:26,064 --> 00:10:28,000
在这里代换模型已经失效了
here the substitution model is dead,

185
00:10:28,110 --> 00:10:29,408
它什么也不能做了
can't do anything at all.

186
00:10:29,640 --> 00:10:30,570
因为
Because,

187
00:10:30,570 --> 00:10:35,856
假设我想用代换模型来考虑COUNT的代换
Supposing I wanted to use a substitution model to consider substituting for count?

188
00:10:37,104 --> 00:10:41,168
如果我在这里和这里进行代换
Well, my gosh, if I substitute for here and here,

189
00:10:41,696 --> 00:10:42,960
它们是不同的
they're different ones.

190
00:10:44,448 --> 00:10:45,968
它不再是同一个COUNT了
It's not the same count any more.

191
00:10:46,480 --> 00:10:47,648
我得到了错误的结果
I get the wrong answer.

192
00:10:47,970 --> 00:10:50,144
代换模型是一个静态的现象
The substitution model is a static phenomenon

193
00:10:51,184 --> 00:10:52,560
它描述的事实
describes things that are true

194
00:10:53,936 --> 00:10:55,296
而不是变动
and not things that change.

195
00:10:55,500 --> 00:10:57,040
这里 我们的事实变动了
Here, we have truths that change.

196
00:11:00,608 --> 00:11:06,740
那么 在我给出任何解释之前
OK, Well, before I give you any understanding of this,

197
00:11:06,740 --> 00:11:07,790
这很糟糕
this is very bad.

198
00:11:07,790 --> 00:11:09,728
我们失去了我们的计算模型
Now, we've lost our model of computation.

199
00:11:10,288 --> 00:11:10,800
并且
And,

200
00:11:11,488 --> 00:11:13,696
很快 我将不得不构建一个新的计算模型
pretty soon, I'm going to have to build you a new model of computation.

201
00:11:14,660 --> 00:11:17,872
我们现在的讨论 还是从一个不严谨的角度进行的
But ours plays with this, just now, in an informal sense.

202
00:11:18,560 --> 00:11:20,160
当然 你们已经看到的是
Of course, what you already see

203
00:11:20,512 --> 00:11:22,704
当我做一些像赋值之类的事情时
is that when I have something like assignment,

204
00:11:23,120 --> 00:11:24,510
我们所需要的模型
the model that we're going to need

205
00:11:24,510 --> 00:11:26,890
与我们之前模型不同
is different from the model that we had before

206
00:11:26,890 --> 00:11:30,930
在这个的模型中 像COUNT或X这样的符号
in that, the variables, those symbols like count, or x

207
00:11:30,930 --> 00:11:34,070
不再关联于它们的值
are no longer going to refer to the values they have,

208
00:11:34,070 --> 00:11:37,312
而是关联于某个储存这些值的地方
but rather to some sort of place where the value restored.

209
00:11:37,680 --> 00:11:39,472
我们将花些时间来适应这种思想
We're going to have to think that way for a while.

210
00:11:40,208 --> 00:11:42,110
这将是一个很糟糕的事情
And it's going to be a very bad thing

211
00:11:42,110 --> 00:11:43,472
并且会造成很多麻烦
and cause a lot of trouble.

212
00:11:44,496 --> 00:11:48,250
所以 就像我说的 若非理由周全
And so, as I said, the very fact that we're inventing this bad thing,

213
00:11:48,250 --> 00:11:50,096
不然绝不要发明这种糟糕的东西
means that there had better be a good reason for it,

214
00:11:50,370 --> 00:11:52,864
否则 就是劳神费力
otherwise, just a waste of time and a lot of effort.

215
00:11:53,392 --> 00:11:55,552
让我们看看一些可以讨论的东西
Let's just look at some of it just to play.

216
00:11:55,880 --> 00:11:58,590
假设我们写了函数式版本的阶乘函数
Supposing we write down the functional version,

217
00:11:58,590 --> 00:12:00,480
我们以前的就是“函数式”风格
functional meaning in the old style,

218
00:12:01,376 --> 00:12:04,608
具有迭代计算过程的阶乘函数
of factorial by an iterative process.

219
00:12:09,590 --> 00:12:13,280
N的阶乘
Factorial of n.

220
00:12:18,384 --> 00:12:24,352
我们要(ITER M I)
we're going to iterate of m and i,

221
00:12:26,128 --> 00:12:33,136
就是说如果I大于N
which says if i is greater than n,

222
00:12:33,776 --> 00:12:35,510
则结果是M
then the result is m,

223
00:12:36,304 --> 00:12:37,392
否则
otherwise,

224
00:12:39,792 --> 00:12:46,820
结果是(ITER (* I M))
the result of iterating the product of i and m.

225
00:12:46,820 --> 00:12:49,952
所以M将是我累积的结果
So m is going to be the product that I'm accumulating.

226
00:12:51,584 --> 00:12:52,624
M就是这个乘积[注：此处教授笔误]
m is the product.

227
00:12:57,970 --> 00:13:00,176
然后我要把COUNT加1
And the count I'm going to increase by one.

228
00:13:04,620 --> 00:13:10,976
（闭合括号中）
Plus, ITER, ELSE, COND, define.

229
00:13:11,952 --> 00:13:13,040
我在这里启动这个内部过程
I'm going to start this up.

230
00:13:17,168 --> 00:13:19,792
对于这种代码 我想大家早已驾轻就熟了
And these days, you should have no trouble reading something like this.

231
00:13:20,864 --> 00:13:25,152
这里是一个累积的乘积 和一个计数器
What I have here is a product there being accumulated and a counter.

232
00:13:26,480 --> 00:13:28,464
我让它们都从1开始
I start them up both at one.

233
00:13:28,896 --> 00:13:30,920
我将不断让计数器增加
I'm going to buzz the counter up,

234
00:13:30,920 --> 00:13:33,120
每一轮I变成I+1
i goes to i plus one every time around.

235
00:13:34,560 --> 00:13:37,472
这是我们在这个过程中设置时间的唯一方法
But that's only way our putting a time on the process,

236
00:13:38,480 --> 00:13:40,048
这些都是一系列的事实
each of this is just a set of truths,

237
00:13:40,496 --> 00:13:41,344
真实的规则
true rules.

238
00:13:42,816 --> 00:13:46,130
M将获得一个新的值 就是I乘M
And m is going to get a new values of i and m,

239
00:13:46,130 --> 00:13:47,824
每一轮I乘以M
i times m each time around,

240
00:13:48,680 --> 00:13:50,480
最终I将大于N
and eventually i is going to be bigger than n,

241
00:13:50,496 --> 00:13:52,060
在这种情况下 结果就是M
in which case, the answer's going to be m.

242
00:13:52,672 --> 00:13:54,800
我给你们讲课的时候 用到了“时间”这个概念
Now, I'm speaking to you, use time in this.

243
00:13:55,680 --> 00:13:57,456
那是因为我知道计算机是怎么工作的
That's just because I know how the computer works.

244
00:13:58,256 --> 00:13:59,248
但是我没必要这么做
But I didn't have to.

245
00:13:59,264 --> 00:14:02,300
这完全可以有一个纯数学的解释
This could be a purely mathematical description at this point,

246
00:14:02,300 --> 00:14:03,744
因为在这里代换可以工作
because substitution will work for this.

247
00:14:05,104 --> 00:14:08,140
但是我们写一个类似的程序
But let's set right down a similar sort of program,

248
00:14:08,304 --> 00:14:09,952
使用相同的算法
using the same algorithm,

249
00:14:10,736 --> 00:14:12,112
但使用了赋值
but with assignments.

250
00:14:15,696 --> 00:14:17,168
所以这个叫做函数式版本
So this is called the functional version.

251
00:14:23,728 --> 00:14:25,568
我想写个命令式的版本的
I want to write down an imperative version.

252
00:14:34,480 --> 00:14:35,392
N的阶乘
Factorial of n.

253
00:14:35,920 --> 00:14:37,744
我要创建两个变量
I'm going to create my two variables.

254
00:14:40,160 --> 00:14:45,536
把I的值初始化为1
Let i initialize itself to one,

255
00:14:46,320 --> 00:14:49,776
M也初始化为1
and m be initialized to one, similar.

256
00:14:51,152 --> 00:14:52,192
我们创建一个循环
We'll create a loop

257
00:14:59,312 --> 00:15:07,270
如果I比N大 循环结束
which has COND greater than i, and if i is greater than n, we're done.

258
00:15:07,270 --> 00:15:08,870
结果是M
And the result is m,

259
00:15:08,870 --> 00:15:10,384
也就是我累积的乘积
the product I'm accumulating.

260
00:15:10,870 --> 00:15:11,776
否则
Otherwise,

261
00:15:15,520 --> 00:15:17,408
我接下来要做三件事
I'm going to write down three things to do.

262
00:15:19,264 --> 00:15:27,056
我要把M赋值为I*M
I'm going to set! m to the product of i and m,

263
00:15:29,360 --> 00:15:35,200
把I赋值为I+1
set! i to the sum of i and one,

264
00:15:37,856 --> 00:15:39,312
然后继续循环
and go around the loop again.

265
00:15:40,410 --> 00:15:43,024
你们中的FORTRAN程序员应该觉得眼熟
Looks very familiar to you FORTRAN programmers.

266
00:15:44,736 --> 00:15:46,640
（闭合括号中）
ELSE, COND, define,

267
00:15:46,640 --> 00:15:47,888
就是这种语法有点陌生
funny syntax though.

268
00:15:51,136 --> 00:15:52,272
启动循环
Start the loop up,

269
00:15:56,100 --> 00:15:57,568
程序就写完了
and that's the program.

270
00:15:59,152 --> 00:16:00,528
那么 这个程序
Now, this program,

271
00:16:01,312 --> 00:16:02,496
我们应该怎么思考它呢？
how do we think about it?

272
00:16:02,710 --> 00:16:04,256
先来看看这里是什么
Well, let's just say what we're seeing here.

273
00:16:04,848 --> 00:16:07,470
这里有两个局部变量 I和M
There are two local variables, i and m,

274
00:16:07,470 --> 00:16:09,024
它们都被初始化为1
that have been initialized to one.

275
00:16:10,720 --> 00:16:13,890
在每一次循环里 我检测I是否大于N
Every time around the loop, I test to see if i is greater than n,

276
00:16:13,890 --> 00:16:15,088
就是我们传入的参数
which is the input argument,

277
00:16:15,300 --> 00:16:18,144
如果成立的话 结果就是M中所累积的乘积
and if so, the result is the product being accumulated in m.

278
00:16:19,168 --> 00:16:21,210
然而 如果循环没有结束
However, if it's not the end of the loop,

279
00:16:21,210 --> 00:16:22,896
如果我们的工作没有结束
if I'm not done,

280
00:16:23,640 --> 00:16:25,552
则我们要把乘积
then what I'm going to do is change the product

281
00:16:25,840 --> 00:16:28,384
变为i与当前乘积的结果
to be the result of multiplying i times the current product.

282
00:16:29,040 --> 00:16:30,688
就是我们在这里做过的事情
Which is sort of what we were doing here.

283
00:16:31,424 --> 00:16:32,688
除了这里我没有改动
Except here I wasn't changing.

284
00:16:33,632 --> 00:16:35,776
我创建了一个复本
I was making another copy,

285
00:16:36,816 --> 00:16:42,048
因为代换模型就是你复制过程的体
because the substitution model says, you copy the body of the procedure

286
00:16:43,088 --> 00:16:45,888
并用实际参数代换形式参数
with the arguments substituted for the formal parameters.

287
00:16:46,720 --> 00:16:48,420
这里 我考虑的不是副本
Here I'm not worried about copying,

288
00:16:48,420 --> 00:16:50,528
在这里 我已经改变了M的值
here I've changed the value of m.

289
00:16:51,808 --> 00:16:55,120
我也把I的值变成了I+1
I also then change the value of i to i plus one,

290
00:16:55,616 --> 00:16:56,960
然后继续循环
and go buzzing around.

291
00:16:58,224 --> 00:17:00,080
看起来是一样的程序
Seems like essentially the same program,

292
00:17:00,960 --> 00:17:02,840
在今天引入赋值之后
but there are some ways of making errors here

293
00:17:02,840 --> 00:17:05,504
我们在这里有很多种方式犯错
that didn't exist until today.

294
00:17:06,144 --> 00:17:07,024
例如
For example,

295
00:17:07,456 --> 00:17:09,408
如果我在赋值的时候
if I were to do the horrible thing

296
00:17:10,048 --> 00:17:12,144
没有小心地写程序
of not being careful in writing my program

297
00:17:12,640 --> 00:17:16,080
把两个赋值的顺序调换了
and interchange those two assignments,

298
00:17:17,104 --> 00:17:18,912
程序计算的就不是相同的函数了
the program wouldn't compute the same function.

299
00:17:20,336 --> 00:17:22,870
我得到了一个时间错误 因为这儿有个依赖关系
I get a timing error because there's a dependency

300
00:17:22,870 --> 00:17:27,220
因为M依赖于I上一次的值
that m depends upon having the last value of i.

301
00:17:27,344 --> 00:17:28,928
如果我先改变I的值
If I try change i first,

302
00:17:31,312 --> 00:17:33,776
就会在乘以M的时候 得到错误的I值
then I've got the wrong value of i when I multiply by m.

303
00:17:35,968 --> 00:17:38,380
没有赋值的话不会存在这样的BUG
It's a bug that wasn't available until this moment,

304
00:17:38,380 --> 00:17:40,592
这是由于我们引入了某些包含时间的东西造成的
until we introduced something that had time in it.

305
00:17:43,440 --> 00:17:44,304
如我所说的
So, as I said,

306
00:17:45,536 --> 00:17:47,390
首先 我们需要一个新的计算模型
first we need a new model of computation,

307
00:17:47,390 --> 00:17:50,864
然后 需要有一个非常好的理由来支持我们做如此丑陋的事
and second, we have to be damn good reason for doing this kind of ugly thing.

308
00:17:52,720 --> 00:17:53,744
有什么问题吗？
Are there any questions?

309
00:17:58,832 --> 00:18:00,224
David 大点儿声说
Speak loudly, David

310
00:18:00,400 --> 00:18:03,472
学生：现在 我们引入了SET!
AUDIENCE: I'm confused about, we've introduced set now,

311
00:18:03,904 --> 00:18:06,368
但是之前我们已经有LET和DEFINE了
but we had let before and define before.

312
00:18:06,896 --> 00:18:09,700
我不太清楚它们的区别
I'm confused about the difference between the three.

313
00:18:09,700 --> 00:18:13,250
DEFINE不能像SET!一样用吗？
Wouldn't define work in the same situation as set!

314
00:18:13,984 --> 00:18:14,830
请详细讲讲
if you introduced it a bit?

315
00:18:14,830 --> 00:18:19,310
教授：不 DEFINE用于创建并初始化
PROFESSOR: No, define is intended for setting something once the first time,

316
00:18:19,310 --> 00:18:21,360
为了创建它
for making it, OK?

317
00:18:22,080 --> 00:18:24,704
你永远也不会见到我在黑板上
You've never seen me write on a blackboard

318
00:18:25,600 --> 00:18:26,944
在同一行写两个DEFINE
two defines in a row

319
00:18:27,088 --> 00:18:32,080
只是为了让某个变量的旧值变成一个新的值
whose intention was to change the old value of some variable to a new one.

320
00:18:32,080 --> 00:18:34,510
学生：这是一个约定俗成的规矩 还是--
AUDIENCE: Is that by convention or--

321
00:18:34,510 --> 00:18:36,350
教授：不 这是有意为之的
PROFESSOR: No, it's intention.

322
00:18:36,350 --> 00:18:38,928
答案是
Okay? The answer is,

323
00:18:39,696 --> 00:18:40,840
举个例子
that, for example,

324
00:18:40,840 --> 00:18:42,272
在一个过程内部
internal to a procedure,

325
00:18:43,200 --> 00:18:45,920
两个DEFINE写在一行里是非法的
two defines in a row are illegal,

326
00:18:46,688 --> 00:18:48,576
对于同一个变量DEFINE两次是非法的
two defines in a row of the same variable.

327
00:18:50,240 --> 00:18:51,740
X不能被DEFINE两次
x can't be defined twice.

328
00:18:51,740 --> 00:18:55,200
而系统会不会捕获这个错误 就是另一个问题了
Whether or not a system catches that error is a different question,

329
00:18:55,936 --> 00:18:57,888
但是我定下规矩
but I legislate to you

330
00:18:58,120 --> 00:19:00,640
任何东西都只能DEFINE一次
that define happens once on anything.

331
00:19:00,736 --> 00:19:02,640
确实 在交互式调试中
Now, indeed, in interactive debugging,

332
00:19:03,376 --> 00:19:07,488
我们打算让你与计算机交互时可以重新DEFINE一些东西
we intend that you interacting with your computer will redefine things,

333
00:19:08,192 --> 00:19:11,216
所以交互式调试时产生的是一个特殊的异常
and so there's a special exception made for interactive debugging.

334
00:19:11,824 --> 00:19:16,480
但是DEFINE的意思是建立某些东西
But define is intended to mean to set up something

335
00:19:18,144 --> 00:19:20,960
在那个时间点后 它的值是永远不变的
which will be forever that value after that point.

336
00:19:22,050 --> 00:19:24,544
好像所有的DEFINE都是在最开始完成的
It's as if all the defines were done at the beginning.

337
00:19:26,090 --> 00:19:30,928
事实上 在Scheme过程中 DEFINE的唯一合法使用地方
In fact, the only legal place to put a define in Scheme internal to a procedure

338
00:19:31,024 --> 00:19:33,360
就是在LAMBDA表达式的开始
is just at the beginning of a lambda expression,

339
00:19:34,470 --> 00:19:37,664
也就是过程体的开始
which is the beginning of the body of a procedure.

340
00:19:40,400 --> 00:19:45,808
LET当然与那个不一样
Now, let of course does nothing like either of that.

341
00:19:48,096 --> 00:19:49,552
如果你想知道LET发生了什么
I mean, if you look at what's happening with a let,

342
00:19:50,176 --> 00:19:52,130
LET只会绑定一次
this happens again exactly once.

343
00:19:52,130 --> 00:19:55,824
它建立了一个I和M的值分别为1的上下文
It sets up a context where i and m are values one and one.

344
00:19:56,832 --> 00:20:00,576
这个上下文存在于整个作用域中
That context exists throughout this scope,

345
00:20:01,310 --> 00:20:02,800
也就是这个程序范围
this region of the program.

346
00:20:04,992 --> 00:20:10,128
然而 你不会认为LET再次设置了I的值
However, you don't think of that let as setting i again.

347
00:20:11,040 --> 00:20:12,160
它没有改变I的值
It doesn't change it.

348
00:20:12,160 --> 00:20:14,016
因为LET的作用 I将永远不会变化
i never changes because of the let.

349
00:20:15,280 --> 00:20:16,816
因为LET的作用 I才被创建
i gets created because of let.

350
00:20:18,512 --> 00:20:19,296
实际上
In fact,

351
00:20:19,730 --> 00:20:21,424
LET是一个非常简单的想法
the let is a very simple idea.

352
00:20:22,240 --> 00:20:23,590
LET不会做别的事情
Let does nothing more,

353
00:20:23,590 --> 00:20:31,620
LET的语义是……
Let a variable one to have value one

354
00:20:31,620 --> 00:20:33,504
我把它写得更准确点
I'll write this down a little bit more neatly;

355
00:20:37,160 --> 00:20:43,730
表达式 (var1 e1)
Let's write, var one have value, the value of expression e1,

356
00:20:43,730 --> 00:20:47,360
还有(var2 e2)
and variable two, have this value of the expression e2,

357
00:20:48,144 --> 00:20:49,744
在表达式e3中
in an expression e3,

358
00:20:51,600 --> 00:21:05,808
与一个以var1和var2为形式参数的过程一样
is the same thing as a procedure of var one and var two, the formal parameters,

359
00:21:06,944 --> 00:21:08,960
e3成为过程的体
and e3 being the body,

360
00:21:10,912 --> 00:21:14,000
在这里 var1与e1的值绑定
where var one is bound to the value of e1,

361
00:21:14,270 --> 00:21:16,912
var2与e2的值绑定
and var two gets the value of e2.

362
00:21:19,536 --> 00:21:23,264
所以实际上 这是一个从代换的角度来看很容易理解的东西
So this is, in fact, a perfectly understandable thing from a substitution point of view.

363
00:21:24,896 --> 00:21:27,952
其实就是同一个表达式的两种不同的写法
This is really the same expression written in two different ways.

364
00:21:31,690 --> 00:21:33,504
事实上 系统真正的工作方式
In fact, the way the actual system works

365
00:21:33,632 --> 00:21:35,820
就是在运行之前把代码翻译成这种形式
is this gets translated into this before anything happens.

366
00:21:37,648 --> 00:21:41,770
学生：我还是不清楚是什么造成了LET和DEFINE之间的区别
AUDIENCE: OK, I'm still unclear as then what makes the difference between a let and a define. They could--

367
00:21:41,770 --> 00:21:44,304
教授：DEFINE就是个语法糖
PROFESSOR: A define is a syntactic sugar,

368
00:21:44,624 --> 00:21:49,104
本质上来说 是通过LET创建一系列变量 然后给它们一次性赋值
whereby, essentially a bunch of variables get created by lets and then set up once.

369
00:21:57,104 --> 00:21:59,744
好吧 我们休息一会
OK, time for the first break, I think. Thank you.

370
00:22:02,520 --> 00:22:12,848
[音乐]
[JESU, JOY OF MAN'S DESIRING]

371
00:22:12,840 --> 00:22:17,840
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

372
00:22:48,810 --> 00:22:52,672
讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
By: Prof. Harold Abelson && Gerald Jay Sussman

373
00:22:52,670 --> 00:22:56,528
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

374
00:22:56,520 --> 00:23:00,592
赋值、状态和副作用
Assignment, State, and Side-effects

375
00:23:04,288 --> 00:23:06,112
看
Well let's see.

376
00:23:06,448 --> 00:23:09,088
现在 我不得不重建计算模型
I now have to rebuild the model of computation,

377
00:23:09,776 --> 00:23:14,160
使得你能够明白那些机制是如何运作的
so you understand how some such mechanical mechanism could work

378
00:23:14,912 --> 00:23:16,464
来完成我们刚才说的那些工作
that can do what we've just talked about.

379
00:23:17,536 --> 00:23:21,392
我刚刚摧毁了你们的代换模型
I just recently destroyed your substitution model.

380
00:23:22,624 --> 00:23:26,032
不幸的是 这个模型比代换模型要复杂得多
Unfortunately, this model is significantly more complicated than the substitution model.

381
00:23:26,624 --> 00:23:27,936
这个模型叫环境模型
It's called the environment model.

382
00:23:29,024 --> 00:23:31,200
我即将介绍一些术语
And I'm going to have to introduce some terminology,

383
00:23:32,032 --> 00:23:34,510
无论如何 你知道这些术语都是很好的
which is very good terminology for you to know anyway.

384
00:23:34,510 --> 00:23:35,744
它是关于名字的
It's about names.

385
00:23:36,510 --> 00:23:39,632
我们要给事物的各种名字
And we're going to give names to the kinds of names things have

386
00:23:40,000 --> 00:23:41,310
和名字的使用途径以名字
and the way those names are used.

387
00:23:42,480 --> 00:23:47,940
如果硬要说的话 这是一个元描述
So this is a meta-description, if you will.

388
00:23:48,560 --> 00:23:50,850
总之 这里面有一堆糟糕的术语
Anyway, there is a pile of an unfortunate terminology here,

389
00:23:50,850 --> 00:23:53,760
但我们需要利用它们来理解所谓的“环境模型”
but we're going to need this to understand what's called the environment model.

390
00:23:54,704 --> 00:23:57,536
我们可能要做一点无聊的事情了
We're about to do a little bit of boring, dog-work here.

391
00:23:58,040 --> 00:24:01,584
我们来看第一张幻灯片
Let's look at the first transparency.

392
00:24:02,256 --> 00:24:06,976
我们看到了术语“约束”的解释
And we see a description of a word called bound.

393
00:24:08,800 --> 00:24:11,000
我们会说一个变量V
And we're going to say that a variable, v,

394
00:24:11,000 --> 00:24:12,912
被约束在表达式E中
is bound in an expression, e,

395
00:24:13,410 --> 00:24:21,520
如果用一个没有出现在E中的变量W 对变量V统一换名
if the meaning of e is unchanged by the uniform replacement of a variable w,

396
00:24:21,560 --> 00:24:24,288
表达式语义没有发生改变
not occurrent if for every occurrence of v in e.

397
00:24:25,696 --> 00:24:27,008
这个解释很长
Now that's a long sentence,

398
00:24:27,370 --> 00:24:29,968
在我们在被搞糊涂之前
so, I think, I'm going to have to say a little bit about that

399
00:24:29,984 --> 00:24:32,620
我应该再多解释下
before we even fool around at all here.

400
00:24:33,424 --> 00:24:35,280
我们这里讨论的约束变量
Bound variables we're talking about here.

401
00:24:44,160 --> 00:24:45,568
你们已经看到它们很多次了
And you've seen lots of them.

402
00:24:46,070 --> 00:24:48,176
只是你们可能还没意识到
You may not know that you've seen lots of them.

403
00:24:48,240 --> 00:24:52,240
在逻辑学中 你们看到一个逻辑变量
Well, I suppose in your logic, you saw a logical variables like,

404
00:24:53,270 --> 00:25:00,112
就像微积分课上的 对于任意任何X 存在一个Y 使得P为真
for every x there exists a y such that p is true of x and y from your calculus class.

405
00:25:02,880 --> 00:25:05,824
这个变量X 这个变量Y 它们是约束变量
This variable, x, and this variable, y, are bound,

406
00:25:07,088 --> 00:25:07,920
因为
because,

407
00:25:08,336 --> 00:25:09,980
这个表达式的含义
the meaning of this expression

408
00:25:09,980 --> 00:25:15,616
不取决于我用来描述X和Y的具体字母
does not depend upon the particular letters I used to describe x and y.

409
00:25:16,496 --> 00:25:19,184
如果我用W替换X
If I were to change the w for x,

410
00:25:19,840 --> 00:25:25,680
则可以说对于任意W 存在一个Y使得P为真
then said for every w there exists a y such that p is true of w and y,

411
00:25:25,984 --> 00:25:27,088
它们其实是同一句话
it would be the same sentence.

412
00:25:29,440 --> 00:25:30,340
就是这个意思
That's what it means.

413
00:25:30,340 --> 00:25:34,896
又或者说 你们看到这样一个积分
Or another case of this that you've seen is integral say,

414
00:25:35,408 --> 00:25:42,656
对dx/(1+x^2)从0到1积分
from 0 to one of dx over one plus x square.

415
00:25:46,032 --> 00:25:47,920
这就是你们经常见到的那种东西
Well that's something you see all the time.

416
00:25:47,920 --> 00:25:50,928
这个x是一个约束变量
And this x is a bound variable.

417
00:25:52,064 --> 00:25:53,792
如果我把它换成t
If I change that to a t,

418
00:25:54,150 --> 00:25:56,256
这个表达式其实没有变化
the expression is still the same thing.

419
00:25:58,060 --> 00:26:02,768
就是arctan(1)/4之类的
This is a 1/4 of the arctan of one or something here, something like that.

420
00:26:04,704 --> 00:26:06,016
是的 就是arctan(1)
Yes, that's the arctan of one.

421
00:26:06,624 --> 00:26:08,768
所以约束变量事实上很常见
So bound variables are actually fairly common,

422
00:26:09,080 --> 00:26:12,368
如果你们接触过一些数学的话
for those of you who have played a bit with mathematics.

423
00:26:13,264 --> 00:26:17,472
好 让我们来到编程的世界
Well, let's go into the programming world.

424
00:26:19,024 --> 00:26:21,360
现在量词不再是
Instead of the quantifier being something like,

425
00:26:22,032 --> 00:26:24,060
所有、存在和积分
for every, or there exists, or integral,

426
00:26:24,060 --> 00:26:26,432
我们有一个符号作为量词 用于约束变量
a quantifier is a symbol that binds a variable.

427
00:26:27,472 --> 00:26:28,992
我们要使用量词LAMBDA
And we are going to use the quantifier lambda

428
00:26:29,792 --> 00:26:31,808
作为约束变量的一个必要的东西
as being the essential thing that binds variables.

429
00:26:33,808 --> 00:26:36,128
我们有一个极好的例子
And so we have some nice examples here

430
00:26:36,592 --> 00:26:44,140
对于以Y为参数的过程 做了以下的事情
like that procedure of one argument y which does the following thing.

431
00:26:44,140 --> 00:26:46,960
它调用一个含单个参数X的过程
It calls the procedure of one argument x,

432
00:26:47,872 --> 00:26:51,136
该过程 将X乘以Y
which multiplies x by y,

433
00:26:52,880 --> 00:26:54,528
并应用于3
and applies that to three.

434
00:26:58,768 --> 00:27:01,664
这个过程中包含两个约束变量
That procedure has the property there of two bound variables in it,

435
00:27:02,016 --> 00:27:02,928
X和Y
x and y

436
00:27:04,832 --> 00:27:07,472
这个LAMBDA量词 约束了这个Y
This quantifier, lambda here, binds this y,

437
00:27:07,910 --> 00:27:10,784
这个LAMBDA量词 约束了这个X
and this quantifier, lambda, binds that x.

438
00:27:12,112 --> 00:27:17,056
因为 如果我用了一个没有出现在表达式中的任意符号 如W
Because, if I were to take an arbitrary symbol does not occur in this expression like w

439
00:27:17,984 --> 00:27:21,040
用W替换表达式中的所有Y
and replace all y's with w's in this expression,

440
00:27:21,360 --> 00:27:22,752
这个表达式仍与原来的相同
the expression is still the same,

441
00:27:23,664 --> 00:27:24,800
是相同的过程
the same procedure.

442
00:27:26,224 --> 00:27:27,410
这是一个重要的想法
And this is an important idea.

443
00:27:27,410 --> 00:27:29,648
我们有这种东西的原因
The reason why we had such things like that

444
00:27:30,208 --> 00:27:31,410
这是一种模块性
is a kind of modularity.

445
00:27:31,410 --> 00:27:32,864
如果有两个人写程序
If two people are writing programs,

446
00:27:34,032 --> 00:27:35,260
并且他们在合作编程
and they work together,

447
00:27:35,260 --> 00:27:40,560
在他们自己构建的小项目里用什么命名都没有关系
it shouldn't matter what names they use internal to their own little machines that they're building.

448
00:27:42,832 --> 00:27:44,672
所以 实际上我想告诉你们
And so, what I'm really telling you there,

449
00:27:45,440 --> 00:27:46,752
例如
is that, for example,

450
00:27:46,840 --> 00:27:51,264
这个表达式等于 以Y为参数的过程
this is equivalent to that procedure of one argument y which

451
00:27:52,352 --> 00:27:59,232
使用这个对于一个参数Z的过程 这个过程将Z乘以Y
uses that procedure of one argument z which multiplies z by y.

452
00:28:01,648 --> 00:28:03,536
因为没人关心我在这用什么
Because nobody cares what I used in here.

453
00:28:06,368 --> 00:28:07,248
这是一个极好的例子
It's a nice example.

454
00:28:08,848 --> 00:28:09,856
另一方面
On the other hand,

455
00:28:11,072 --> 00:28:14,336
我有一些未被约束的变量
I have some variables that are not bound.

456
00:28:15,232 --> 00:28:15,968
举个例子
And example,

457
00:28:20,272 --> 00:28:21,760
这个对于一个以X为参数的过程
that procedure of one argument x

458
00:28:22,096 --> 00:28:25,040
将X乘以Y
which multiplies x by y

459
00:28:27,280 --> 00:28:28,160
在这个例子中
In this case,

460
00:28:29,456 --> 00:28:30,752
y没有被约束
y is not bound.

461
00:28:32,464 --> 00:28:34,272
假设Y的值是3
Supposing y had the value three,

462
00:28:35,264 --> 00:28:36,800
Z的值是4
and z had the value four,

463
00:28:38,832 --> 00:28:44,272
那么这个过程就是把它的参数乘以3
then this procedure would be the thing that multiplies its argument by three.

464
00:28:44,864 --> 00:28:47,392
如果我把所有的y都用z来代替
If I were to replace every instance of y with z,

465
00:28:47,520 --> 00:28:51,968
我将得到一个完全不同的过程 它会把参数乘以4
I would have a different procedure which multiplies every argument that's given by four.

466
00:28:53,872 --> 00:28:56,400
事实上 我们给这类变量取了个名字
And, in fact, we have a name for such a variable.

467
00:28:57,760 --> 00:29:04,010
我们把表达式E中的变量V叫做自由变量
Here, we say that a variable, v, is free in the expression, e,

468
00:29:04,010 --> 00:29:09,424
如果用没有出现在E中的变量W统一替换E中所有的V
if the meaning of the expression, e, is changed by the uniform replacement of a variable, w, not occurring in e,

469
00:29:09,584 --> 00:29:11,152
使得表达式E的含义发生了改变
for every occurrence of v and e.

470
00:29:13,264 --> 00:29:13,712
所以
So,

471
00:29:14,496 --> 00:29:22,768
所以这就是为什么这个变量Y 是一个自由变量
So that's why this variable over here, y, is a free variable.

472
00:29:29,160 --> 00:29:32,272
所以 这个表达式里的自由变量
And so free variables in this expression--

473
00:29:33,760 --> 00:29:35,184
另一个例子是
And other examples of that is that

474
00:29:36,176 --> 00:29:39,328
对于一个以Y为参数的过程
is that procedure of one argument y,

475
00:29:40,432 --> 00:29:42,000
就像我们之前的那个一样
which is just what we had before,

476
00:29:42,272 --> 00:29:44,608
调用以X为参数的过程
which uses that procedure of one argument x

477
00:29:45,088 --> 00:29:48,544
将X与Y相乘--
that multiplies x by y--

478
00:29:51,408 --> 00:29:52,656
并应用于3
use that on three.

479
00:29:57,248 --> 00:30:00,352
这个过程中有一个自由变量
This procedure has a free variable in it

480
00:30:00,928 --> 00:30:01,984
也就是这个星号
which is asterisk.

481
00:30:05,008 --> 00:30:05,890
因为
See, because,

482
00:30:05,890 --> 00:30:08,080
如果它表示正常意义的乘法
if that has a normal meaning of multiplication,

483
00:30:09,440 --> 00:30:12,784
如果我统一地用加号来代替星号
then if I were to replace uniformly all asterisks with pluses,

484
00:30:14,256 --> 00:30:16,384
这个表达式的含义就变了
then the meaning of this expression would change.

485
00:30:19,344 --> 00:30:20,768
这就是自由变量的意思
That's what you mean by a free variable.

486
00:30:22,688 --> 00:30:24,816
现在 你们已经学到了一些逻辑学术语
So, so far you've learned some logician words

487
00:30:25,648 --> 00:30:27,584
用它们可以解释名字的用法
which describe the way names are used.

488
00:30:28,944 --> 00:30:31,264
我们需要更进一步深入
Now, we have to do a little bit more playing around here,

489
00:30:32,960 --> 00:30:33,728
再多了解一些
a little bit more.

490
00:30:35,136 --> 00:30:36,224
我想给你们讲讲
I want to tell you about

491
00:30:36,816 --> 00:30:39,760
变量被定义的区域
about the regions are over which variables are defined.

492
00:30:42,176 --> 00:30:42,880
你瞧
You see,

493
00:30:43,376 --> 00:30:45,696
目前为止 我们已经相当不正式了
we've been very informal about this up till now,

494
00:30:46,336 --> 00:30:50,160
当然 你们中的一些 或者大部分人可能已经理解得很透彻了
and, of course, many of you have probably understood very clearly or most of you,

495
00:30:50,360 --> 00:30:52,848
在这里被声明的X
that the x that's being declared here

496
00:30:53,648 --> 00:30:55,184
只被定义在这里
is defined only in here.

497
00:30:58,288 --> 00:31:00,912
这个X 只被定义在这里
This x is the defined only in here,

498
00:31:01,616 --> 00:31:04,336
这个Y 只被定义在这里
and this y is defined only in here.

499
00:31:07,104 --> 00:31:09,168
我们给这个概念取了个名字 叫“作用域”
We have a name for such an idea. It's called a scope.

500
00:31:11,616 --> 00:31:13,584
我给你们再讲个术语
And let me give you another piece of terminology.

501
00:31:14,704 --> 00:31:15,776
这个就比较复杂
It's a long story.

502
00:31:15,968 --> 00:31:17,648
如果X是E中的一个约束变量
If x is a bound variable in e,

503
00:31:18,160 --> 00:31:20,240
那么它是约束于一个LAMBDA表达式中
then there is a lambda expression where it is bound.

504
00:31:20,896 --> 00:31:24,910
LAMBDA表达式是约束变量的唯一方式
So the only way you can get a bound variable ultimately is by lambda expression.

505
00:31:24,910 --> 00:31:25,968
你可能会担心
Then you may worry,

506
00:31:26,220 --> 00:31:29,056
DEFINE是它的一个例外吗？
does define quite an exception to this?

507
00:31:29,648 --> 00:31:32,920
事实证明 通过巧妙安排 我们可以避免使用DEFINE
And it turns out, we could always arrange things so you don't need any defines.

508
00:31:32,920 --> 00:31:33,968
一会我们就能看到了
And we'll see that in a while.

509
00:31:34,240 --> 00:31:35,728
它一个非常神奇的东西
It's a very magical thing.

510
00:31:36,540 --> 00:31:38,400
所以我们完全不需要DEFINE
So define really can go away.

511
00:31:38,680 --> 00:31:41,552
实际上 唯一能创建名字的东西是LAMBDA
The really, only thing that makes names is lambda .

512
00:31:42,640 --> 00:31:43,408
这就是它的职责
That's its job.

513
00:31:44,304 --> 00:31:46,230
多么的令人惊奇
And what's so amazing about a lot of things

514
00:31:46,230 --> 00:31:47,872
很多东西你只凭借LAMBDA就可以计算
is you can compute with only lambda.

515
00:31:48,736 --> 00:31:49,584
但是 在任何情况下
But, in any case,

516
00:31:51,744 --> 00:31:55,760
一个LAMBDA表达式有一个地方来声明变量
a lambda expression has a place where it declares a variable.

517
00:31:55,760 --> 00:31:57,104
我们把它称为形式参数表
We call it the formal parameter list

518
00:31:58,944 --> 00:32:00,560
或者叫 约束变量表
and we say or the bound variable list.

519
00:32:01,264 --> 00:32:04,512
我们说LAMBDA表达式约束了--这是一个动词
We say that the lambda expression binds -- so it's a verb

520
00:32:05,020 --> 00:32:07,344
--约束了在约束变量表里声明的变量
--binds the variables declared in it's bound variable list.

521
00:32:08,592 --> 00:32:12,480
另外 表达式中定义变量的那些部分
In addition, those parts of the expression where the variable is defined,

522
00:32:13,232 --> 00:32:15,232
是被一些声明所声明的
which was declared by some declaration

523
00:32:15,568 --> 00:32:19,264
这些部分被叫做变量的作用域
is called the scope of that variable.

524
00:32:20,448 --> 00:32:21,920
所以 这些是作用域
So these are scopes.

525
00:32:22,256 --> 00:32:23,680
这是Y的作用域
This is the scope of y.

526
00:32:27,160 --> 00:32:28,544
这是X的作用域--
And this is the scope of x--

527
00:32:33,104 --> 00:32:34,032
以此类推
that sort of thing.

528
00:32:41,328 --> 00:32:42,080
好
OK,

529
00:32:43,936 --> 00:32:45,632
现在我们有了足够多的术语
well, now we have enough terminology

530
00:32:46,608 --> 00:32:51,760
可以开始理解如何建立一个新的计算模型了
to begin to understand how to make a new model for computation

531
00:32:51,968 --> 00:32:53,776
因为 这里很重要的一点是
because the key thing going on here

532
00:32:54,944 --> 00:32:57,008
我们摧毁了代换模型
is that we destroyed the substitution model,

533
00:32:57,180 --> 00:32:58,384
我们现在不得不需要一个模型
and we now have to have a model

534
00:32:58,624 --> 00:33:02,320
来体现表示名字被关联到某些地方
that represents the names as referring to places.

535
00:33:03,936 --> 00:33:05,344
因为 如果我们要改变某个东西
Because if we are going to change something,

536
00:33:05,984 --> 00:33:07,472
我们就需要一个存它的地方
then we have a place where it's stored.

537
00:33:09,568 --> 00:33:10,352
请想一想
You see,

538
00:33:10,832 --> 00:33:13,312
如果一个名字只是关联于一个值
if a name only refers to a value,

539
00:33:14,040 --> 00:33:16,360
如果我试图改变这个名字的含义
and if I tried to change the name's meaning,

540
00:33:16,736 --> 00:33:20,320
这不怎么明确
well, that's not clear.

541
00:33:20,320 --> 00:33:24,680
因为没有名字可以关联的地方
There's nothing that is the place that that name referred to.

542
00:33:24,992 --> 00:33:25,808
该怎么解释呢……
How am I really saying it?

543
00:33:25,920 --> 00:33:29,540
也就是名字的所有实例之间没有共享任何东西
There're nothing shared among all of the instances of that name.

544
00:33:29,872 --> 00:33:31,680
也就是说 对于一个名字
And what we really mean, by a name,

545
00:33:31,680 --> 00:33:32,976
是用来让我们找到某些东西的
is that we find something out.

546
00:33:34,336 --> 00:33:36,368
我们给某个东西一个名字 然后你得到了它
We've given something a name, and you have it,

547
00:33:36,736 --> 00:33:39,060
你能得到它 是因为我给了你一个它的引用
and you have it, because I'm given you a reference to it,

548
00:33:39,060 --> 00:33:40,448
我把对它的引用给了你
and I've given you a reference to it.

549
00:33:41,024 --> 00:33:42,304
我们会看到很多相关的例子
And we'll see a lot about that.

550
00:33:43,616 --> 00:33:45,216
让我们继续学习“环境”
So let me tell you about environments.

551
00:33:46,192 --> 00:33:48,768
我需要用一下头顶上的投影仪
I need the overhead projection machine,

552
00:33:49,312 --> 00:33:49,984
谢谢你
thank you.

553
00:33:52,192 --> 00:33:53,024
这里
And so here

554
00:33:55,488 --> 00:34:00,400
是一堆环境结构
is a bunch of environment structures.

555
00:34:01,536 --> 00:34:05,760
环境就是执行虚拟的代换的一种方法
An environment is a way of doing substitutions virtually.

556
00:34:06,384 --> 00:34:07,890
它代表了一个地方
It represents a place

557
00:34:07,890 --> 00:34:11,392
是存储你的未完成的代换的地方
where something is stored which is the substitutions that you haven't done.

558
00:34:13,344 --> 00:34:16,500
它是一个积累各种东西的地方
It's a place where everything accumulates,

559
00:34:16,500 --> 00:34:21,136
在那里 变量的名字与值关联在一起
where the names of the variables are associated with the values they have

560
00:34:21,792 --> 00:34:22,560
使得
such that,

561
00:34:22,752 --> 00:34:25,900
当你问某个名字是什么意思的时候
when you say, what dose this name mean,

562
00:34:25,900 --> 00:34:27,408
你要在一个环境中寻找答案
you look it up in an environment.

563
00:34:28,080 --> 00:34:29,488
所以环境是一个函数
So an environment is a function,

564
00:34:30,800 --> 00:34:31,488
或一张表
or a table,

565
00:34:32,224 --> 00:34:33,240
或类似的东西
or something like that.

566
00:34:33,240 --> 00:34:34,896
但它是一种结构化的表
But it's a structured sort of table.

567
00:34:35,760 --> 00:34:37,392
它是由框架构成
It's made out of things called frames.

568
00:34:41,136 --> 00:34:44,464
框架是环境的一部分
Frames are pieces of environment,

569
00:34:44,896 --> 00:34:46,016
它们被链接在一起
and they are chained together,

570
00:34:47,072 --> 00:34:48,192
以某种很好的方式
in some nice ways,

571
00:34:49,008 --> 00:34:52,096
用一种叫做父链接之类的东西
by what's called parent links or something like that.

572
00:34:54,032 --> 00:34:55,024
这里
So here,

573
00:34:55,648 --> 00:34:57,620
有一个环境结构
we have an environment structure

574
00:34:57,620 --> 00:35:04,224
它由三个环境组成 分别是A B和C
consisting of three environments, basically, A, B, and C.

575
00:35:05,104 --> 00:35:07,632
D也是环境 但它和C是一样的
d is also an environment, but it's the same one,

576
00:35:08,880 --> 00:35:10,176
它们共享了同一个环境
they share.

577
00:35:11,456 --> 00:35:13,968
那就是赋值的本质所在
And that's the essence of assignment.

578
00:35:14,400 --> 00:35:16,100
如果我改变了一个变量
If I change a variable,

579
00:35:16,100 --> 00:35:19,800
比如改变这个变量的值
a value of a valuable that lives here, like that one,

580
00:35:19,800 --> 00:35:23,500
那么它将在所有地方都可见
it should be visible from all places that you're looking at it from.

581
00:35:23,500 --> 00:35:24,840
用x来举例
Take this one, x.

582
00:35:24,840 --> 00:35:28,190
如果我将X改为4
If I change the x to four,

583
00:35:28,190 --> 00:35:30,190
在其他地方也是可见的
it's visible from other places.

584
00:35:30,190 --> 00:35:32,190
但是我们现在不去关心这个
But I'm not going to worry about that right now.

585
00:35:32,190 --> 00:35:33,840
过一会儿会详细讨论这个问题
We're going to talk a lot about that in a little while.

586
00:35:34,560 --> 00:35:35,536
这里有什么？
What do we have here?

587
00:35:36,768 --> 00:35:38,848
这些叫做框架 这是一个框架
Well, these are called frames. Here is a frame,

588
00:35:39,408 --> 00:35:40,384
这是一个框架
here's a frame

589
00:35:40,768 --> 00:35:41,840
这也是一个框架
and here's a frame.

590
00:35:43,184 --> 00:35:45,200
A是一个环境
A is an environment which consists of

591
00:35:45,200 --> 00:35:47,824
它由框架II
the table label which is frame two,

592
00:35:48,368 --> 00:35:51,056
和框架I组成
followed by the table labeled frame one.

593
00:35:52,528 --> 00:35:54,608
在这个环境中
And, in this environment,

594
00:35:54,992 --> 00:35:59,680
在环境C中 在框架II中
in C, this environment, frame two,

595
00:36:00,480 --> 00:36:03,264
X和Y是被约束的
uh....x and y are bound.

596
00:36:04,064 --> 00:36:04,784
它们具有值
They have values.

597
00:36:05,260 --> 00:36:07,180
对不起 是在框架I中
Sorry, in frame one

598
00:36:07,180 --> 00:36:08,288
而在框架II中
In frame two,

599
00:36:09,728 --> 00:36:10,832
Z被约束
z is bound,

600
00:36:10,992 --> 00:36:12,176
X被约束
and x is bound,

601
00:36:12,448 --> 00:36:13,696
并且Y也是被约束的
and y is bound,

602
00:36:15,248 --> 00:36:17,408
但是我们看到的X的值
but the value of x that we see,

603
00:36:17,420 --> 00:36:19,040
从这个角度来看
looking from this point of view,

604
00:36:20,016 --> 00:36:21,744
是这个X 它的值是7
is this x. It's x is seven,

605
00:36:22,368 --> 00:36:24,840
而不是这个值为3的X
rather than this one which is three.

606
00:36:24,840 --> 00:36:27,616
我们称之为 这个X遮蔽了这个X
We say that this x shadows this x.

607
00:36:31,056 --> 00:36:32,496
从环境III
From environment three--

608
00:36:33,440 --> 00:36:34,450
从框架III
from frame three,

609
00:36:34,450 --> 00:36:35,730
从环境B
from environment b,

610
00:36:35,730 --> 00:36:37,184
它引用了框架III
which refers to frame three,

611
00:36:37,450 --> 00:36:42,128
变量M和Y被约束 X也被约束
we have variables m and y bound and also x.

612
00:36:44,848 --> 00:36:46,976
这个Y遮蔽了这个Y
This y shadow this one.

613
00:36:48,656 --> 00:36:51,000
从这个角度来看
So the value, looking from this point of view,

614
00:36:51,104 --> 00:36:52,650
Y的值是2
of y is two.

615
00:36:53,456 --> 00:36:55,280
从这个角度来看
The value for looking from this point of view

616
00:36:55,280 --> 00:36:58,640
M的值是1 X的值是3
and m is one. And the value, looking from this point of view, of x is three.

617
00:37:02,224 --> 00:37:03,150
所以 我们有了一个
So there we have

618
00:37:03,150 --> 00:37:05,520
由框架构成的非常简单的环境结构
a very simple environment structure made out of frames.

619
00:37:06,384 --> 00:37:09,808
它们与过程的应用相一致
These correspond to the applications of procedures.

620
00:37:10,944 --> 00:37:12,176
我们马上就会看到
And we'll see that in a second.

621
00:37:14,416 --> 00:37:17,600
现在要给你们看看我们构建的一些其他的很好的小结构
So now I have to make you some other nice little structure that we build.

622
00:37:20,752 --> 00:37:21,712
下一张幻灯片
Next slide,

623
00:37:22,144 --> 00:37:24,368
我们可以看到一个对象
we see an object,

624
00:37:24,840 --> 00:37:26,544
我描绘的是一个过程的图像
which I'm going to draw procedures.

625
00:37:27,936 --> 00:37:28,944
这是一个过程
This is a procedure.

626
00:37:30,112 --> 00:37:31,904
过程由两个部分组成
A procedure is made out of two parts.

627
00:37:33,104 --> 00:37:34,800
这有点像CONS
It's sort of like a cons.

628
00:37:37,216 --> 00:37:38,384
不管怎样 它有两个部分
However, it's the two parts.

629
00:37:40,848 --> 00:37:44,720
第一个部分指向一些代码
The first part refers to some code,

630
00:37:45,696 --> 00:37:46,944
这些代码将会被执行
something that can be executed,

631
00:37:47,420 --> 00:37:50,000
你可以把它视作一组指令
a set of instructions, if you will. You can think of it that way.

632
00:37:50,688 --> 00:37:52,832
第二部分是环境
And the second part is the environment.

633
00:37:53,888 --> 00:37:55,504
这就是过程的全部了
The procedure is the whole thing.

634
00:37:57,168 --> 00:37:58,400
我们要用它
And we're going to have to use this

635
00:37:58,710 --> 00:38:05,168
来捕获出现在过程中的自由变量的值
to capture the values of the free variables that occur in the procedure.

636
00:38:06,176 --> 00:38:08,096
如果变量出现在过程中
If a variable occurs in the procedure

637
00:38:08,112 --> 00:38:09,920
它不是被约束的就是自由的
it's either bound in that procedure or free.

638
00:38:11,104 --> 00:38:11,968
如果它是被约束的
If it's bound,

639
00:38:12,576 --> 00:38:14,560
则它的值将很容易被找到
then the value will somehow be easy to find.

640
00:38:16,112 --> 00:38:18,640
它将存在于某个很容易找到的环境中
It will be in some easy environment to get at.

641
00:38:18,910 --> 00:38:19,872
如果它是自由的
If it's free,

642
00:38:20,864 --> 00:38:23,020
我们就必须在过程中放入一些东西
we're going to have to have something that goes with the procedure

643
00:38:23,020 --> 00:38:24,816
用来指导我们查询自由变量的值
that says where we'll go look for its value.

644
00:38:27,056 --> 00:38:29,210
相关理由目前还不清楚
And the reasons why are not obvious yet,

645
00:38:29,210 --> 00:38:30,608
但很快就要真相大白了
but will be soon.

646
00:38:32,320 --> 00:38:34,976
这里有一个对象 它是个复合对象
So here's a procedure object. It's a composite object

647
00:38:35,344 --> 00:38:41,648
由一些代码和一个环境结构组成
consisting of a piece of code and a environment structure.

648
00:38:42,720 --> 00:38:45,504
现在我要告诉你们一些全新的规则
Now I will tell you the new rules, the complete new rules,

649
00:38:46,416 --> 00:38:47,472
关于执行的规则
for evaluation.

650
00:38:50,544 --> 00:38:52,208
仅有的两条规则的第一条是--
The first rule is-- there's only two of them.

651
00:38:53,200 --> 00:38:55,392
这些规则与代换模型规则相对应
These correspond to the substitution model rules.

652
00:38:57,264 --> 00:38:59,328
第一条规则是用来解决
And the first one has to do with

653
00:38:59,664 --> 00:39:02,784
如何把一个过程 应用到参数上的问题
how do you apply a procedure to its arguments?

654
00:39:05,280 --> 00:39:08,544
程序对象被应用于一组参数
Okay, And a procedural object is applied to a set of arguments

655
00:39:08,960 --> 00:39:10,432
是通过构建一个新的框架来完成
by constructing a new frame.

656
00:39:11,312 --> 00:39:15,760
那个框架将包含形式参数
That frame will contain the mapping of the former parameters to the actual parameters

657
00:39:15,830 --> 00:39:19,488
到调用中使用的实际参数的映射
of the arguments that were supplied in the call.

658
00:39:21,424 --> 00:39:22,208
如你所知
As you know,

659
00:39:22,310 --> 00:39:26,940
当我们调用一个过程 如(LAMBDA (X) (* X Y))
when we make up a call to a procedure like lambda x times x y,

660
00:39:26,940 --> 00:39:29,136
然后我们以3为参数调用它
and we call that with the argument three,

661
00:39:30,192 --> 00:39:32,752
那么我们需要某个从X到3的映射
then we're going to need some mapping of x to three.

662
00:39:34,190 --> 00:39:37,392
你可以把它想做是代换的一种
It's the same thing as later substituting, if you will

663
00:39:38,272 --> 00:39:40,304
在旧的模型中 用3代换X
the three for the x in the old model.

664
00:39:42,000 --> 00:39:44,800
所以我要建立一个框架
So I'm going to build a frame which contains x equals three

665
00:39:45,152 --> 00:39:46,608
在框架中包含X等于3的这个信息
as the information in that frame.

666
00:39:49,120 --> 00:39:49,712
现在
Now,

667
00:39:50,336 --> 00:39:53,312
过程的体即将被执行
the body of the procedure will then have to be evaluated which is this,

668
00:39:54,160 --> 00:39:56,448
它将在一个环境中执行
and will be evaluated in an environment

669
00:39:57,808 --> 00:40:08,032
这个环境是由我们创建的新框架邻接组合而成
which is constructed by adjoining the new frame that we just made

670
00:40:08,544 --> 00:40:11,696
它是我们所应用的过程的一部分
to the environment which was part of the procedure that we applied.

671
00:40:13,152 --> 00:40:15,776
所以 举个例子
So I'm going to make a little example of that here.

672
00:40:19,200 --> 00:40:24,128
假设我有一些环境
Supposing I have some environment.

673
00:40:25,152 --> 00:40:27,232
画个方框代表它
Here's a frame which represents it.

674
00:40:27,968 --> 00:40:32,192
以及一些过程--我画圆来代表它们 因为这比小三角形好画--
And some procedure-- which I'm going to draw with circles here because it's easier than little triangles--

675
00:40:33,040 --> 00:40:36,368
抱歉 是菱形
Ummm.. sorry, those are rhombuses,

676
00:40:37,664 --> 00:40:40,784
小块菱形的果冻之类的东西
rhomboidal little pieces of fruit jelly or something.

677
00:40:42,688 --> 00:40:45,328
这有一个使用这个环境的过程
So here's a procedure which takes this environment.

678
00:40:45,952 --> 00:40:48,160
这个过程有一些代码
And the procedure has a piece of code,

679
00:40:48,160 --> 00:40:49,680
是一个LAMBDA表达式
which is a lambda expression,

680
00:40:50,120 --> 00:40:51,696
约束了X和Y
which binds x and y

681
00:40:53,152 --> 00:40:56,432
然后执行了表达式E
and then executes an expression, e.

682
00:40:57,936 --> 00:40:58,992
这个过程就是这样的
And this is the procedure.

683
00:40:59,560 --> 00:41:00,576
我们叫它P
We'll call it p.

684
00:41:01,440 --> 00:41:05,792
我希望将这个过程应用于3和4
I wish to apply that procedure to three and four.

685
00:41:06,384 --> 00:41:08,368
所以我在这写(P 3 4)
So I want to do p of three and four.

686
00:41:09,760 --> 00:41:12,176
我要做的事情则是 创建一个新的框架
What I'm going to do, of course, is make a new frame.

687
00:41:13,152 --> 00:41:14,128
创建一个框架
I build a frame

688
00:41:15,248 --> 00:41:18,288
框架中X等于3
which contains x equals three,

689
00:41:18,848 --> 00:41:20,512
而Y等于4
and y equals four.

690
00:41:21,696 --> 00:41:23,488
我要把这个框架
I'm going to connect that frame

691
00:41:24,272 --> 00:41:25,376
连接到这一个框架上
to this frame over here.

692
00:41:27,632 --> 00:41:28,992
对于这个环境
And then this environment,

693
00:41:29,680 --> 00:41:30,976
我把它叫做B
with I will call b,

694
00:41:31,552 --> 00:41:35,024
我会在这个环境中求值E的体
is the environment in which I will evaluate the body of e.

695
00:41:39,888 --> 00:41:40,336
现在
Now,

696
00:41:41,952 --> 00:41:45,040
E可能包含了X和Y的引用以及一些别的东西
e may contain references to x and y and other things.

697
00:41:46,848 --> 00:41:49,952
X和Y的值在这里
x and y will have values right here.

698
00:41:50,704 --> 00:41:52,528
其他的变量的值在这里
Other things will have their values here.

699
00:41:55,056 --> 00:41:56,256
怎样才能获取这个框架呢？
How do we get this frame?

700
00:41:57,264 --> 00:41:59,264
我们通过过程构建来完成
That we do by the construction of procedures

701
00:41:59,616 --> 00:42:00,608
这就是另一条规则了
which is the other rule.

702
00:42:02,032 --> 00:42:04,400
请看下一张幻灯片
And I think that's the next slide.

703
00:42:05,344 --> 00:42:06,128
规则二
Rule two,

704
00:42:07,808 --> 00:42:09,900
当一个LAMBDA表达式被求值时
when a lambda expression is evaluated,

705
00:42:09,900 --> 00:42:11,760
相对于某个特定的环境--
relative to a particular environment--

706
00:42:14,192 --> 00:42:14,400
例如
See,

707
00:42:15,040 --> 00:42:18,120
获取一个过程的方式就是求值一个LAMBDA表达式
the way I get a procedure is by evaluating the lambda expression.

708
00:42:18,192 --> 00:42:19,360
这里有一个LAMBDA表达式
Here's a lambda expression.

709
00:42:20,048 --> 00:42:21,120
通过对它求值
By evaluating it,

710
00:42:21,904 --> 00:42:23,968
我获得了一个可以应用于3的过程
I get a procedure which I can apply to three.

711
00:42:25,088 --> 00:42:26,650
现在这个LAMBDA表达式
Now this lambda expression

712
00:42:26,650 --> 00:42:30,384
在一个Y已被定义的环境中执行
is evaluated in an environment where y is defined.

713
00:42:31,840 --> 00:42:35,840
我希望这个过程的体中包括的Y是自由的
And I want the body of this which contains a free version of y.

714
00:42:36,390 --> 00:42:38,368
在这里面 Y是自由的
y is free in here,

715
00:42:38,720 --> 00:42:40,384
但是在整个的表达式中却是被约束的
it's bound over the whole thing,

716
00:42:41,360 --> 00:42:42,752
而在这里是自由的
but it's free over here.

717
00:42:43,328 --> 00:42:46,240
我想让这两个Y指称同一个Y
I want that y to be this one.

718
00:42:47,440 --> 00:42:55,136
我在Y被创建的环境中求值这个过程的体
I evaluate this body of this procedure in the environment where y was created.

719
00:42:55,328 --> 00:42:58,400
就像这个一样 因为那是通过应用完成的
That's this kind of thing, because that was done by application.

720
00:42:59,008 --> 00:42:59,632
现在
Now,

721
00:43:00,240 --> 00:43:02,608
如果我还想查找Y的值
if I ever want to look up the value of y,

722
00:43:03,104 --> 00:43:04,096
我就必须知道它在哪
I have to know where it is.

723
00:43:04,544 --> 00:43:06,420
因此 这个过程在被创建时
Therefore, this procedural was created,

724
00:43:06,420 --> 00:43:10,060
过程的创建 也就是对LAMBDA表达式求值的结果
the creation of the procedure which is the result of evaluating that lambda expression

725
00:43:10,060 --> 00:43:16,336
最好是获取一个指针或记住Y被约束在哪个框架中
had better capture a pointer or remember the frame in which y was bound.

726
00:43:17,920 --> 00:43:19,760
这就是这个规则的内容
So that's what this rule is telling us.

727
00:43:22,112 --> 00:43:23,136
那么 举个例子
So, for example,

728
00:43:24,448 --> 00:43:29,328
如果我恰好求值了一个LAMBDA表达式
if I happen to be evaluating a lambda expression,

729
00:43:30,896 --> 00:43:33,328
在E中的LAMBDA表达式
lambda expression in e,

730
00:43:34,048 --> 00:43:40,464
在E中求值(LAMBDA (X Y) G)
lambda of say, x and y, let's call it g in e,

731
00:43:41,088 --> 00:43:42,368
对其求值
evaluating that.

732
00:43:42,976 --> 00:43:46,176
这些事的意义就是我现在构建了一个过程对象
all that means is I now construct a procedure object.

733
00:43:47,104 --> 00:43:48,288
E是某个环境
e is some environment.

734
00:43:48,848 --> 00:43:50,944
有个指针指向E
e is something which has a pointer to it.

735
00:43:51,792 --> 00:43:56,688
我构建了一个过程对象指向了这个环境
I construct a procedure object that points up to that environment,

736
00:43:58,560 --> 00:44:00,112
它的代码
where the code of that

737
00:44:00,544 --> 00:44:03,248
是一个LAMBDA表达式 或者是某种中间代码
is a lambda expression or whatever that translates into.

738
00:44:06,240 --> 00:44:07,568
而这就是一个过程
And this is the procedure.

739
00:44:12,384 --> 00:44:14,704
它为我生成了这个和这个
So this produces for me-- this -- this

740
00:44:14,940 --> 00:44:16,370
这个对象
this object here,

741
00:44:16,370 --> 00:44:18,128
这个环境指针
this environment pointer,

742
00:44:18,370 --> 00:44:22,520
获取了求值LAMBDA表达式时的环境
captures the place where this lambda expression was evaluated,

743
00:44:22,624 --> 00:44:24,592
定义所使用的环境
where the definition was used,

744
00:44:25,584 --> 00:44:27,408
创建一个过程时的定义所用的环境
where the definition was used to make a procedure,

745
00:44:30,320 --> 00:44:31,472
从而创建了过程
to make the procedure.

746
00:44:32,896 --> 00:44:36,304
所以 它将环境从定义过程的地方取出
So it picks up the environment from the place where that procedure was defined,

747
00:44:37,424 --> 00:44:38,928
将它保存在过程自己内部
stores it in the procedure itself,

748
00:44:39,600 --> 00:44:40,976
之后当过程被调用时
and then when the procedure is used,

749
00:44:41,328 --> 00:44:43,472
它在被定义时的环境
the environment where it was defined is extended

750
00:44:43,984 --> 00:44:45,072
将由新的框架扩充
with the new frame.

751
00:44:48,720 --> 00:44:52,336
这给了我们一个放置有值的变量的地方
So this gives us a locus for putting where a variable has a value.

752
00:44:53,040 --> 00:44:53,960
举个例子
And, for example,

753
00:44:53,960 --> 00:44:56,816
如果有很多东西指向那这个环境
if there are lots of guys pointing in at that environment,

754
00:44:57,744 --> 00:45:00,336
它们就会共享这个环境
then they share that place.

755
00:45:01,200 --> 00:45:02,528
我们很快将会见到
And we'll see more of that shortly.

756
00:45:04,016 --> 00:45:05,344
现在你们有了一个新模型
Well, now you have a new model

757
00:45:06,384 --> 00:45:09,920
我们用它来理解程序的执行
for understanding the execution of programs.

758
00:45:11,360 --> 00:45:12,784
我觉得现在我应该解答一些问题了
I suppose I'll take questions now,

759
00:45:13,100 --> 00:45:14,960
之后我们再继续
and then we'll go on and use that for something.

760
00:45:18,192 --> 00:45:19,520
学生：这么说是对的吗？
AUDIENCE: Is it right to say then,

761
00:45:19,520 --> 00:45:23,960
环境就是一些被连接在一起的框架
the environment is that linked chain of frames starting with--

762
00:45:23,960 --> 00:45:25,104
教授：对
PROFESSOR: That's right.

763
00:45:25,480 --> 00:45:26,640
学生：通过它能够访问所有的框架？
AUDIENCE:  working all the way back?

764
00:45:27,712 --> 00:45:31,456
教授：是的 环境是一系列被连接在一起的框架
PROFESSOR: Yes, the environment is a sequence of frames linked together.

765
00:45:32,432 --> 00:45:35,472
我对它的理解是 它是指向第一个框架的指针
And the way I like to think about it, it's the pointer to the first one,

766
00:45:36,880 --> 00:45:38,720
因为一旦你获得了它 你就能拿到所有的框架
because once you've got that you've got them all.

767
00:45:43,968 --> 00:45:44,656
还有谁有问题吗？
Anybody else?

768
00:45:45,200 --> 00:45:49,360
学生：有可能在两个不同的环境中定义或求值一个过程
AUDIENCE: Is it possible to evaluate a procedure or to define a procedure in two different environments

769
00:45:49,360 --> 00:45:53,200
使得它有不同的行为 并且有指向两个环境的指针--
such that it will behave differently, and have pointers to both--

770
00:45:53,200 --> 00:45:55,776
教授：噢 是的 同一个过程不会有两个不同环境
PROFESSOR: Oh, yes. The same procedure is not going to have two different environments.

771
00:45:56,900 --> 00:45:59,020
同样的代码
The same code,

772
00:45:59,020 --> 00:46:00,820
比如同样的LAMBDA表达式
the same lambda expression

773
00:46:00,820 --> 00:46:03,728
再不同的环境下求值可能产生不同的过程
can be evaluated in two environments producing two different procedures.

774
00:46:06,032 --> 00:46:07,180
每个过程--
Each procedure--

775
00:46:07,180 --> 00:46:09,950
学生：它们的定义有同样的名字 它们的运算--
AUDIENCE: Their definition has the same name. Their operation--

776
00:46:09,950 --> 00:46:11,920
教授：它们定义是写起来是一样的 使用同样的字母
PROFESSOR: The definition is written the same, with the same characters.

777
00:46:12,560 --> 00:46:14,624
我能求值那一组字母
I can evaluate that set of characters,

778
00:46:14,930 --> 00:46:18,140
或定义的表结构之类的东西
whatever, that list structure that defines,

779
00:46:18,224 --> 00:46:20,416
那只是文本表示
that is the textual representation.

780
00:46:20,912 --> 00:46:24,864
我可以在两个不同环境种对它求值 产生两个不同的过程
I can evaluate that in two different environments producing two different procedures.

781
00:46:25,552 --> 00:46:26,848
每一个过程
Each of those procedures

782
00:46:27,568 --> 00:46:32,192
有它们自己的一组局部变量
has its own local sets of variables,

783
00:46:32,340 --> 00:46:33,456
我们很快就会看到
and we'll see that right now.

784
00:46:36,704 --> 00:46:37,360
还有问题吗？
Anybody else?

785
00:46:42,608 --> 00:46:44,032
好 谢谢大家 我们休息一会
OK, thank you. Let's take a break.

786
00:46:47,980 --> 00:46:57,616
[音乐]
[JESU, JOY OF MAN'S DESIRING]

787
00:46:57,610 --> 00:47:02,032
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

788
00:47:05,984 --> 00:47:09,696
讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
By: Prof. Harold Abelson && Gerald Jay Sussman

789
00:47:09,690 --> 00:47:13,440
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

790
00:47:13,470 --> 00:47:18,848
赋值、状态和副作用
Assignment, State, and Side-effects

791
00:47:22,670 --> 00:47:25,696
现在 我已经对你们做了一件非常糟糕的事儿
Well, now I've done this terrible thing to you.

792
00:47:26,560 --> 00:47:30,544
我引入了一个非常复杂的东西
I've introduced a very complicated thing,

793
00:47:32,768 --> 00:47:33,424
赋值
assignment,

794
00:47:34,512 --> 00:47:38,080
它摧毁了我们程序中大部分的 有趣的数学特性
which destroys most of the interesting mathematical properties of our programs.

795
00:47:41,072 --> 00:47:42,464
我为什么要做这件事呢
Why should I have done this?

796
00:47:43,184 --> 00:47:45,024
这样做可能有什么好处吗？
What possible good could this do?

797
00:47:46,512 --> 00:47:48,864
很明显 这不是一个什么好东西
Clearly not a nice thing,

798
00:47:49,600 --> 00:47:51,232
因此我最好有一个好的理由
so I better have a good excuse.

799
00:47:52,832 --> 00:47:54,800
让我们来小小地玩一下
Well, let's do a little bit of playing,

800
00:47:54,800 --> 00:47:58,352
首先 我们写些非常有趣的带赋值的程序
first of all, with some very interesting programs that have assignment.

801
00:47:58,816 --> 00:48:00,880
来理解它们的特殊之处
Understand something special about them

802
00:48:01,424 --> 00:48:02,832
这些特殊之处使赋值变得有价值
that makes them somewhat valuable.

803
00:48:04,960 --> 00:48:06,704
我们从一个非常简单的程序开始
Start with a very simple program

804
00:48:07,696 --> 00:48:09,280
我把这个程序叫做MAKE-COUNTER
I'm going to call make-counter.

805
00:48:10,480 --> 00:48:18,192
我要把它定义为
I'm going to define make-counter

806
00:48:24,176 --> 00:48:28,128
接受一个参数N的过程
to be a procedure of one argument n

807
00:48:29,232 --> 00:48:32,944
并且它的返回值是一个没有参数的过程--
which returns as its value a procedure of no arguments--

808
00:48:34,368 --> 00:48:36,032
一个生成过程的过程--
a procedure that produces a procedure--

809
00:48:36,848 --> 00:48:44,352
这个过程把N的值设为N+1
which sets n to the increment of n

810
00:48:47,888 --> 00:48:49,776
并且返回N的值
and returns that value of n.

811
00:48:55,376 --> 00:48:57,540
现在 我们要研究它的行为
Now we're going to investigate the behavior of this.

812
00:48:57,540 --> 00:48:59,024
它很有趣
It's a sort of interesting thing.

813
00:48:59,824 --> 00:49:01,450
为了研究它的行为
In order to investigate the behavior,

814
00:49:01,450 --> 00:49:03,088
我需要建立一个环境模型
I have to make an environment model,

815
00:49:04,112 --> 00:49:05,984
因为我们不能通过其他的方式来理解它
because we can't understand this any other way.

816
00:49:08,656 --> 00:49:09,632
所以我们开始吧
So let's just do that.

817
00:49:10,000 --> 00:49:12,864
我们从这里开始
We start out with some sort of--

818
00:49:13,240 --> 00:49:15,904
假设机器天生就有一个全局环境
let's say there is a global environment that the machine is born with.

819
00:49:16,130 --> 00:49:17,120
我们把它叫做Global
Global we'll call it.

820
00:49:20,032 --> 00:49:24,256
它内部有一堆初始化的东西
And it's going to have in it a bunch of initial things.

821
00:49:24,440 --> 00:49:25,600
我们都知道它里面有什么
We all know what it's got.

822
00:49:25,720 --> 00:49:30,880
这里面有+和*
It's got things in it like say, plus, and times,

823
00:49:32,240 --> 00:49:37,264
/ -和CAR
and quotient, and difference, and CAR,

824
00:49:38,704 --> 00:49:39,744
以此类推
and etcetera,

825
00:49:41,450 --> 00:49:42,480
有很多东西
lots of things.

826
00:49:42,880 --> 00:49:43,984
我不知道它们是什么
I don't know what they are,

827
00:49:44,420 --> 00:49:45,552
一些乱七八糟的符号
some various squiggles

828
00:49:46,080 --> 00:49:48,880
机器一开始就有这些特性
that are the things the machine is born with.

829
00:49:51,216 --> 00:49:53,232
通过在这做定义
And by doing the definition here,

830
00:49:54,688 --> 00:49:55,760
我要做的是--
what I plan to do--

831
00:49:56,320 --> 00:49:57,310
我在干什么呢？
Well, what am I doing?

832
00:49:57,310 --> 00:49:59,584
我要把它关联到全局环境上
I'm doing this relative to the global environment.

833
00:49:59,720 --> 00:50:01,296
这是我的环境指针
So here's my environment pointer.

834
00:50:03,728 --> 00:50:06,704
为了达到那个目的 我要求值这个LAMBDA表达式
In order to do that I have to evaluate this lambda expression.

835
00:50:08,352 --> 00:50:10,016
这意味着我创建了一个过程对象
That means I make a procedure object.

836
00:50:11,504 --> 00:50:13,264
所以 我要在这创建一个过程对象
So I'm going to make a procedure object here.

837
00:50:17,360 --> 00:50:18,688
这个过程对象
And the procedure object has,

838
00:50:18,720 --> 00:50:20,496
由于在它被定义的地方
as the place it's defined,

839
00:50:21,168 --> 00:50:22,352
有一个全局的环境
the global environment.

840
00:50:24,064 --> 00:50:25,792
这个过程对象包括了
The procedure object contains

841
00:50:28,160 --> 00:50:31,472
以N为参数的过程的代码
some code that represents a procedure of one argument n

842
00:50:31,960 --> 00:50:35,344
它返回一个不接受参数的过程
which returns a procedure of no arguments which does something.

843
00:50:38,240 --> 00:50:43,280
DEFINE是一种改变环境的方法
And the define is a way of changing this environment,

844
00:50:44,320 --> 00:50:46,736
所以我把MAKE-COUNTER加入全局环境中
so that I now add to it a make-counter,

845
00:50:52,288 --> 00:50:55,056
这是对于特殊的东西定义的一个特殊的规则
a special rule for the special thing defined.

846
00:50:55,824 --> 00:50:56,944
但它其实是
But what that is,

847
00:50:58,944 --> 00:51:01,968
它给了我们一个指针 指向那个过程
is it gives me that pointer to that procedure.

848
00:51:03,824 --> 00:51:06,320
所以现在全局环境中也有了MAKE-COUNTER
So now the global environment contains make-counter as well.

849
00:51:09,280 --> 00:51:11,216
现在 我们要进行一些操作
Now, we're going to do some operations.

850
00:51:11,872 --> 00:51:13,504
我要用它来创建一些计数器
I'm going to use this to make some counters.

851
00:51:14,992 --> 00:51:16,208
我们来看看计数器是什么
We'll see what a counter is.

852
00:51:17,120 --> 00:51:18,512
所以我们定义
So let's define

853
00:51:23,328 --> 00:51:26,656
C1为一个从0开始的计数器
c1 to be a counter beginning at 0.

854
00:51:35,728 --> 00:51:38,384
根据模型 我们知道如何做这个了
Well, we know how to do this now, according to the model.

855
00:51:39,632 --> 00:51:44,336
我需要在全局环境中求值这个表达式
I have to evaluate the expression make-counter in the global environment,

856
00:51:45,408 --> 00:51:46,272
(MAKE-COUNTER 0)
make-counter of 0.

857
00:51:47,808 --> 00:51:51,104
我查找MAKE-COUNTER 发现它是一个过程
Well, I look up make-counter and see that it's a procedure.

858
00:51:53,616 --> 00:51:55,296
我将要应用这个过程
I'm going to have to apply that procedure.

859
00:51:56,224 --> 00:51:57,744
应用这个过程的方式
The way I apply the procedure

860
00:51:58,432 --> 00:51:59,968
就是构建一个框架
is by constructing a frame.

861
00:52:01,808 --> 00:52:03,792
所以我构建了一个框架
Okay? So I construct a frame

862
00:52:06,592 --> 00:52:10,448
它内部有一个N的值
which has a value for n in it

863
00:52:11,776 --> 00:52:12,640
这个值是0
which is 0

864
00:52:14,000 --> 00:52:15,344
它的父环境
and the parent environment

865
00:52:15,872 --> 00:52:19,328
就是定义MAKE-COUNTER时的环境
is the one which is the environment of definition of make-counter.

866
00:52:23,936 --> 00:52:28,368
所以我已经通过将MAKE-COUNTER应用于0上 而创建了一个环境
So I've made an environment by applying make-counter to 0.

867
00:52:31,450 --> 00:52:34,400
现在 我需要求值MAKE-COUNTER的体
Now, I have to evaluate the body of make-counter,

868
00:52:34,410 --> 00:52:37,728
就是那个环境中的LAMBDA表达式
which is this lambda expression, in that environment.

869
00:52:40,640 --> 00:52:42,304
求值这个体
Well evaluating this body,

870
00:52:42,768 --> 00:52:44,592
它是一个LAMBDA表达式
this body is a lambda expression.

871
00:52:46,288 --> 00:52:48,864
对LAMBDA表达式求值 意味着创建一个过程对象
Evaluate a lambda expression means make a procedure object.

872
00:52:49,568 --> 00:52:51,008
所以我将创建一个过程对象
So I'm going to make a procedure object.

873
00:52:56,768 --> 00:52:58,290
这个过程对象
And that procedure object has

874
00:52:58,290 --> 00:53:00,464
拥有一个环境
the environment it was defined in being that,

875
00:53:04,208 --> 00:53:05,888
在这个环境中N被定义为0
where n was defined to be 0.

876
00:53:07,680 --> 00:53:08,800
它有一些代码
And it has some code,

877
00:53:08,830 --> 00:53:11,376
这个过程不需要参数
which is the procedure of no arguments

878
00:53:11,408 --> 00:53:15,280
该过程进行一些处理 然后进行赋值
which does something, then sets something,

879
00:53:15,280 --> 00:53:16,736
并返回N
and returns n.

880
00:53:17,888 --> 00:53:18,816
这个东西
And this thing

881
00:53:19,424 --> 00:53:21,232
将成为一个对象
is going to be the object,

882
00:53:21,920 --> 00:53:24,672
在全局环境中 它的名字是C1
which in the global environment, will have the name c1.

883
00:53:26,128 --> 00:53:28,336
所以我们在这建立一个名字 C1
So we construct a name here, c1,

884
00:53:28,640 --> 00:53:32,144
并且说C1等于这个过程
and say that equals that.

885
00:53:35,488 --> 00:53:37,360
现在 再来创建另一个计数器
Now, but also make another counter,

886
00:53:43,040 --> 00:53:45,136
通过MAKE-COUNTER创建c2
c2 to be make-counter

887
00:53:50,944 --> 00:53:52,192
让它从10开始
say, starting with 10.

888
00:53:54,250 --> 00:53:55,904
然后我执行同样的步骤
Then I do essentially the same thing.

889
00:53:56,640 --> 00:54:00,400
我应用这个MAKE-COUNTER过程
I apply the make-counter procedure, which I got from here,

890
00:54:00,992 --> 00:54:04,528
建立另一个框架 其中N等于10
to make another frame with n being 10.

891
00:54:05,632 --> 00:54:09,184
全局环境作为它的父环境
That frame has the global environment as its parent.

892
00:54:10,048 --> 00:54:11,808
然后我构建一个过程
I then construct a procedure

893
00:54:13,040 --> 00:54:17,632
以这个框架作为它定义的环境
which has that as it's frame of definition.

894
00:54:18,272 --> 00:54:21,664
它的代码是
The code of it is

895
00:54:21,800 --> 00:54:24,384
完成一些操作的无参过程
the procedure of no arguments which does something.

896
00:54:25,540 --> 00:54:28,600
然后进行赋值 等等
And it does a set, and so on.

897
00:54:28,600 --> 00:54:31,220
然后返回N
And n comes out. Okay?

898
00:54:31,456 --> 00:54:34,832
这就是C2
And c2 is this.

899
00:54:36,880 --> 00:54:39,328
好 你们应该发现 某些东西开始变得有趣了
Well, you're already beginning to see something fairly interesting.

900
00:54:40,176 --> 00:54:41,920
这里有两个N
There are two n's here.

901
00:54:42,928 --> 00:54:44,192
它们不是同一个N
They are not one n.

902
00:54:46,144 --> 00:54:48,160
我每次调用MAKE-COUNTER的时候
Each time I called make-counter,

903
00:54:48,640 --> 00:54:50,256
我就创建了另一个N的实例
I made another instance of n.

904
00:54:52,624 --> 00:54:54,400
它们彼此独立 没有关联
These are distinct and separate from each other.

905
00:54:57,792 --> 00:55:00,288
现在 我们来使用一下这些计数器
Now, let's do some execution, use those counters.

906
00:55:05,920 --> 00:55:15,008
如果此时 我调用C1 会发生什么？
Well, what happens if I say, c1 at this point?

907
00:55:15,840 --> 00:55:17,344
我会在这里查找
Well, I go over here,

908
00:55:17,560 --> 00:55:19,984
发现C1是一个过程
and I say, oh yes, c1 is a procedure.

909
00:55:20,640 --> 00:55:22,784
我要不带参数地调用这个过程
I'm going to call this procedure on no arguments,

910
00:55:23,160 --> 00:55:24,960
因为它不需要参数
but it has no parameters.

911
00:55:24,960 --> 00:55:25,632
对吧？
That's right.

912
00:55:26,976 --> 00:55:27,840
它的体是什么呢？
What's its body?

913
00:55:27,960 --> 00:55:30,020
我得来这里解释 因为我没有给誊过来
Well, I have to look over here, because I didn't write it down.

914
00:55:30,020 --> 00:55:32,656
这个过程体是将N赋值为N+1
It said, set n to one plus n

915
00:55:33,808 --> 00:55:34,896
并且返回N
and return n,

916
00:55:37,120 --> 00:55:38,128
就是把N增大1
increment n.

917
00:55:38,976 --> 00:55:41,600
它的N指的是这个
Well, the n it says is this one.

918
00:55:43,088 --> 00:55:44,608
所以我把这个n增大1
So I increment that n.

919
00:55:45,808 --> 00:55:47,008
它变成了1
That becomes one,

920
00:55:48,640 --> 00:55:50,240
然后返回了1
and I return the value one.

921
00:55:53,136 --> 00:55:56,496
之后我调用C2
Supposing I then called c2.

922
00:55:58,384 --> 00:55:59,200
我会做什么？
Well, what do I do?

923
00:55:59,232 --> 00:56:03,330
C2是相同的过程
I say c2 is this procedure which does the same thing,

924
00:56:03,330 --> 00:56:04,480
但这个N
but here's the n.

925
00:56:05,330 --> 00:56:06,576
它变成了11
It becomes 11.

926
00:56:10,976 --> 00:56:14,592
所以返回值是11
And so I have an 11 which is the value.

927
00:56:15,920 --> 00:56:18,320
然后我们再来调用一下C1
I then can say, let's try c1 again.

928
00:56:20,912 --> 00:56:22,560
C1是这个
hum, c1 is this,

929
00:56:23,280 --> 00:56:24,160
它是2
that's two,

930
00:56:27,248 --> 00:56:28,304
所以结果是2
so the answer is two.

931
00:56:29,664 --> 00:56:30,752
然后调用C2
And c2

932
00:56:33,376 --> 00:56:35,312
然后C2通过同样的方法 返回了12
gives me a 12 by the same method,

933
00:56:35,744 --> 00:56:37,550
它在这里进行查找
by walking down here looking at that

934
00:56:37,550 --> 00:56:39,280
发现了N 并把它加1
and saying, here's the n, I'm incrementing.

935
00:56:41,648 --> 00:56:43,680
我拥有的是可计算的对象
So what I have are computational objects.

936
00:56:45,216 --> 00:56:46,864
它们是两个计数器
There are two counters,

937
00:56:48,960 --> 00:56:51,024
每一个都有各自独立的局部状态
each with its own independent local state.

938
00:56:55,488 --> 00:56:56,624
我们再进一步
Let's talk about this a little.

939
00:56:56,640 --> 00:56:58,528
这是个奇怪的东西
This is a strange thing.

940
00:57:01,120 --> 00:57:02,224
什么是对象？
What's an object?

941
00:57:04,112 --> 00:57:06,128
这个概念并不明确
It's not at all obvious what an object is.

942
00:57:07,552 --> 00:57:09,456
我们倾向于以对象的角度思考
We like to think about objects,

943
00:57:11,248 --> 00:57:13,328
因为这样思考比较经济
because it's economical to think that way.

944
00:57:14,624 --> 00:57:17,280
这是一种智力上的经济
It's an intellectual economy.

945
00:57:18,576 --> 00:57:19,616
我是一个对象
I am an object.

946
00:57:20,992 --> 00:57:22,304
你也是一个对象
You are an object.

947
00:57:23,552 --> 00:57:25,296
但我们不是同一个对象
We are not the same object.

948
00:57:27,520 --> 00:57:29,648
我可以把世界分为两部分
I can divide the world into two parts,

949
00:57:29,920 --> 00:57:31,856
我和你
me and you,

950
00:57:31,920 --> 00:57:33,312
以及其它的东西
and there's other things as well,

951
00:57:34,704 --> 00:57:35,264
使得
such that

952
00:57:35,440 --> 00:57:39,504
大多数对于我的讨论
most of the things I might want to discuss about my workings

953
00:57:39,680 --> 00:57:40,896
不会影响到你
do not involve you,

954
00:57:41,392 --> 00:57:44,672
大多数对于你的讨论不会牵涉到我
and most of the things I want to discuss about your workings don't involve me.

955
00:57:45,664 --> 00:57:46,944
我有血压
I have a blood pressure,

956
00:57:47,504 --> 00:57:48,384
体温
a temperature,

957
00:57:49,360 --> 00:57:51,488
呼吸频率
a respiration rate,

958
00:57:53,344 --> 00:57:54,992
血液中有确定的血糖值
certain amount of sugar in my blood,

959
00:57:56,112 --> 00:57:59,344
数不清的 数以千计的状态变量--上百万实际上
and numerous, thousands, of state variables-- millions actually,

960
00:57:59,376 --> 00:58:00,656
我不知道具体有多少
or I don't know how many--

961
00:58:00,930 --> 00:58:03,488
以物理学观点 我拥有大量的状态变量
huge numbers of state variables in the physical sense

962
00:58:04,912 --> 00:58:07,120
如果将我视为一个粒子的话
which represent the state of me as a particle,

963
00:58:09,152 --> 00:58:10,640
你也有许许多多这样的变量
and you have gazillions of them as well.

964
00:58:12,688 --> 00:58:14,944
我们的大多数变量之间是好无联系的
And most of mine are uncoupled to most of yours.

965
00:58:17,312 --> 00:58:19,504
所以可以计算我的属性
So we can compute the properties of me

966
00:58:20,560 --> 00:58:22,832
而不用太担心你的属性
without worrying too much about the properties of you.

967
00:58:23,824 --> 00:58:25,776
如果把我们两个放在一起计算
If we had to work about both of us together,

968
00:58:25,960 --> 00:58:27,824
那么我们需要考虑的状态的数量
than the number of states that we have to consider

969
00:58:27,824 --> 00:58:30,010
就是你与我的状态的数量的乘积
is the product of the number of states you have and the number of states I have.

970
00:58:30,528 --> 00:58:32,112
按对象解耦的话 则只需考虑你我状态之和
But this way it's almost a sum.

971
00:58:32,656 --> 00:58:35,344
然而 实际上有一种力量把我们耦合起来
Now, indeed there are forces that couple us.

972
00:58:36,000 --> 00:58:37,952
我对你讲话 你的状态就变了
I'm talking to you and your state changes.

973
00:58:38,448 --> 00:58:40,096
我看着你 我的状态就变了
I'm looking at you and my state changes.

974
00:58:41,728 --> 00:58:44,080
因此 我的变量中的一小部分
Some of my state variables, a very few of them,

975
00:58:44,336 --> 00:58:46,070
与你的一些变量是耦合的
therefore, are coupled to yours.

976
00:58:46,070 --> 00:58:47,800
如果你突然大喊大叫
If you were to suddenly yell very loud,

977
00:58:47,800 --> 00:58:48,880
我的血压就会升高
my blood pressure would go up.

978
00:58:54,304 --> 00:58:56,864
然而 将世界看作是由独立的变量
However, and it may not be always appropriate

979
00:58:57,170 --> 00:59:01,168
和独立的粒子组成的是不恰当的
to think about the world as being made out of independent states and independent particles.

980
00:59:02,128 --> 00:59:04,464
在像量子力学这样的东西里存在大量的BUG
Lots of the bugs that occur in things like quantum mechanics,

981
00:59:05,230 --> 00:59:08,704
或者当我们思考像量子力学之类的东西的时候 会在我们的脑海中产生bug
or the bugs in our minds that occur when we think about things like quantum mechanics,

982
00:59:08,896 --> 00:59:10,970
这是由于 当我们思考事物时
are due the fact that we are trying to think about things

983
00:59:10,970 --> 00:59:12,960
会去将事物分解为相互独立的部分来看待
being broken up into independent pieces,

984
00:59:13,584 --> 00:59:17,328
而事实上事物的耦合程度 远远大于在表面所看到的
when in fact there's more coupling than we see on the surface,

985
00:59:18,016 --> 00:59:19,440
即便这样 我们仍像那样思考
or that we want to believe in,

986
00:59:19,616 --> 00:59:21,696
是因为我们希望高效并且有效的进行计算
because we want to compute efficiently and effectively.

987
00:59:22,192 --> 00:59:23,824
我们被培养成以那种方式进行思考
We've been trained to think that way.

988
00:59:29,760 --> 00:59:30,512
大家看
Well, let's see.

989
00:59:31,504 --> 00:59:33,440
我们如何才能知道我们是否有对象？
How would we know if we had objects at all?

990
00:59:35,120 --> 00:59:37,344
如果我们有对象 应该如何分辨呢？
How can we tell if we have objects?

991
00:59:37,640 --> 00:59:41,456
通过思考一些光学现象
Consider some possible optical illusions.

992
00:59:42,464 --> 00:59:43,136
就能解答这个问题
This could be done.

993
00:59:45,040 --> 00:59:47,696
这几截粉笔不完全相同
These pieces of chalk are not appropriately identical,

994
00:59:47,760 --> 00:59:50,208
但假设 只通过观察是无法区分它们的
but supposing you couldn't tell the difference of them by looking at them.

995
00:59:52,048 --> 00:59:53,320
有一种可能
Well, there's a possibility

996
00:59:53,320 --> 00:59:55,168
是这一切都是我们与镜子的游戏
that this all a game I'm playing with mirrors.

997
00:59:56,070 --> 00:59:57,600
它们真的是同一截粉笔
It's really the same piece of chalk,

998
00:59:59,360 --> 01:00:00,480
但你看到了两个
but you're seeing two of them.

999
01:00:01,616 --> 01:00:03,872
你怎么知道你看到的是一个还是两个呢？
How would you know if you're seeing one or two?

1000
01:00:05,040 --> 01:00:06,704
我只知道有一种方法可以确定
Well, there's only one way I know.

1001
01:00:07,376 --> 01:00:08,944
抓起其中一个并且改变它
You grab one of them and change it

1002
01:00:09,456 --> 01:00:10,672
然后看看另一个有没有跟着变化
and see if the other one changed.

1003
01:00:14,016 --> 01:00:14,672
而另一个没有变化
And it didn't,

1004
01:00:15,504 --> 01:00:16,144
所以它们是两截不同粉笔
so there's two of them.

1005
01:00:19,504 --> 01:00:20,160
另一方面
And, on the other hand,

1006
01:00:20,176 --> 01:00:22,208
事物还有一些其它的类似的纠结属性
there is some other screwy properties of things like that.

1007
01:00:22,576 --> 01:00:24,016
例如 我们怎么才知道某个东西是否改变了呢？
Like, how do we know if something changed?

1008
01:00:25,008 --> 01:00:27,936
我们需要在它改变之前和之后进行观察
We have to look at it before and after the change.

1009
01:00:28,650 --> 01:00:30,020
改变就是赋值
The change is an assignment,

1010
01:00:30,020 --> 01:00:31,456
它是时间中的一个时刻
it's a moment in time.

1011
01:00:32,144 --> 01:00:34,608
但是那意味着我们需要知道 我们看到的是否是同一个
But that means we have to know it was the same one that we're looking at.

1012
01:00:36,512 --> 01:00:38,840
所以一些东西非常奇怪
So some very strange, and unusual,

1013
01:00:38,840 --> 01:00:40,384
不同寻常并且晦涩难懂
and obscure, and -- I don't understand

1014
01:00:40,840 --> 01:00:43,520
并且我不理解与赋值
the problems associated with assignment,

1015
01:00:44,450 --> 01:00:46,288
变化以及对象有关的问题
and change, and objects.

1016
01:00:47,296 --> 01:00:48,992
这些东西可能变得非常非常糟糕
These could get very, very bad.

1017
01:00:51,408 --> 01:00:52,128
例如
For example,

1018
01:00:53,312 --> 01:00:55,600
我 一个特定的人
here I am, I am a particular person,

1019
01:00:56,160 --> 01:00:57,728
一个特定的对象
a particular object, okay?

1020
01:00:57,960 --> 01:00:59,312
现在 我可以拿出小刀
Now, I can take out my knife,

1021
01:01:00,688 --> 01:01:01,776
切下一片我的指甲
and cut my fingernail.

1022
01:01:01,890 --> 01:01:04,816
一片指甲掉在了桌子上
Alright? A piece of my fingernail has fallen off onto the table.

1023
01:01:05,936 --> 01:01:10,160
我相信自己和一秒钟之前的自己 是同一个人
I believe I am the same person I was a second ago,

1024
01:01:10,976 --> 01:01:12,816
但在物理上并不是分毫不差
but I'm not physically the same in the slightest.

1025
01:01:14,464 --> 01:01:15,430
我已经改变了
I have changed.

1026
01:01:15,584 --> 01:01:16,656
为什么我还是同一个人呢？
Why am I the same?

1027
01:01:18,112 --> 01:01:19,408
什么能认定我的身份呢？
What is the identity of me?

1028
01:01:20,960 --> 01:01:23,504
我不知道
I don't know...Okay?

1029
01:01:25,056 --> 01:01:27,888
除非我有某种特征
Except for the fact that I have some sort of identity.

1030
01:01:29,712 --> 01:01:33,040
我觉得 由于引入赋值和对象
And so, I think by introducing assignment and objects,

1031
01:01:33,648 --> 01:01:38,288
我们不得不去面对这种
we have opened ourselves up to all the horrible questions of philosophy

1032
01:01:38,416 --> 01:01:42,240
困扰了哲学家们上千年的哲学问题
that have been plaguing philosophers for some thousands of years about this sort of thing.

1033
01:01:43,424 --> 01:01:44,992
这也是相比之下 为什么数学清晰得多
It's why mathematics is a lot cleaner.

1034
01:01:45,696 --> 01:01:50,240
我将尽我所能地向大家阐述关于动作和身份的理解
Let's look at the best things I know to say about actions and identity.

1035
01:01:52,448 --> 01:01:55,392
我们说动作A 对于对于某个对象X有影响
We say that an action, a, had an effect on an object, x,

1036
01:01:55,776 --> 01:01:56,704
换句话说
or equivalently,

1037
01:01:56,928 --> 01:01:58,416
X被A改变
that x was changed by a,

1038
01:01:58,896 --> 01:02:01,664
如果某个属性P 在P作用于X之前为真
if some property, p, which was true of x before a,

1039
01:02:01,872 --> 01:02:03,760
在A作用于X之后为假
became false of x after a.

1040
01:02:04,992 --> 01:02:05,632
那是个测试
That's test.

1041
01:02:06,624 --> 01:02:09,664
这也意味着 我必须有变动前和变动后的X
It still means I have to have the x before and after.

1042
01:02:10,912 --> 01:02:12,544
或者 换句话说
Or, the other way of saying this is,

1043
01:02:12,944 --> 01:02:14,944
我们说对任一动作 两个对象X和Y是同一个对象
we say that two objects x and y are the same for any action

1044
01:02:14,976 --> 01:02:17,936
当且仅当 该动作对X、Y有同样的影响
which has an effect on x has the same effect on y

1045
01:02:19,632 --> 01:02:21,390
然而 就像我说的
However, objects are very useful,

1046
01:02:21,440 --> 01:02:23,184
对象在智力经济上是非常有用的
as I said, for intellectual economy.

1047
01:02:24,640 --> 01:02:27,120
对于它们来说非常有用的东西之一
One of the things that's incredibly useful about them,

1048
01:02:28,272 --> 01:02:29,440
就是对于这个世界
is that the world

1049
01:02:30,784 --> 01:02:34,800
我们习惯于把它认为是由带有独立状态的独立对象所构成的
is made out of independent objects with independent local state.

1050
01:02:35,008 --> 01:02:37,280
虽然那并不完全正确 但我们喜欢以那样的的方式来思考
We like to think that way, although it isn't completely true.

1051
01:02:39,680 --> 01:02:42,030
当我们要写一个非常复杂的程序
When we want to make very complicated programs

1052
01:02:42,030 --> 01:02:43,264
来应对这样一个世界时
that deal with such a world,

1053
01:02:43,984 --> 01:02:46,448
如果我们希望这些程序可以被我们理解
if we want those programs to be understandable by us

1054
01:02:46,912 --> 01:02:48,144
并且也是可修改的
and also to be changeable,

1055
01:02:48,730 --> 01:02:51,120
那么如果世界改变了 我们只需要稍微改动一下程序
so that if we change the world we change the program only a little bit,

1056
01:02:51,392 --> 01:02:53,700
我们希望建立一种联系 一种同构
then we want there to be connections, isomorphism,

1057
01:02:53,824 --> 01:02:56,880
建立在真实世界的对象与我们脑海中的对象之间
between the objects in the world and the objects in our mental model.

1058
01:02:58,768 --> 01:03:01,440
世界的模块化 使我们的程序得以模块化
The modularity of the world can give us the modularity in our programming.

1059
01:03:02,416 --> 01:03:05,360
所以我们发明了面向对象编程
So we invent things called object-oriented programming and things like that

1060
01:03:05,888 --> 01:03:08,368
使我们获得那样的力量
to provide us with that power.

1061
01:03:10,064 --> 01:03:10,944
但是 它甚至更简单
But it's even easier.

1062
01:03:10,944 --> 01:03:12,256
让我们玩一个小游戏
Let's play a little game.

1063
01:03:12,270 --> 01:03:13,184
我想通过这个游戏
I want to play a little game,

1064
01:03:13,390 --> 01:03:15,776
给你展示一个更简单的例子
show you an even easier example

1065
01:03:16,000 --> 01:03:21,744
来说明谨慎地使用赋值语句 可以增强模块性
or where modularity can be enhanced by using an assignment statement, judiciously.

1066
01:03:22,864 --> 01:03:25,350
有一件事 我想让你牢牢地铭记
One thing I want to enforce and impress on you,

1067
01:03:25,450 --> 01:03:27,440
就是不要像在FORTRAN Basic
is don't use assignment statements the way

1068
01:03:27,456 --> 01:03:29,790
或者Pascal里一样使用赋值语句
you use it in FORTRAN or Basic or something or Pascal,

1069
01:03:30,000 --> 01:03:31,712
你不那样做 也能达到目的
to do the things you don't have to do with it.

1070
01:03:34,048 --> 01:03:36,624
这不是思考大多数事情的正确方式
It's not the right way to think for most things.

1071
01:03:36,976 --> 01:03:38,288
有些时候它是必要的
Sometimes it's essential,

1072
01:03:38,688 --> 01:03:39,690
或者可能是必要的
or maybe it's essential.

1073
01:03:39,690 --> 01:03:40,976
我们一会更深入地去研究
We'll see more about that too.

1074
01:03:42,240 --> 01:03:44,224
我要给你展示一个有趣的游戏
OK, let me show you a fun game here.

1075
01:03:47,616 --> 01:03:49,424
从前有一个数学家
There was a mathematician

1076
01:03:49,680 --> 01:03:53,696
叫做Cesaro
by the name of Cesaro--or Cesaro, Cesaro I suppose it is--

1077
01:03:54,480 --> 01:03:57,456
他发现了一个计算pi的巧妙方法
who figured out a clever way of computing pi.

1078
01:03:58,380 --> 01:04:04,304
这个方法是说 如果我有两个随机数
It turns out that if I take two random numbers

1079
01:04:05,248 --> 01:04:06,944
两个随机的整数
two integers at random,

1080
01:04:07,744 --> 01:04:09,488
计算它们的最大公约数
and compute the greatest common divisor,

1081
01:04:10,944 --> 01:04:13,248
结果可能是1 或者不是1
their greatest common divisor is either one or it's not one.

1082
01:04:13,840 --> 01:04:15,648
如果是1 它们没有公约数
If it's one, then they have no common divisors.

1083
01:04:18,144 --> 01:04:20,680
如果它们的最大公约数是1
If their greatest common divisor is one--

1084
01:04:21,120 --> 01:04:23,090
这两个随机数
the probability that two random numbers,

1085
01:04:23,090 --> 01:04:26,384
两个随机生成的数 最大公约数为1的概率
two numbers chosen at random, has as greatest common divisor one

1086
01:04:26,580 --> 01:04:27,824
与pi有关系
is related to pi.

1087
01:04:29,328 --> 01:04:30,112
事实上
In fact--

1088
01:04:31,110 --> 01:04:32,336
是的 这很奇怪
yes, it's very strange--

1089
01:04:32,944 --> 01:04:34,416
当然有其他计算pi的方法
of course there are other ways of computing pi,

1090
01:04:34,416 --> 01:04:38,944
像投针法之类的的方法
like dropping pins on flags, and things like that, and sort of the same kind of thing.

1091
01:04:40,192 --> 01:04:48,976
N1和N2的最大公约数是1的概率为
So the probability of that the GCD of number one and number two,

1092
01:04:49,440 --> 01:04:51,024
N1、N2是随机选取的两个数
two random numbers chosen,

1093
01:04:51,712 --> 01:04:53,664
是6/pi^2
is 6 over pi squared.

1094
01:04:55,616 --> 01:04:56,832
我不准备证明这个
I'm not going to try to prove that.

1095
01:04:57,152 --> 01:04:59,648
事实上这不难 并且有些有趣
It's actually not too hard and sort of fun.

1096
01:05:01,072 --> 01:05:03,056
我们要怎样估算这个概率呢？
How would we estimate such probability?

1097
01:05:03,536 --> 01:05:06,464
我们估算概率的方法则是
Well, the way we do that, the way we estimate the probabilities,

1098
01:05:07,232 --> 01:05:08,656
是做大量的实验
is by doing lots of experiments,

1099
01:05:09,200 --> 01:05:12,010
去计算成功的试验
and then computing the ratios of the ones that come out one way

1100
01:05:12,010 --> 01:05:13,584
与试验总次数的比率
to the total number of experiments we do.

1101
01:05:16,320 --> 01:05:17,280
这种方法叫做蒙特卡罗方法
It's called Monte Carlo,

1102
01:05:18,048 --> 01:05:22,380
它也可以用于计算包含大量变量的积分
and it's useful in other contexts for doing things like integrals where you have lots and lots of variables--

1103
01:05:22,944 --> 01:05:25,280
其中积分的面积是限定的
the space which is limiting the dimensions you are doing you integral in.

1104
01:05:26,272 --> 01:05:28,704
回到这里
But going back to here,

1105
01:05:29,760 --> 01:05:31,728
我们来看看这张幻灯片
Let's look at this slide,

1106
01:05:33,968 --> 01:05:36,928
我们可以用Cesaro的方法来估算pi的值
We can use Cesaro's method for estimating pi

1107
01:05:37,190 --> 01:05:43,180
通过N次试验 取结果的六分之一 开根号
with n trials by taking the square root of six over a Monte Carlo,

1108
01:05:43,290 --> 01:05:46,464
用蒙特卡罗方法
a Monte Carlo experiment with n trials,

1109
01:05:46,800 --> 01:05:50,380
进行了N次Cesaro实验
with n trials using Cesaro's experiment,

1110
01:05:51,376 --> 01:05:57,568
这个实验是关于两个随机数的最大公约数的--
where Cesaro's experiment is the test of whether the GCD of two random numbers--

1111
01:05:58,960 --> 01:06:01,600
你可以看到 我已经在这里进行了一些赋值
And you can see that I've already got some assignments in here,

1112
01:06:01,840 --> 01:06:03,136
就像我写的这样
just by what I wrote.

1113
01:06:04,048 --> 01:06:07,490
这个在括号中的RAND
The fact that this word rand, in parentheses,

1114
01:06:07,490 --> 01:06:09,097
这个过程调用
therefore, that procedure call,

1115
01:06:09,090 --> 01:06:11,395
生成了一个与这个RAND不同的值
yields a different value than this one,

1116
01:06:11,390 --> 01:06:13,728
至少是我写的这样所假设的
at least that's what I'm assuming by writing this this way,

1117
01:06:14,624 --> 01:06:16,752
这表明这不是一个函数
indicates that this is not a function,

1118
01:06:18,208 --> 01:06:20,576
这里面会有一个不断改变内部状态
that there's internal state in it which is changing.

1119
01:06:22,272 --> 01:06:28,640
如果两个随机数的最大公约数等于1
If the GCD of those two random numbers is equal to one,

1120
01:06:28,640 --> 01:06:29,792
这就是整个实验过程
that's the experiment.

1121
01:06:31,488 --> 01:06:35,184
那么我有了一个实验方法 用来估算pi的值
So here I have an experimental method for estimating the value of pi.

1122
01:06:36,512 --> 01:06:39,728
我可以轻松地将这个问题分为两个部分
Where, I can easily divide this problem into two parts.

1123
01:06:40,020 --> 01:06:44,704
一部分是使用蒙特卡罗方法进行特定的Cesaro实验 就像你刚才看到那个
One is the specific Monte Carlo experiment of Cesaro, which you just saw,

1124
01:06:44,992 --> 01:06:48,560
另一部分就是一般性蒙特卡罗方法的实现
and the other is the general technique of doing Monte Carlo experiments.

1125
01:06:49,168 --> 01:06:50,272
就是这个
And that's what this is.

1126
01:06:51,040 --> 01:06:55,472
如果我想进行N次蒙特卡罗试验
If I want to do Monte Carlo experiments with n trials,

1127
01:06:55,670 --> 01:06:58,368
即一个确定的试验次数 和一个确定的实验
a certain number of trials, and a particular experiment,

1128
01:06:59,312 --> 01:07:00,336
我进行实验的方法就是
the way I do that

1129
01:07:00,848 --> 01:07:02,704
构建一个迭代过程
is I make a little iterative procedure

1130
01:07:03,312 --> 01:07:07,264
这个过程有两个变量 分别是试验的剩余次数和通过次数
which has variable the number of trials remaining and the number trials that have been passed,

1131
01:07:08,352 --> 01:07:09,440
也就是实验结果为真的次数
that I've gotten true.

1132
01:07:10,130 --> 01:07:12,213
如果剩余次数为0
And if the number remaining is 0,

1133
01:07:12,210 --> 01:07:15,360
结果就是通过的次数除以总次数
then the answer is the number past divided by this whole number of trials,

1134
01:07:16,048 --> 01:07:17,520
也就是该概率的估算值
was the estimate of the probability.

1135
01:07:19,072 --> 01:07:20,040
如果剩余次数不是0
And if it's not,

1136
01:07:20,040 --> 01:07:22,080
如果还有试验要做
if I have more trials to do,

1137
01:07:22,080 --> 01:07:23,824
那么接下来我们就进行一次试验
then let's do one. We do an experiment.

1138
01:07:23,856 --> 01:07:27,300
我们调用一次没有参数的实验的过程
We call the procedure which is experiment on no arguments.

1139
01:07:27,300 --> 01:07:28,432
我们进行这个试验
We do the experiment

1140
01:07:29,104 --> 01:07:30,640
如果实验结果为真
and then, if that turned out to be true,

1141
01:07:30,820 --> 01:07:32,256
我们继续循环
we go around the loop

1142
01:07:32,620 --> 01:07:35,424
试验剩余次数减1
decrementing the number of experiments we have to do by one

1143
01:07:35,700 --> 01:07:37,488
将试验通过次数加1
and incrementing the number that were passed.

1144
01:07:38,576 --> 01:07:40,112
如果试验的结果为假
And if the experiment was false,

1145
01:07:40,416 --> 01:07:42,250
我们继续循环
we just go around the loop

1146
01:07:42,320 --> 01:07:44,380
剩余试验次数减1
decrementing the number of experiments remaining

1147
01:07:44,448 --> 01:07:46,608
试验通过次数保持不变
and keeping the number passed the same.

1148
01:07:48,768 --> 01:07:54,592
我们以TRIAL为剩余次数 以0为通过次数 开始迭代
We start this up iterating over the total number of trials with 0 experiments past.

1149
01:07:55,424 --> 01:07:57,104
多么简洁的小程序啊
A very elegant little program.

1150
01:07:57,744 --> 01:08:00,550
我不一定非要进行Cesaro的实验
And I don't have to just do this with Cesaro's experiment,

1151
01:08:00,550 --> 01:08:02,736
它可以用来进行很多种蒙特卡罗实验
it could be lots of Monte Carlo experiments I might do.

1152
01:08:03,360 --> 01:08:07,120
当然 它依赖于某种随机数生成器的存在
Of course, this depends upon the existence of some sort of random number generator.

1153
01:08:07,344 --> 01:08:10,992
随机数生成器通常是像这种的东西
And random number generators generally look something like this.

1154
01:08:13,600 --> 01:08:16,320
这是一个随机数生成器--
There is a random number generator--

1155
01:08:17,424 --> 01:08:25,216
它实际上就是一个过程 具体行为跟计数器有些相似
is in fact a procedure which is going to do something just like the counter.

1156
01:08:25,616 --> 01:08:27,520
它会把X的值更新为
It's going to update an x

1157
01:08:28,336 --> 01:08:31,824
将某个函数应用于X的结果
to the result of applying some function to x,

1158
01:08:32,200 --> 01:08:35,280
而这类古怪的函数
where this function is some screwy kind of function

1159
01:08:35,392 --> 01:08:40,160
你可以在Kunth写的关于编程细节的书中找到
that you might find out in Knuth's books on the details of programming.

1160
01:08:41,568 --> 01:08:45,750
他写的书绝妙而充满了编程细节
He does these wonderful books that are full of the details of programming,

1161
01:08:45,750 --> 01:08:48,528
虽然我记不住随机数生成器该怎样写
because I can't remember how to make a random number generator,

1162
01:08:48,630 --> 01:08:50,624
但我可以在书里找出一个来用
but I can look it up there, and I can find out.

1163
01:08:51,648 --> 01:08:54,016
最后 我返回了X的值
And then, eventually, I return the value of x

1164
01:08:54,080 --> 01:08:57,408
也就是随机数生成器的内部状态变量
which is the state variable internal to the random number generator.

1165
01:08:58,288 --> 01:09:00,752
这个状态变量以某种方式被初始化
That state variable is initialized somehow,

1166
01:09:01,328 --> 01:09:02,240
从而获得了一个值
and has a value.

1167
01:09:03,392 --> 01:09:08,112
这个过程被定义在那个变量被约束的上下文中
And this procedure is defined in the context where that variable is bound

1168
01:09:10,416 --> 01:09:15,264
所以你在这看到的 是一个隐藏的局部状态
So this is a hidden piece of local state that you see here.

1169
01:09:15,872 --> 01:09:20,240
这个过程定义在那个上下文中
And this procedure is defined in that context.

1170
01:09:21,568 --> 01:09:23,664
这样做起来非常容易
Now, that's a very simple thing to do.

1171
01:09:24,880 --> 01:09:25,792
而且结果也非常好
And it's very nice.

1172
01:09:25,990 --> 01:09:27,776
设想 我不想用赋值
Supposing, I didn't want to use assignments.

1173
01:09:29,104 --> 01:09:31,472
假设我想写一个不带赋值的程序
Supposing, I wanted to write this program without assignments.

1174
01:09:32,736 --> 01:09:33,936
我将遇到什么困难？
What problems would I have?

1175
01:09:35,520 --> 01:09:37,408
让我们来看看
Well, let's see.

1176
01:09:37,824 --> 01:09:41,104
我要用一下头顶上的投影仪了
I'd like to use the overhead machine here,

1177
01:09:42,064 --> 01:09:42,704
多谢
thank you.

1178
01:09:43,472 --> 01:09:47,660
首先 我们来整体看一下 这是一个很庞大的东西
First of all, let's look at the whole thing. It's a big story. Right?

1179
01:09:48,016 --> 01:09:49,904
它告诉你有某些东西出了问题
Unfortunately, which tells you there is something wrong.

1180
01:09:50,960 --> 01:09:52,752
毕竟有这么大一堆东西呢
It's at least that big,

1181
01:09:53,424 --> 01:09:54,608
庞大而单一
and it's monolithic.

1182
01:09:56,768 --> 01:10:00,120
你不需要现在去理解或看这里的文本
You don't have to understand or look at the text there right now

1183
01:10:00,120 --> 01:10:01,392
就把它们看做一个整体
to see that it's monolithic.

1184
01:10:01,920 --> 01:10:04,897
它不是Cesaro的实验
It isn't a thing which is Cesaro's experiment.

1185
01:10:04,890 --> 01:10:07,904
它不是从蒙特卡罗过程中抽取出来的
It's not pulled out from the Monte Carlo process.

1186
01:10:09,872 --> 01:10:11,840
它不是分离的 让我们来看看为什么
It's not separated. Let's look why.

1187
01:10:14,224 --> 01:10:15,850
记住 这里的约束是
Remember, the constraint here

1188
01:10:15,850 --> 01:10:17,872
每个过程
is that every procedure

1189
01:10:18,690 --> 01:10:22,208
对于同样的参数 将返回同样的值
return the same value for the same arguments.

1190
01:10:22,976 --> 01:10:24,752
每个过程就是一个函数
Every procedure represents a function.

1191
01:10:26,928 --> 01:10:28,500
那是另一种约束
That's a different kind of constraint.

1192
01:10:28,500 --> 01:10:31,216
因为当我赋值时 我可以改变一些内部状态变量
Because when I have assignments, I can  change some internal state variable.

1193
01:10:31,744 --> 01:10:34,032
所以让我们来看看它是怎么出错的
So let's see how that causes things to go wrong.

1194
01:10:35,040 --> 01:10:36,144
我们从头开始
Well, start at the beginning.

1195
01:10:37,504 --> 01:10:41,920
估算pi的过程看起来是一样的
Ah...The estimate of pi looks sort of the same.

1196
01:10:42,660 --> 01:10:45,888
我取RAMDOM-GCD-TEST应用于N
What I'm doing is I take the square root

1197
01:10:46,352 --> 01:10:50,224
的结果分之6的平方根
of six over the random GCD test applied to n

1198
01:10:50,740 --> 01:10:51,936
就是这个
whereas that's what this is.

1199
01:10:52,960 --> 01:10:55,200
在这里 我们开始看到了一些有趣的东西
But here, we are beginning to see something funny.

1200
01:10:55,200 --> 01:10:57,936
对于以TRAILS为参数的RANDOM-GCD-TEST过程
The random GCD test of a certain number of trials

1201
01:10:58,320 --> 01:10:59,984
就像我们之前做的一样
is just like we had before,

1202
01:11:00,460 --> 01:11:04,666
是一个以剩余次数
an iteration on the number of trials remaining,

1203
01:11:04,660 --> 01:11:06,800
通过次数
the number of trials that have been passed,

1204
01:11:08,272 --> 01:11:09,712
另一个变量X为基准的迭代
and another variable x.

1205
01:11:10,752 --> 01:11:11,760
这个X是什么？
What's that x?

1206
01:11:12,330 --> 01:11:15,200
X是随机数发生器的状态
That x is the state of the random number generator.

1207
01:11:19,008 --> 01:11:21,160
它会在这里被使用
And it is now going to be used here.

1208
01:11:21,160 --> 01:11:23,791
这里的同样的随机更新函数
The same random update function that I have over here

1209
01:11:23,790 --> 01:11:27,152
来自于一个我另外写的随机数发生器
is the one I would have used in a random number generator if I were building it the other way,

1210
01:11:27,712 --> 01:11:29,328
或者从Knuth的书中找一个
the one I get out of Knuth's books.

1211
01:11:31,560 --> 01:11:33,360
X将转化为X1
x is going to get transformed into x1,

1212
01:11:33,376 --> 01:11:34,360
但我需要两个随机数
I need two random numbers.

1213
01:11:34,816 --> 01:11:36,928
X1将被转化为X2
And x1 is going to get transformed into x2,

1214
01:11:37,264 --> 01:11:38,448
我有两个随机数
I have two random numbers.

1215
01:11:39,504 --> 01:11:42,144
然后进行和之前一样的步骤
I then have to do exactly what I did before.

1216
01:11:42,520 --> 01:11:44,192
取X1和X2的最大公约数
I take the GCD of x1 x2.

1217
01:11:44,224 --> 01:11:47,152
如果结果是1 则将X2作为下一个X的值继续循环
If that's one, then I go around the loop with X2 being the next value of x.

1218
01:11:54,784 --> 01:11:55,984
这里所发生的
You see what's happened here

1219
01:11:56,880 --> 01:11:58,704
随机数发生器的状态
is that the state of the random number generator

1220
01:11:58,736 --> 01:12:01,700
不再被限制于其内部
is no longer confined to the insides of the random number generator.

1221
01:12:01,808 --> 01:12:02,736
它已经暴露了出来
It has leaked out.

1222
01:12:03,330 --> 01:12:05,506
它已经被暴露在
It has leaked out into my procedure

1223
01:12:05,500 --> 01:12:10,080
我们的的蒙特卡罗实验的过程中
that does the Monte Carlo experiment.

1224
01:12:10,704 --> 01:12:11,870
但比那更糟糕的是
But what's worse than that,

1225
01:12:11,870 --> 01:12:16,240
同样的 因为它也被包含在我们的Cesaro实验中
is it's also, because it was contained inside my experiment itself, Cesaro,

1226
01:12:16,784 --> 01:12:19,488
它被暴露了两次 因为Cesaro被调用了两次
It leaked out that two. Because Cesaro called twice,

1227
01:12:20,864 --> 01:12:22,470
每次有不同的值
has to have a different value each time,

1228
01:12:22,470 --> 01:12:25,168
如果我要进行一个合理的实验的话
if I going to have a legitimate experimental test.

1229
01:12:26,320 --> 01:12:28,320
所以Cesaro也不能成为函数了
So Cesaro can't be a function either,

1230
01:12:31,040 --> 01:12:35,696
除非我把随机数发生器的种子传给它
unless I pass it the seed of the random number generator that is going to go wandering around.

1231
01:12:36,528 --> 01:12:39,370
所以很不幸 随机数发生器的种子
So unfortunately, the seed of random number generator

1232
01:12:39,370 --> 01:12:42,777
从随机数发生器中暴露到了Cesaro内部
has leaked out into Cesaro, from the random number generator,

1233
01:12:42,880 --> 01:12:45,168
被暴露在蒙特卡罗实验中
that's leaked into the Monte Carlo experiment.

1234
01:12:45,648 --> 01:12:49,120
很不幸 这里的蒙特卡罗实验不再是通用的了
And, unfortunately, my Monte Carlo experiment here is no longer general.

1235
01:12:50,256 --> 01:12:51,808
这里的蒙特卡罗实验
The Monte Carlo experiment here

1236
01:12:52,032 --> 01:12:54,736
知道了我在实验中需要多少个随机数
knows how many random numbers I need to do the experiment.

1237
01:12:58,960 --> 01:12:59,744
这真的很糟糕
That's sort of horrible.

1238
01:13:00,080 --> 01:13:02,544
我失去了将问题分解开来的能力
I lost an ability to decompose a problem into pieces,

1239
01:13:03,440 --> 01:13:09,120
因为我不愿意接受信息的循环
because I wasn't willing to accept the little loop of information,

1240
01:13:09,504 --> 01:13:12,432
反馈的过程
the feedback process,

1241
01:13:12,880 --> 01:13:15,940
这之前都是发生在随机数发生器内部
that happens inside the random number generator before

1242
01:13:15,940 --> 01:13:21,216
也就是赋值给一个限制在随机数生成器内部的状态变量
that was made by having an assignment to a state variable that was confined to the random number generator.

1243
01:13:22,920 --> 01:13:25,488
所以实际上 随机数发生器是一个对象
So the fact that the random number generator is an object,

1244
01:13:25,920 --> 01:13:27,376
它有一个内部状态变量
with an internal state variable,

1245
01:13:28,064 --> 01:13:29,360
它不受任何东西影响
it's affected by nothing,

1246
01:13:29,376 --> 01:13:31,600
但是它会给你某些东西 把它的力量赐予你
but it'll give you something, and it will apply it's force to you,

1247
01:13:32,800 --> 01:13:34,288
那是我们现在缺少的
that was what we're missing now.

1248
01:13:38,000 --> 01:13:40,730
好 我认为我已经知道了
OK, well I think we've seen

1249
01:13:40,730 --> 01:13:42,304
引入赋值的充分理由
enough reason for doing this,

1250
01:13:42,832 --> 01:13:45,248
并且一些看起来很圆满
and it all sort of looks very wonderful.

1251
01:13:45,380 --> 01:13:50,704
如果赋值是一个好东西
Wouldn't it be nice if assignment was a good thing

1252
01:13:51,740 --> 01:13:53,040
并且赋值是值得的 这不是很好吗？
and maybe it's worth it,

1253
01:13:53,280 --> 01:13:54,144
我不是很确定
but I'm not sure.

1254
01:13:55,344 --> 01:13:57,040
Mr. Gilbert和Sullivan说过
As Mr. Gilbert and Sullivan said,

1255
01:13:57,040 --> 01:13:58,515
事物往往不像表面看到的那样
things are seldom what they seem,

1256
01:13:58,510 --> 01:14:00,352
脱脂牛奶也能装成奶油
skim milk masquerades as cream.

1257
01:14:01,872 --> 01:14:03,904
谁有什么问题吗？
Are there any questions?

1258
01:14:16,976 --> 01:14:18,304
在座的有哲学家吗？
Are there any philosophers here?

1259
01:14:20,064 --> 01:14:22,032
有人想要讨论有关“对象”的问题吗？
Anybody want to argue about objects?

1260
01:14:24,320 --> 01:14:25,504
你们已经一头雾水了是吧？
You're just floored, right?

1261
01:14:29,720 --> 01:14:30,720
你们还没有完成家庭作业呢
And you haven't done your homework yet.

1262
01:14:30,736 --> 01:14:32,000
你们需要提一个好问题
You haven't come up with a good question.

1263
01:14:36,352 --> 01:14:37,440
好了
Oh, well.

1264
01:14:39,970 --> 01:14:42,336
感谢你们 我们下课吧
Sure, thank you. Let's take the long break now.

1265
01:14:47,900 --> 01:14:56,416
MIT OpenCourseWare
http://ocw.mit.edu

1266
01:14:56,448 --> 01:15:05,696
本项目主页
https://github.com/DeathKing/Learning-SICP

