1
00:00:00,030 --> 00:00:02,688
Learning-SICP学习小组
倾情制作

2
00:00:02,752 --> 00:00:05,968
翻译&&时间轴：邓雄飞、张大伟
压制&&特效：邓雄飞（Dysprosium）
校对：邓雄飞（Dysprosium）

3
00:00:06,000 --> 00:00:08,752
特别感谢：裘宗燕教授

4
00:00:08,848 --> 00:00:11,408
计算机程序的构造和解释

5
00:00:11,420 --> 00:00:13,248
元循环求值器 I
Metacircular Evaluator

6
00:00:15,792 --> 00:00:17,328
教授：今天我们将学习一些
PROFESSOR: Well today we're going to learn about something

7
00:00:17,520 --> 00:00:18,410
非同一般的东西
quite amazing.

8
00:00:19,200 --> 00:00:21,888
我们将对计算机程序
We're going to understand what we mean by a program

9
00:00:22,592 --> 00:00:25,216
有更深层次的理解
a little bit more profoundly than we have up till now.

10
00:00:26,800 --> 00:00:29,120
目前为止 我们一直把程序看作
Up till now, we've been thinking

11
00:00:29,264 --> 00:00:32,096
对机器的描述
programs as describing machines.

12
00:00:32,720 --> 00:00:37,216
举个例子 在这个幻灯片上
So for example, looking at this still store

13
00:00:37,936 --> 00:00:41,776
我们可以看到一个计算阶乘的程序
we see here is a program for factorial.

14
00:00:42,800 --> 00:00:47,312
当然 你可以认为这些字符串描述了
And what it is, is a character string description, if you will,

15
00:00:47,664 --> 00:00:51,984
这个线路图所表示的无穷机器
of the wiring diagram of a potentially infinite machine.

16
00:00:52,496 --> 00:00:54,800
我们可以稍稍地看下 它描述的是什么
And we can look at that a little bit and just see the idea.

17
00:00:55,130 --> 00:00:58,208
这种紧凑的记法 描述的是：
That this is a sort of compact notation which says,

18
00:00:58,544 --> 00:01:00,170
如果N是0 结果就是1
if n is 0, the result is one.

19
00:01:00,170 --> 00:01:02,000
N是从这里进入机器的
Well here comes n coming into this machine,

20
00:01:02,336 --> 00:01:03,520
如果它是0的话
and if it's 0,

21
00:01:03,744 --> 00:01:05,200
那么我就控制这个开关
then I control this switch

22
00:01:05,472 --> 00:01:08,208
把它掰到输出为1的那一端
in such a way that the switch allows the output to be one.

23
00:01:09,340 --> 00:01:10,080
否则的话
Otherwise,

24
00:01:10,384 --> 00:01:12,832
就是(* N (FACT (- N 1)))
it's n times factorial of n minus one.

25
00:01:12,970 --> 00:01:15,136
我先计算(FACT (- N 1))
Well, I'm computing factorial of n minus one

26
00:01:15,290 --> 00:01:16,688
再把结果乘以N
and multiplying that by n,

27
00:01:16,848 --> 00:01:18,912
这样如果N不为0的话
in the case that it's not 0,

28
00:01:18,912 --> 00:01:20,608
这个开关就会输出这里的结果
this switch makes the output come from there.

29
00:01:21,900 --> 00:01:22,320
当然了
Of course,

30
00:01:22,368 --> 00:01:25,130
这个机器可能有无穷多个部件
this is a machine with a potentially infinite number of parts,

31
00:01:25,488 --> 00:01:28,128
因为FACT内部又调用了FACT
because factorial occurs within factorial,

32
00:01:28,432 --> 00:01:30,176
因此我们不知道调用栈有多深
so we don't know how deep it has to be.

33
00:01:31,070 --> 00:01:33,552
但到目前为止
But that's basically what our notation

34
00:01:34,224 --> 00:01:37,696
代码对我们来说就是这样的东西了
for programs really means to us at this point.

35
00:01:38,310 --> 00:01:40,592
你可以认为代码是用字符串来描述
It's a character string description, if you will,

36
00:01:41,280 --> 00:01:44,160
某种用其它方式描画的线路图
of a wiring diagram that could also be drawn some other way.

37
00:01:44,900 --> 00:01:46,608
事实上 很多人都向我提议
And, in fact, many people have proposed to me,

38
00:01:46,848 --> 00:01:49,040
说程序设计语言应该像这个一样 是图像化的
programming languages look graphical like this.

39
00:01:49,490 --> 00:01:51,808
不过我不认为用图形表示会有很多优势
I'm not sure I believe there are many advantages.

40
00:01:52,000 --> 00:01:53,792
当然 最主要的劣势就是
The major disadvantage, of course,

41
00:01:53,808 --> 00:01:55,632
它需要占用很大的平面空间
is that it takes up more space on a page,

42
00:01:55,968 --> 00:01:59,952
所以展示和修改起来就非常麻烦
and, therefore, it's harder to pack into a listing or to edit very well.

43
00:02:01,344 --> 00:02:02,160
但是不管怎样
But in any case,

44
00:02:03,580 --> 00:02:05,152
在计算的世界中
there's something very remarkable

45
00:02:05,184 --> 00:02:07,050
还有一个非常重要的东西
that can happen in the computation world

46
00:02:07,648 --> 00:02:10,640
也就是所谓的“通用机器”
which is that you can have something called a universal machine.

47
00:02:10,730 --> 00:02:15,248
我们再来看第二张幻灯片
If we look at the second slide,

48
00:02:16,048 --> 00:02:17,184
我们看到的就是
what we see is

49
00:02:18,144 --> 00:02:19,888
名为EVAL的特殊机器
a special machine called eval.

50
00:02:21,260 --> 00:02:22,864
这个叫做EVAL的机器
There is a machine called eval,

51
00:02:22,880 --> 00:02:24,240
也就是我今天要讲解的
and I'm going to show it to you today.

52
00:02:25,824 --> 00:02:26,672
它非常简单
It's very simple.

53
00:02:27,780 --> 00:02:30,800
最了不起的是 它简单得可以写在黑板上
What is remarkable is that it will fit on the blackboard.

54
00:02:33,350 --> 00:02:35,792
然而 EVAL这个机器
However, eval is a machine

55
00:02:36,000 --> 00:02:39,840
是以其它机器的描述作为输入的
which takes as input a description of another machine.

56
00:02:40,450 --> 00:02:42,128
它可以接收一个
It could take the wiring diagram

57
00:02:42,400 --> 00:02:45,584
阶乘机器的线路图作为输入
of a factorial machine as input.

58
00:02:46,490 --> 00:02:47,664
这样一来
Having done so,

59
00:02:48,496 --> 00:02:52,570
它就可以模拟那台阶乘机器
it becomes a simulator for the factorial machine

60
00:02:53,136 --> 00:02:53,792
这样的话
such that,

61
00:02:54,160 --> 00:02:56,368
如果输入6 就会得到720
if you put a six in, out comes a 720.

62
00:02:58,910 --> 00:03:01,680
这是一个非常了不起的机器
That's a very remarkable sort of machine.

63
00:03:02,130 --> 00:03:03,584
而最让人惊奇的是
And the most amazing part of it

64
00:03:03,776 --> 00:03:05,136
它竟然可以写在一个黑板内
it is that it fits on a blackboard.

65
00:03:05,590 --> 00:03:06,656
与之相反的是
By contrast,

66
00:03:07,320 --> 00:03:10,448
我们可以想象一下模拟电子世界中的
one could imagine in the analog electronics world

67
00:03:11,552 --> 00:03:12,864
一台非常不同的机器
a very different machine.

68
00:03:14,576 --> 00:03:16,336
这台机器呢
a machine where, a machine

69
00:03:16,528 --> 00:03:18,816
某种意义上 同样也是“通用机器”
which also was, in some sense, universal,

70
00:03:19,260 --> 00:03:23,120
只要你输入一个电路图
where you gave a circuit diagram as one of the inputs,

71
00:03:23,824 --> 00:03:25,744
比如这个小型的低通滤波器
for example, of this little low-pass filter,

72
00:03:26,016 --> 00:03:27,488
单极低通滤波器之类的
one-pole low-pass filter.

73
00:03:28,050 --> 00:03:29,536
你可以想像
And you can imagine that

74
00:03:29,710 --> 00:03:33,152
如果我们扫描这个元件得到扫描线
you could, for example, scan this out-- the scan lines

75
00:03:34,432 --> 00:03:37,130
得到的信号描述的就是
Right? are the signal that's describing

76
00:03:37,392 --> 00:03:40,400
这个机器所模拟的
what this machine is to simulate--

77
00:03:40,784 --> 00:03:43,392
这个模拟机器EVAL是由电路构成
then the analog of eval which is made out of electrical circuits,

78
00:03:43,680 --> 00:03:45,152
它可以把自己配置成一个滤波器
which configure itself into a filter

79
00:03:45,184 --> 00:03:48,040
响应由电路图指定的频率
has the frequency response specified by the circuit diagram.

80
00:03:49,890 --> 00:03:51,488
这种机器很难制造出来
That's a very hard machine to make,

81
00:03:51,616 --> 00:03:54,064
当然 更不可能用一个黑板就把它说清楚
and, surely, there's no chance that I could put it on a blackboard.

82
00:03:55,670 --> 00:03:57,584
所以今天我们将学习一些神奇的东西
So we're going to see an amazing thing today.

83
00:03:58,430 --> 00:04:00,816
我们将在黑板上见证
We're going to see, on the blackboard,

84
00:04:01,168 --> 00:04:02,496
通用机器
the universal machine.

85
00:04:02,790 --> 00:04:04,416
跟其它程序比起来
And we'll see that among other things,

86
00:04:04,528 --> 00:04:05,808
它真是非常简单
it's extremely simple.

87
00:04:06,780 --> 00:04:08,752
现在 我们已经非常接近
Now, we're getting very close

88
00:04:09,088 --> 00:04:10,976
计算机中真正的精灵了
the real spirit in the computer at this point.

89
00:04:11,280 --> 00:04:14,624
所以为了保持足够的尊重
So I have to show a certain amount of reverence and respect,

90
00:04:15,184 --> 00:04:17,328
我特地穿上外套
so I'm going to wear a suit jacket for the only time

91
00:04:17,520 --> 00:04:19,296
你们应该从没见我穿过
that you'll ever see me wear a suit jacket here.

92
00:04:20,470 --> 00:04:22,736
在这个盛重的场合
And I think I'm also going to

93
00:04:23,552 --> 00:04:26,704
我还得戴上一顶合适的帽子
put on an appropriate hat for the occasion.

94
00:04:28,780 --> 00:04:31,440
开讲前再给大家提个醒
Now, this is a lecturer which I have to warn you--

95
00:04:34,140 --> 00:04:36,912
那些40岁以下
let's see, normally, people under 40

96
00:04:37,168 --> 00:04:38,490
以及没有孩子的人
and who don't have several children

97
00:04:38,672 --> 00:04:40,496
你们可要小心了
are advised to be careful.

98
00:04:40,490 --> 00:04:41,968
如果真的受不了 可以选择离开
If they're really worried, they should leave.

99
00:04:43,340 --> 00:04:45,568
因为一会儿要发生一些
Because there's a certain amount of

100
00:04:45,728 --> 00:04:47,130
非常神秘的事情
mysticism that will appear here

101
00:04:47,744 --> 00:04:51,056
可能使你的大脑异常混乱
which may be disturbing and cause trouble in your minds.

102
00:04:51,820 --> 00:04:54,288
好了 无论如何
Well in any case, let's see,

103
00:04:55,712 --> 00:05:01,104
我要带着你们写一个Lisp求值器
I wish to write for you the evaluator for Lisp.

104
00:05:02,510 --> 00:05:04,288
求值器并不复杂
Now the evaluator isn't very complicated.

105
00:05:05,020 --> 00:05:07,632
很像我们以前见到过的程序
It's very much like all the programs we've seen already.

106
00:05:08,240 --> 00:05:09,488
这也是它令人吃惊的地方
That's the amazing part of it.

107
00:05:10,860 --> 00:05:13,104
现在我开始写这个程序
It's going to be-- and I'm going to write it right here--

108
00:05:15,280 --> 00:05:16,620
我把这个程序叫做EVAL
it's a program called eval.

109
00:05:22,900 --> 00:05:26,240
这个过程接收两个参数
And it's a procedure of two arguments

110
00:05:26,280 --> 00:05:29,440
表达式EXP和环境ENV
expression and an environment.

111
00:05:31,860 --> 00:05:33,792
跟所有实用过程一样
And like every interesting procedure,

112
00:05:34,016 --> 00:05:35,136
它是个“按情况分析”语句
it's a case analysis.

113
00:05:40,460 --> 00:05:41,872
但是在我开始之前
But before I start on this,

114
00:05:42,528 --> 00:05:43,904
我还想你们注意一下
I want to tell you some things.

115
00:05:44,448 --> 00:05:46,064
我将要在黑板上写的程序
The program we're going to write on the blackboard

116
00:05:46,560 --> 00:05:50,240
非常丑陋、混乱、令人作呕
is ugly, dirty, disgusting,

117
00:05:50,944 --> 00:05:53,168
并不是一种专业的写法
not the way I would write this is a professional.

118
00:05:54,320 --> 00:05:56,576
它是用具体语法写就的
It is written with concrete syntax,

119
00:05:57,248 --> 00:05:58,832
也就是说用了很多CAR、CDR
meaning you've got really to use lots of CARs and CDRs

120
00:05:58,848 --> 00:06:00,624
我之前告诉过你们这样写并不好
which is exactly what I told you not to do.

121
00:06:02,944 --> 00:06:05,616
在这里是故意这样来写的
That's on purpose in this case,

122
00:06:06,110 --> 00:06:09,024
因为我想让它尽量精简
because I want it to be small, compact,

123
00:06:09,344 --> 00:06:10,400
能塞在黑板内
fit on the blackboard

124
00:06:10,432 --> 00:06:11,856
你们就可以看到整个代码
so you can get the whole thing.

125
00:06:12,420 --> 00:06:14,800
我就不像平时那样实用长变量名了
So I don't want to use long names like I normally use.

126
00:06:15,600 --> 00:06:17,296
就用CAR、CDR 因为它们短小
I want to use CAR-CDR because it's short.

127
00:06:18,060 --> 00:06:20,784
这算是一种取舍
Okay, I wanna, it's a whole, that's a trade-off.

128
00:06:20,896 --> 00:06:22,816
我不希望你们这样来写程序
I don't want you writing programs like this.

129
00:06:23,570 --> 00:06:25,088
这里单纯地想达到一种简洁的效果
This is purely for an effect.

130
00:06:25,850 --> 00:06:27,616
因此你们读起来可能有些费力
Now, you're going to have to work a little harder to read it,

131
00:06:27,776 --> 00:06:30,192
我尽量写得清楚一些
but I'm going to try to make it clear as I'm writing it.

132
00:06:31,270 --> 00:06:34,400
这个解释器已经比较完整了
I'm also-- this is a pretty much complete interpreter,

133
00:06:34,512 --> 00:06:36,240
但是还是缺少一些功能
but there's going to be room for putting in more things--

134
00:06:36,256 --> 00:06:38,608
我就不写定义和赋值的部分了
I'm going to leave out definition and assignment,

135
00:06:39,104 --> 00:06:42,416
因为它们都不是最本质的
just because they are not essential,

136
00:06:42,880 --> 00:06:46,464
稍后我就会解释 这是数学上的原因
and a, for a mathematical reason I'll show you later

137
00:06:46,928 --> 00:06:49,968
当然啦 黑板也没有那么大
and also they take up more space.

138
00:06:51,888 --> 00:06:53,648
但是 我们怎么做呢？
But, in any case, what do we have to do?

139
00:06:53,952 --> 00:06:55,664
我们需要一个分派
We have to do a dispatch

140
00:06:56,096 --> 00:06:57,904
它根据表达式的类型
which breaks the types of expressions up

141
00:06:58,288 --> 00:07:00,384
把它们划分为几类
into particular classes.

142
00:07:01,728 --> 00:07:03,264
这就是现在要做的
Okay? So that's what we're going to have here.

143
00:07:03,824 --> 00:07:05,150
我们都有哪些表达式？
Well, what expressions are there?

144
00:07:05,150 --> 00:07:06,368
我们先来看几种表达式
Let's look at the kinds of expressions.

145
00:07:06,810 --> 00:07:09,600
比如说 数字“3”就是一个表达式
We can have things like the numeral three.

146
00:07:10,420 --> 00:07:11,584
我想让它代表什么呢？
What do I want that to do?

147
00:07:12,720 --> 00:07:14,752
我有很多选择 但是就现在而言
I can make choices, but I think right now,

148
00:07:15,056 --> 00:07:16,208
我就想让它表示数字3
I want it to be a three.

149
00:07:17,050 --> 00:07:17,888
这就是我要的
That's what I want.

150
00:07:18,720 --> 00:07:19,696
这个足够简单
So that's easy enough.

151
00:07:20,032 --> 00:07:22,912
那就意味着 如果表达式是数字
That means I want, if the thing is a number,

152
00:07:27,290 --> 00:07:31,680
表达式本身就应该是求值结果
that I want the expression itself as the answer.

153
00:07:35,420 --> 00:07:36,768
另外一种情况是
Now the next possibility

154
00:07:36,896 --> 00:07:38,864
表达式还可能是符号
is things that we represent as symbols.

155
00:07:39,390 --> 00:07:46,752
比如EXP、ENV、EVAL、NUMBER、X之类
Examples of symbols are things like x, n, eval, number, x.

156
00:07:48,016 --> 00:07:49,184
它们意味着什么？
What do I mean them to be?

157
00:07:50,160 --> 00:07:51,632
它们是一类代表其它事物的事物
Those are things that stand for other things.

158
00:07:51,632 --> 00:07:53,232
也就是我们语言中所谓的变量
Those are the variables of our language.

159
00:07:54,770 --> 00:07:56,880
因此我想要能够 比如说
And so I want to be able to say, for example,

160
00:07:57,056 --> 00:08:01,040
对X求值 可能会得到3
that x, for example, transforms to it's value which might be three.

161
00:08:02,640 --> 00:08:05,760
又可能是CAR
Or I might ask something like car.

162
00:08:07,760 --> 00:08:09,408
我希望它的值是
I want to have as its value--

163
00:08:09,632 --> 00:08:11,344
某种类似于过程的东西
be something like some procedure,

164
00:08:16,512 --> 00:08:18,432
我不需要知道它内部是什么
which I don't know what is inside there,

165
00:08:18,640 --> 00:08:21,152
可能是一些机器码 或者类似的东西
perhaps a machine language code or something like that.

166
00:08:22,848 --> 00:08:24,272
到这是还是相对简单的
Ok? So, well, that's easy enough.

167
00:08:24,430 --> 00:08:26,896
我想把这部分交给其他人来写
I'm going to push that off on someone else.

168
00:08:27,808 --> 00:08:28,896
如果我们有一个符号
If something is a symbol,

169
00:08:30,800 --> 00:08:32,480
假如表达式是符号
if the expression is a symbol,

170
00:08:33,424 --> 00:08:34,880
那么我求值它的结果就应该是
then I want the answer to be the result,

171
00:08:34,912 --> 00:08:40,240
在环境ENV中查找该表达式的值
looking up the expression in the environment.

172
00:08:46,480 --> 00:08:48,992
环境是一个字典
Now the environment is a dictionary

173
00:08:49,968 --> 00:08:54,060
它把符号映射成一个值
which maps the symbol names to their values.

174
00:08:54,288 --> 00:08:55,168
就这么简单
And that's all it is.

175
00:08:56,280 --> 00:08:57,200
怎么完成的呢？
How it's done?

176
00:08:57,530 --> 00:08:58,528
稍后我们再谈这个
Well, we'll see that later.

177
00:08:59,680 --> 00:09:00,576
其实并不难
It's very easy.

178
00:09:01,670 --> 00:09:04,288
编写类似于表的数据结构非常容易
It's easy to make data structures that are tables of various sorts.

179
00:09:04,840 --> 00:09:05,744
但它只是一个表
But it's only a table,

180
00:09:05,776 --> 00:09:07,560
而这是存取某个表的过程
and this is the access routine for some table.

181
00:09:09,550 --> 00:09:10,816
好的 接下来
Ok? Well, the next thing,

182
00:09:11,312 --> 00:09:12,560
另一类表达式
another kind of expression--

183
00:09:12,672 --> 00:09:15,568
表达式可能是一些不是数字的常量
you have things that are described constants that are not numbers,

184
00:09:16,064 --> 00:09:17,430
比如 'FOO
like 'foo.

185
00:09:20,170 --> 00:09:21,296
为了方便起见
Well, for my convenience,

186
00:09:21,312 --> 00:09:23,360
我想在语法上
I want to syntactically transform that

187
00:09:24,736 --> 00:09:26,800
把它转换成表结构
into a list structure which is,

188
00:09:26,848 --> 00:09:31,520
比如说是(QUOTE FOO)
which is, quote foo.

189
00:09:33,728 --> 00:09:37,180
一个被引用起来的对象 无论它是什么
Or it's -- A quoted object, whatever it is,

190
00:09:38,352 --> 00:09:40,832
都实际上是一个缩写
is going to be actually an abbreviation,

191
00:09:41,040 --> 00:09:42,592
这一部分并不由求值器负责
which is not part of the evaluator

192
00:09:43,216 --> 00:09:44,464
这是在其它地方完成的
but happens somewhere else,

193
00:09:44,752 --> 00:09:47,792
左边的符号就是右边表达式的缩略形式
an abbreviation for an expression that looks like this.

194
00:09:48,780 --> 00:09:50,480
这样 我就可以
This way, I can test for

195
00:09:50,576 --> 00:09:53,120
依据表达式的CAR部分
the type of the expression as being a quotation

196
00:09:53,312 --> 00:09:55,952
来判断它的类型了
by examining the car of the expression.

197
00:09:58,460 --> 00:10:01,088
因此这一部分也不会出现在求值器中
So I'm not going to worry about that in the evaluator.

198
00:10:01,650 --> 00:10:02,688
这在更早时候
It's happening somewhere earlier

199
00:10:02,700 --> 00:10:03,968
比如源代码读取阶段完成
in the reader or something.

200
00:10:05,540 --> 00:10:15,040
如果是引用表达式
If the expression of the expression is quote,

201
00:10:18,272 --> 00:10:19,104
那么求值的结果就是
then what I want,

202
00:10:19,630 --> 00:10:25,136
我想让(QUOTE FOO)求值为自身FOO
I want quote foo to itself evaluate to foo.

203
00:10:25,140 --> 00:10:25,952
一个常量
It's a constant.

204
00:10:27,530 --> 00:10:28,928
这条代码是说
This is just a way of saying

205
00:10:29,088 --> 00:10:30,736
这类表达式求值为它自己
that this evaluates to itself.

206
00:10:31,792 --> 00:10:33,660
怎么才能把它取出来呢？
Ok? So thats the. What is that?

207
00:10:33,660 --> 00:10:36,368
这是列表第二个元素的第一个部分
That's the first of the second of the list.

208
00:10:36,592 --> 00:10:37,584
也就是表的第二个元素
That's the second of the list.

209
00:10:38,496 --> 00:10:40,320
也就是CADR
The second element of the list is it's CADR.

210
00:10:41,280 --> 00:10:42,384
所以这里我就写CADR
So I'm just going to write here, CADR.

211
00:10:51,088 --> 00:10:52,352
表达式还可能是什么类型呢？
OK? What else do we have here?

212
00:10:52,510 --> 00:10:53,808
还有LAMBDA表达式
We have lambda expressions,

213
00:10:55,008 --> 00:11:03,296
比如 (LAMBDA (X) (+ X Y))
for example, lambda of x plus x y.

214
00:11:04,160 --> 00:11:06,336
我还得找到某种表示方法
Well, I going have to have some representation for the procedure

215
00:11:06,336 --> 00:11:07,856
LAMBDA表达式求值的结果
which is the value of an expression,

216
00:11:08,112 --> 00:11:09,088
也就是如何表示过程
of a lambda expression.

217
00:11:09,600 --> 00:11:12,624
过程并不就是表达式(LAMBDA (x))
The procedure here is not the expression lambda x.

218
00:11:13,136 --> 00:11:15,568
表达式只是过程的代码描述
That's the description of it, the textual description.

219
00:11:16,416 --> 00:11:18,330
如果在词法作用域的语言中实现过程
However, what what I going to expect to see here

220
00:11:18,560 --> 00:11:21,200
那么我希望在表示过程的时候
is something which contains an environment as one of its parts

221
00:11:23,232 --> 00:11:25,360
能够把当前的求值环境包括进来
if I'm implementing a lexical language.

222
00:11:25,840 --> 00:11:29,072
所以这里我还需要
And so what I'd like to see

223
00:11:29,200 --> 00:11:30,672
一些类型标志
is some type flags.

224
00:11:30,704 --> 00:11:33,904
这样后面我就可以用它们来区分过程
I'm going to have to be able to distinguish procedures later,

225
00:11:34,304 --> 00:11:36,592
看哪些是由LAMBDA表达式生成的
procedures which were produced by lambdas,

226
00:11:36,816 --> 00:11:38,032
哪些是基本过程
from ones that may be primitive.

227
00:11:39,060 --> 00:11:41,968
所以这里是个类型标志
And so I'm going to have some flag,

228
00:11:41,984 --> 00:11:43,568
出于历史原因
which I'll just arbitrarily call closure,

229
00:11:43,568 --> 00:11:45,104
我用CLOSURE作为类型标志
just for historical reasons.

230
00:11:47,680 --> 00:11:49,600
现在来看看 哪部分比较重要
Now, to say what parts of this are important.

231
00:11:49,920 --> 00:11:51,120
我需要知道
I'm going to need to know

232
00:11:51,248 --> 00:11:52,928
绑定变量表和过程的体
the bound variable list and the body.

233
00:11:54,220 --> 00:11:55,408
这是它的CDR部分
Well, that's the CDR of this,

234
00:11:56,096 --> 00:12:01,856
这里就是((X) (+ X Y))
so it's going to be x and plus x y and some environment.

235
00:12:03,040 --> 00:12:03,872
以及某个环境<ENV>
and some environment.

236
00:12:08,170 --> 00:12:12,208
用户不应该看到这个东西
Now this is not something that users should ever see,

237
00:12:13,536 --> 00:12:16,192
这只是过程对象的
this is purely a representation, internally,

238
00:12:16,768 --> 00:12:18,304
一种内部表示
for a procedure object.

239
00:12:18,520 --> 00:12:20,528
它包括绑定变量表
It contains a bound variable list,

240
00:12:20,704 --> 00:12:22,624
过程的体和某个环境
a body, and an environment,

241
00:12:23,536 --> 00:12:25,808
以及一个类型标签 表示这是一个过程
and some type tag saying, I am a procedure.

242
00:12:26,340 --> 00:12:27,376
接下来写代码
I'm going to make one now.

243
00:12:28,080 --> 00:12:38,720
如果表达式的CAR部分是'LAMBDA
So if the CAR of the expression is quote lambda,

244
00:12:43,472 --> 00:12:44,816
这里 我就要
then what I'm going to put here

245
00:12:45,648 --> 00:12:51,840
创建一个表 表头是'CLOSURE
is-- I'm going to make a list of closure,

246
00:12:55,150 --> 00:13:00,736
接着是 过程代码的CDR部分
the CDR of the procedure description

247
00:13:01,568 --> 00:13:02,976
也就是除开LAMBDA的其它部分
was everything except the lambda,

248
00:13:07,744 --> 00:13:08,864
以及当前的环境
and the current environment.

249
00:13:10,250 --> 00:13:15,328
这样就实现了环境模型中的那些规则
This implements the rule for environments in the environment model.

250
00:13:15,456 --> 00:13:18,528
这是从LAMBDA表达式中构建过程所必须遵守的
It has to do with construction of procedures from lambda expressions.

251
00:13:19,408 --> 00:13:20,976
那个求值器在遇到
The environment that was around

252
00:13:21,488 --> 00:13:24,320
LAMBDA表达式时的环境
at the time the evaluator encountered the lambda expression

253
00:13:25,040 --> 00:13:28,464
在过程运行的时候
is the environment where the lambda expression gets

254
00:13:28,688 --> 00:13:31,776
会去这个环境中查找自由变量的值
where the procedure resulting interprets it's free variables.

255
00:13:34,720 --> 00:13:35,824
所以需要把它囊括进来
So that's part of that.

256
00:13:35,920 --> 00:13:37,552
因此我们必须把求值时的环境
And so we have to capture that environment

257
00:13:37,568 --> 00:13:38,860
作为过程对象的一部分
as part of the procedure object.

258
00:13:39,210 --> 00:13:40,624
之后再来看它的作用
And we'll see how that gets used later.

259
00:13:42,032 --> 00:13:43,776
我们也有COND表达式
There are also conditional expressions

260
00:13:44,592 --> 00:13:52,816
像是(COND (P1 E1) (P2 E2) ...)这样的
of things like COND of say, p one, e one, p two, e two.

261
00:13:54,400 --> 00:13:56,096
P1是谓词
Where this is a predicate,

262
00:13:56,352 --> 00:13:58,432
谓词总是返回TRUE或者FALSE
a predicate is a thing that is either true or false,

263
00:13:58,992 --> 00:14:01,760
如果谓词P1为真时 表达式E1才被求值
and the expression to be evaluated if the predicate is true.

264
00:14:03,440 --> 00:14:06,080
当然 你也可以列这么一组子句
A set of clauses, if you will, that's the name for such a thing.

265
00:14:06,790 --> 00:14:09,360
我会把它封装在另一个过程中
So I'm going put that somewhere else.

266
00:14:09,360 --> 00:14:11,568
我们稍后在那个过程中进行处理
We're going to worry about that in another piece of code.

267
00:14:12,420 --> 00:14:21,280
如果表达式的CAR部分是'COND的话
So EQ--  if the CAR of the expression is COND,

268
00:14:24,000 --> 00:14:26,848
那么我就用EVCOND来求值这个表达式
then I'm going to do nothing more than evaluate the COND,

269
00:14:30,208 --> 00:14:31,424
求值表达式的CDR部分
the CDR of the expression.

270
00:14:34,400 --> 00:14:38,496
记得带上环境
That's all the clauses in the environment that I'm given.

271
00:14:41,430 --> 00:14:42,608
好的 还有一种情况
Well, there's one more case,

272
00:14:44,096 --> 00:14:48,224
任意的像(+ X 3)这样的表达式
arbitrary thing like the sum of x and three,

273
00:14:50,624 --> 00:14:53,952
这是把运算符应用在运算对象上
where this is an operator applied to operands,

274
00:14:55,136 --> 00:14:56,590
这并没有什么特殊的
and there's nothing special about it.

275
00:14:56,590 --> 00:14:59,632
就是说 它不属于这里的特殊形式
It's not one of the special cases, the special forms.

276
00:14:59,850 --> 00:15:01,424
上面写的这些都是特殊形式
These are the special forms.

277
00:15:09,650 --> 00:15:12,128
再说明一下 如果我要把这个程序写得专业一点
And if I were writing here a professional program, again,

278
00:15:12,368 --> 00:15:14,176
我会把它设计成数据导向的
I would somehow make this data directed.

279
00:15:14,480 --> 00:15:16,528
那样的话 这里就不会是一系列的条件判断
So there wouldn't be a sequence of conditionals here,

280
00:15:16,656 --> 00:15:18,208
而是根据一些比特位来做分派
there'd be a dispatch on some bits

281
00:15:19,424 --> 00:15:22,256
这样来设计会更加专业一些
if I were trying to do this in a more professional way.

282
00:15:22,360 --> 00:15:24,144
并且 我不用大量修改程序
So that, in fact, I can add to the thing

283
00:15:24,688 --> 00:15:26,384
就可以添加规则
without changing my program much.

284
00:15:26,710 --> 00:15:28,464
这样来做可能运行得更快
So, for example, they would run fast,

285
00:15:29,040 --> 00:15:30,432
但这里我并不打算这么做
but I'm not worried about that.

286
00:15:31,280 --> 00:15:33,984
现在的目的是把握EVAL过程的整体
Here we're trying to look at this in its entirety.

287
00:15:35,072 --> 00:15:35,808
那么 最后一种情况
So it's else.

288
00:15:37,696 --> 00:15:38,560
要怎么做呢？
Well, what do we do?

289
00:15:38,560 --> 00:15:41,232
在这种情况下 我需要进行加法运算
In this case, I have to somehow do an addition.

290
00:15:44,350 --> 00:15:46,160
那么我就得搞清楚 '+到底是什么
Well, I could find out what the plus is.

291
00:15:46,848 --> 00:15:49,296
我还得知道X和3又代表什么
I have to find out what the x and the three are.

292
00:15:50,550 --> 00:15:53,968
然后再把'+的所代表的东西
And then I have to apply the result of finding what the plus is

293
00:15:54,432 --> 00:15:57,008
应用于'X与3所代表的东西上
to the result of finding out what the x and the three are.

294
00:15:58,112 --> 00:15:59,392
具体来写一下
We'll have a name for that.

295
00:15:59,872 --> 00:16:09,550
我要把表达式CAR部分的求值结果
So I'm going to apply the result of evaluating the CAR

296
00:16:11,200 --> 00:16:12,140
应用在
of the expression--

297
00:16:13,216 --> 00:16:15,504
表达式的CAR部分就是运算符
the car of the expression is the operator--

298
00:16:17,200 --> 00:16:18,512
要在给定的环境中进行
in the environment given.

299
00:16:20,512 --> 00:16:22,896
对运算符求值会得到一个过程
So evaluating the operator gets me the procedure.

300
00:16:24,050 --> 00:16:26,784
现在 我要求值所有运算对象来取得参数
Now I have to evaluate all the operands to get the arguments.

301
00:16:27,290 --> 00:16:28,224
我将调用EVLIST
I'll call that EVLIST,

302
00:16:31,264 --> 00:16:35,536
来求值表达式的CDR部分 也就是运算对象
the CDR of the operands, of the expression,

303
00:16:36,768 --> 00:16:39,008
当然是在相应的环境中
with respect to the environment.

304
00:16:41,940 --> 00:16:43,136
我们待会儿再定义EVLIST
EVLIST will come up later--

305
00:16:43,264 --> 00:16:48,070
（闭合括号中）
EVLIST, apply, COND pair, COND, lambda, define.

306
00:16:50,900 --> 00:16:52,336
你现在看到的
So that what you are seeing here

307
00:16:52,670 --> 00:16:56,112
基本上就是一个完整的求值器
is pretty much all there is in the evaluator itself.

308
00:16:56,496 --> 00:17:01,000
它根据表达式的类型分情况处理
It's the case dispatch on the type of the expression

309
00:17:01,240 --> 00:17:02,112
默认的情况是
with the default

310
00:17:04,992 --> 00:17:07,950
表达式应用或者说是组合式
being a general application or a combination.

311
00:17:17,520 --> 00:17:19,520
不过还有好些过程 我们没有定义
Now there is lots of things we haven't defined yet.

312
00:17:20,080 --> 00:17:21,600
接下来就看这些未定义的部分
Let's just look at them and see what they are.

313
00:17:21,780 --> 00:17:24,128
我们还要定义EVCOND
We're going to have to do this later, evcond.

314
00:17:25,480 --> 00:17:26,672
我得定义APPLY
We have to write apply.

315
00:17:27,570 --> 00:17:28,624
还有EVLIST
We're going to have to write EVLIST.

316
00:17:28,944 --> 00:17:30,208
以及LOOKUP
We're going to write LOOKUP.

317
00:17:31,790 --> 00:17:33,430
我看看 没别的了吧？
I think that's everything, isn't there?

318
00:17:33,430 --> 00:17:35,168
剩下的东西都很简单
Everything else is something which is simple,

319
00:17:35,168 --> 00:17:37,184
比如基本元素之类的东西
or primitive, or something like that.

320
00:17:38,570 --> 00:17:39,488
当然
And, of course,

321
00:17:39,696 --> 00:17:42,064
在这里 可以扩充很多特殊形式
we could many more special forms here,

322
00:17:42,256 --> 00:17:44,450
但如果在通用语言中这么做就很糟糕
but that would be a bad idea in general in a language.

323
00:17:44,450 --> 00:17:45,920
在这里添加大量的东西
You make a language very complicated

324
00:17:46,000 --> 00:17:47,488
会让语言变得复杂
by putting a lot of things in there.

325
00:17:47,690 --> 00:17:50,352
语言中的保留字
The number of reserve words that should exist in a language

326
00:17:50,768 --> 00:17:53,616
不该比你能用几个手指、脚指记住的数目多
should be no more than a person could remember on his fingers and toes.

327
00:17:54,160 --> 00:17:55,536
有些语言的保留字有成百上千个
And I get very upset with languages

328
00:17:55,568 --> 00:17:58,208
我都不知道该说什么了
which have hundreds of reserve words.

329
00:17:59,410 --> 00:18:00,710
保留字就是在这里定义的
But that's where the reserve words go.

330
00:18:03,152 --> 00:18:06,540
好 接下来 我们来看下一个部分
Okay. Well, now let's get to the next part of this,

331
00:18:06,560 --> 00:18:07,690
求值器的核心 APPLY
the kernel, apply.

332
00:18:09,640 --> 00:18:10,752
它还做些什么呢？
What else is this doing?

333
00:18:11,590 --> 00:18:17,536
APPLY把还是符号状态的求值运算符和运算对象
Well, apply's job is to take a procedure and apply it to its arguments

334
00:18:17,664 --> 00:18:20,688
求值为相应的过程以及参数值
after both have been evaluated to come up with a procedure and the arguments

335
00:18:20,912 --> 00:18:23,856
然后把得到的过程应用在参数上
rather the operator symbols and the operand symbols,

336
00:18:24,096 --> 00:18:26,960
无论它们是什么符号表达式
whatever they are-- symbolic expressions.

337
00:18:33,270 --> 00:18:35,088
我们把APPLY定义为
So we will define apply

338
00:18:38,352 --> 00:18:40,656
接收两个参数的过程
to be a procedure of two arguments,

339
00:18:40,752 --> 00:18:43,440
一个过程和对应的参数
a procedure and arguments.

340
00:18:47,248 --> 00:18:48,128
它要怎么做呢？
And what does it do?

341
00:18:48,144 --> 00:18:49,552
其实并不复杂
It does nothing very complicated.

342
00:18:49,936 --> 00:18:50,784
分两种情况就够了
It's got two cases.

343
00:18:53,580 --> 00:18:55,168
如果这个过程是基本过程--
Either the procedure is primitive--

344
00:19:03,424 --> 00:19:06,416
我不知道这个谓词具体是如何判断的
And I don't know exactly how that is done.

345
00:19:06,864 --> 00:19:10,240
可能这里面有某种类型信息
It's possible there's some type information

346
00:19:10,384 --> 00:19:12,416
就像我们在这里用'CLOSURE
just like we made closure for, here,

347
00:19:12,688 --> 00:19:15,056
来描述一些复合对象一样
being the description of the type of a compound thing--

348
00:19:16,336 --> 00:19:17,792
我想可能是这样
OK? probably so.

349
00:19:18,550 --> 00:19:20,208
但是具体怎么判断并不重要
But it is not essential how that works,

350
00:19:20,688 --> 00:19:22,016
事实上
in fact, it turns out,

351
00:19:22,192 --> 00:19:23,856
你可能已经知道或者推断过
as you probably know or have deduced,

352
00:19:23,872 --> 00:19:25,472
我们并不需要任何基本过程
that you don't need any primitives anyway.

353
00:19:27,350 --> 00:19:29,280
就算没有它们 照样可以进行计算
You can compute anything because without

354
00:19:30,464 --> 00:19:33,190
因为我们可以用一直在用的LAMBDA
because some of the lambda that I've been playing with.

355
00:19:33,616 --> 00:19:34,768
但是有它们总归方便点儿
But it's nice to have them.

356
00:19:34,810 --> 00:19:36,272
我在这儿略施魔法
So here we're going to do some magic

357
00:19:36,304 --> 00:19:37,470
但不会去解释
which I'm not going to explain.

358
00:19:38,060 --> 00:19:41,440
转到机器语言 执行APPLY-PRIMOP
Go to machine language, apply primop.

359
00:19:42,912 --> 00:19:43,808
加法是在这里运算的
Here's how it adds.

360
00:19:44,784 --> 00:19:46,100
执行加法指令
Execute an add instruction.

361
00:19:50,620 --> 00:19:52,112
然而一门语言有趣的部分
However, the interesting part of a language

362
00:19:52,144 --> 00:19:54,270
在于组合基本元素的粘合剂
is the glue by which the primitives are glued together.

363
00:19:54,912 --> 00:19:55,904
我们接着往下看
So let's look at that.

364
00:19:56,910 --> 00:19:58,384
另一种可能就是
Well, the other possibility

365
00:19:58,752 --> 00:20:04,128
这个复合对象是求值LAMBDA表达式得到的
this is a compound made up by executing a lambda expression,

366
00:20:04,976 --> 00:20:07,056
这是个复合过程
this is a compound procedure.

367
00:20:07,620 --> 00:20:09,360
检测它的类型标志
Well, we'll check its type.

368
00:20:10,110 --> 00:20:17,072
如果是'CLOSURE
If it is closure,

369
00:20:20,512 --> 00:20:24,096
如果是的话 我就得求值这个过程的体
if it's one of those, then I have to do an eval of the body.

370
00:20:24,190 --> 00:20:27,392
过程的体的求值方式则是
The way I do this, the way I deal with this at all

371
00:20:28,080 --> 00:20:31,696
我求值过程的应用是通过
is the way I evaluate the application of a procedure to its arguments,

372
00:20:31,720 --> 00:20:33,710
先扩充程序的求值环境
is by evaluating the body of the procedure

373
00:20:34,192 --> 00:20:37,808
在这个环境中 把过程的形式参数
in the environment resulting from extending the environment of the procedure

374
00:20:37,920 --> 00:20:40,480
跟传递过来的实际参数绑定在一起
with the bindings of the formal parameters

375
00:20:41,024 --> 00:20:43,680
在这个环境中求值过程的体
of the procedure to the arguments that were passed to it.

376
00:20:46,704 --> 00:20:47,872
这句话很长
That was a long sentence.

377
00:20:51,130 --> 00:20:52,160
但其实简单
Well that's easy enough.

378
00:20:52,820 --> 00:20:54,480
一会儿可能会出现许多CAR CDR...
Now here's going to be a lot of CAR-CDRing.

379
00:20:56,464 --> 00:20:58,110
现在我先要得到过程体
I have to get the body of the procedure.

380
00:20:59,400 --> 00:21:02,304
如何取出过程体呢？
Where's the body of the procedure in here?

381
00:21:02,960 --> 00:21:04,080
这里是CAR部分
Well here's the CAR,

382
00:21:04,496 --> 00:21:06,130
这一块是剩下部分的CDR部分
here's the CDR is the whole rest of this.

383
00:21:06,130 --> 00:21:06,960
因此这就是CADR
So here's the CADR.

384
00:21:07,400 --> 00:21:09,456
所以这里我得到的过程体
And so I see, what I have here is the body

385
00:21:09,456 --> 00:21:13,040
是过程对象第二个元素的第二个元素
is the second element of the second element of the procedure.

386
00:21:13,200 --> 00:21:15,152
因此CADR的CADR 也就是CADADR
So it's the CADR of the CADR or the CADADR.

387
00:21:19,170 --> 00:21:27,680
这里取过程对象的CADADR部分
It's the C-A-D-A-D-R, CADADR of the procedure.

388
00:21:30,260 --> 00:21:31,560
为了求值过程体
To evaluate the body

389
00:21:31,984 --> 00:21:36,480
要在参数绑定后的新环境之中进行
in the result of binding that's making up more environment,

390
00:21:38,096 --> 00:21:42,064
我还得获取过程的形式参数
well I need the formal parameters of the of the procedure,

391
00:21:42,064 --> 00:21:42,720
要怎么取呢？
what is that?

392
00:21:43,500 --> 00:21:45,136
就是CADR部分的CAR部分
That's the CAR of the CADR.

393
00:21:46,528 --> 00:21:48,780
这很糟糕不是吗？
OK? It's horrible isn't it?

394
00:21:52,656 --> 00:21:53,632
过程的CADR部分
--of the procedure.

395
00:21:55,440 --> 00:22:00,864
在随着过程一起传递过来的环境中
Bind that to the arguments that were passed in the environment,

396
00:22:00,896 --> 00:22:04,144
把形参和由环境传递过来的实参绑定起来
which is passed also as part of the procedure.

397
00:22:04,540 --> 00:22:07,904
也就是CDR的CDR的CAR
Well, that's the CAR of the CDR of the CDR of this,

398
00:22:09,792 --> 00:22:16,624
也就是过程的CADDR部分
CADDR, of the procedure.

399
00:22:20,290 --> 00:22:24,960
（闭合括号中）
Bind, eval, pair, COND, lamda, define--

400
00:22:26,144 --> 00:22:29,680
当然 如果我非常追求整洁
Now, of course, if I were being really a neat character,

401
00:22:29,872 --> 00:22:31,344
并且又非常谨慎
and I was being very careful,

402
00:22:32,240 --> 00:22:34,128
我会在后面多加一个情况
I would actually put an extra case here

403
00:22:34,384 --> 00:22:35,984
来判断是否出错
for checking for certain errors like,

404
00:22:36,176 --> 00:22:38,416
比如应用在参数上的是一个过程吗？
did you try to apply one to an argument?

405
00:22:39,000 --> 00:22:41,696
如果不是 这里就是未定义的过程类型
You get a undefined procedure type.

406
00:22:42,570 --> 00:22:44,096
我在这里也会这么做
So I may as well do that anyway.

407
00:22:45,808 --> 00:22:55,968
像这样 在ELSE子句中返回错误
--else, some sort of error, like that.

408
00:22:57,610 --> 00:23:01,616
当然 在现实中的一些系统中
Now, of course, again, in some sort of more real system,

409
00:23:02,560 --> 00:23:04,224
出于专业设计的考虑
written for professional reasons,

410
00:23:05,320 --> 00:23:08,000
这里可能会根据某种分派
this would be written with a case analysis

411
00:23:08,368 --> 00:23:09,900
来进行“分情况处理”
done by some sort of dispatch.

412
00:23:10,750 --> 00:23:12,688
回到这里 我可能还会添加新的条件来检查
Over here, I would probably have other cases

413
00:23:12,704 --> 00:23:14,144
比如 这是编译过的代码吗？
like, is this compiled code?

414
00:23:16,220 --> 00:23:16,848
这很重要
It's very important.

415
00:23:16,880 --> 00:23:18,352
这样的话我就可以区分
I might have distinguished the kind of code

416
00:23:18,384 --> 00:23:22,336
过程是直接由解释LAMBDA表达式而来
that's produced by a directly evaluating a lambda in interpretation

417
00:23:22,944 --> 00:23:25,872
还是从另外的编译器中得到的 等等
from code that was produced by somebody's compiler or something like that.

418
00:23:26,112 --> 00:23:27,230
之后再讨论这个话题
And we'll talk about that later.

419
00:23:27,230 --> 00:23:29,616
又或许是 我必须要执行的一段Frotran代码
Or is this a piece Fortran program I have to go off and execute.

420
00:23:30,510 --> 00:23:32,512
这完全是可能的
It's a perfectly possible thing, at this point, to do that.

421
00:23:32,920 --> 00:23:36,416
实际上 我用具体语法写的这个求值器
In fact, in this concrete syntax evaluator I'm writing here,

422
00:23:37,456 --> 00:23:40,864
假定了它是用Lisp来编写的
there's an assumption built in that this is Lisp,

423
00:23:42,304 --> 00:23:43,824
这是因为我用了CAR和CDR
because I'm using CARs and CDRs.

424
00:23:43,840 --> 00:23:45,104
用CAR来取运算符
CAR means the operator,

425
00:23:45,280 --> 00:23:46,640
用CDR来取运算对象
and CDR means the operand.

426
00:23:46,750 --> 00:23:49,968
教科书上给出了一个用抽象语法编写的求值器
In the text, there is an abstract syntax evaluator

427
00:23:50,350 --> 00:23:53,152
它使用的都是抽象的名字
which these could be-- these are given abstract names

428
00:23:53,160 --> 00:23:54,096
比如OPERATOR、OPERAND
like operator, and operand,

429
00:23:54,144 --> 00:23:55,820
以及类似的名字
and all these other things are like that.

430
00:23:56,160 --> 00:23:56,864
那样的话
And, in that case,

431
00:23:57,024 --> 00:24:00,912
你可以毫无问题地用ALGOL来重新实现
you could reprogram it to be ALGOL with no problem.

432
00:24:03,360 --> 00:24:06,400
写完APPLY之后
Well, here we have added another couple of things

433
00:24:07,200 --> 00:24:08,432
又有一些东西没有定义
that we haven't defined.

434
00:24:10,810 --> 00:24:12,576
我先不操心这两个
I don't think I'll worry about these at all,

435
00:24:13,392 --> 00:24:15,050
我们稍后讨论这个很重要的BIND
however, this one will be interesting later.

436
00:24:17,184 --> 00:24:19,760
现在我们来快速过一遍 结束这一部分
Let's just proceed through this and get it done.

437
00:24:20,550 --> 00:24:22,656
只剩下两块黑板了 不能够写太长
There's only two more blackboards so it can't be very long.

438
00:24:27,408 --> 00:24:29,088
我还得悉心裁剪才能刚好写下
It's carefully tailored to exactly fit.

439
00:24:30,070 --> 00:24:30,980
嗯 还剩下点什么？
Well, what do we have left?

440
00:24:30,980 --> 00:24:33,200
我们得定义这里的EVLIST
We have to define EVLIST, which is over here.

441
00:24:33,730 --> 00:24:35,072
EVLIST只不过是
And EVLIST is nothing more

442
00:24:35,264 --> 00:24:43,088
在运算对象上映射某个函数得到参数
than a map down a bunch of operands producing arguments.

443
00:24:44,304 --> 00:24:45,408
但是我还是要写出来看看
But I'm going to write it out.

444
00:24:45,820 --> 00:24:48,304
我把它写出来的原因有点神秘
And one of the reasons I'm going to write this out is for a mystical reason,

445
00:24:49,888 --> 00:24:52,048
我想让这个求值器简单得
which is I want to make this evaluator so simple

446
00:24:52,064 --> 00:24:53,568
可以求值自身
that it can understand itself.

447
00:24:56,450 --> 00:24:58,096
我真的很在意这一点
I'm going to really worry about that a little bit.

448
00:25:00,230 --> 00:25:01,744
现在我就把它完全写在这里
So let's write it out completely.

449
00:25:02,850 --> 00:25:04,240
我并不关心
See, I don't want to worry about

450
00:25:04,272 --> 00:25:06,080
它能否把过程作为参数传递
whether or not the thing can pass functional arguments.

451
00:25:06,272 --> 00:25:08,064
求值器并不会用到这些参数
The value evaluator is not going to use them.

452
00:25:08,980 --> 00:25:10,784
求值器也不会生成一个是过程的值
The evaluator is not going to produce functional values.

453
00:25:10,880 --> 00:25:12,672
因此 如果另外有个不同的语言
So even if there were a different, alternative language

454
00:25:12,800 --> 00:25:13,968
跟这个又非常相似
that were very close to this,

455
00:25:15,160 --> 00:25:17,792
这个求值器能够求值像Scheme这样的复杂语言
this evaluates a complex language like Scheme

456
00:25:17,808 --> 00:25:23,120
Scheme是能够把过程当做参数传递的
which does allow procedural arguments, procedural values, and procedural data.

457
00:25:24,070 --> 00:25:25,952
但当我在求值ALGOL时
But even if I were evaluating ALGOL,

458
00:25:27,344 --> 00:25:28,960
尽管ALGOL并不支持过程值
which doesn't allow procedural values,

459
00:25:29,472 --> 00:25:30,592
这个求值器也能正常工作
I could use this evaluator.

460
00:25:31,580 --> 00:25:33,920
因为这个解释器 并没有对这个做过什么假定
And this evaluator is not making any assumptions about that.

461
00:25:34,270 --> 00:25:36,032
实际上 就算这个求值器
And, in fact, if this evaluator were to be restricted

462
00:25:36,270 --> 00:25:37,504
被限制不允许那么做 也没有什么关系
to not being able to that, it wouldn't matter

463
00:25:37,520 --> 00:25:40,030
因为它没有使用那些高级功能
because it doesn't use any of those clever things.

464
00:25:40,640 --> 00:25:42,416
这就是我为什么要把它设计得非常简单
So that's why I'm arranging this to be super simple.

465
00:25:44,070 --> 00:25:46,464
这几乎是所有可能的语言求值器的核心
This is sort of the kernel of all possible language evaluators.

466
00:25:47,810 --> 00:25:48,480
回到这个定义上来
How about that?

467
00:25:49,420 --> 00:25:53,568
EVLIST -- 它是什么呢？
Evlist--  well, what is it?

468
00:25:53,820 --> 00:25:57,040
这个过程接收两个参数 L和ENV
It's the procedure of two arguments, l and an environment,

469
00:25:58,096 --> 00:25:59,088
其中L是个表
where l is a list

470
00:25:59,584 --> 00:26:08,272
这样的话 如果参数表是空表
such that if the list of arguments is the empty list,

471
00:26:10,192 --> 00:26:12,688
那么结果就是空表
then the result is the empty list.

472
00:26:14,032 --> 00:26:19,232
否则的话 我就要组合
Otherwise, I want to cons up

473
00:26:20,752 --> 00:26:26,672
在ENV中求值运算对象表的CAR部分
result of evaluating the CAR of the

474
00:26:28,160 --> 00:26:32,512
在ENV中求值运算对象CAR部分的结果
the CAR of the list of operands in the environment.

475
00:26:33,344 --> 00:26:35,712
我想先求值第一个运算对象
So I want the first operand evaluated,

476
00:26:35,984 --> 00:26:38,400
返回的结果将是一个新表
and I'm going to make a list of the results

477
00:26:38,970 --> 00:26:40,768
是通过把这个和
by CONSing that onto the result

478
00:26:41,088 --> 00:26:45,420
用CDR递归EVLIST的结果组合得到的
of this EVLISTing as a CDR recursion,

479
00:26:46,224 --> 00:26:50,130
在同样的ENV下 L的CDR部分
the CDR of the list relative to the same environment.

480
00:26:53,088 --> 00:26:58,240
（闭合括号中）
Evlist, cons, else, COND, lambda, define--

481
00:26:59,660 --> 00:27:01,840
还有一个过程
OK? And I have one more

482
00:27:01,840 --> 00:27:03,360
我也想写在这里
that I want to put on the blackboard.

483
00:27:03,620 --> 00:27:05,216
它是这整个的关键
It's the essence of this whole thing.

484
00:27:05,648 --> 00:27:08,130
还要深入一个层次
And there's some sort of next layer down.

485
00:27:14,540 --> 00:27:15,440
也就是COND语句
Conditionals--

486
00:27:15,690 --> 00:27:16,992
在剩下的东西中
conditionals are the only thing left

487
00:27:17,024 --> 00:27:18,170
EVCOND是唯一的重要过程
that are sort of substantial.

488
00:27:18,880 --> 00:27:20,752
解决完这个后
Then below that, we have to worry about

489
00:27:21,072 --> 00:27:22,944
我们再讨论LOOKUP和BIND
things like lookup and bind,

490
00:27:23,568 --> 00:27:25,360
稍后再来讨论
and we'll look at that in a second.

491
00:27:25,530 --> 00:27:27,936
在这个层次上 这是非常重要的
But of the substantial stuff at this level of detail,

492
00:27:28,656 --> 00:27:30,624
下一个重要的事就是如何处理COND语句
next important thing is how you deal with conditionals.

493
00:27:31,600 --> 00:27:33,330
那么 我们怎么来处理呢？
Well, how do we have a conditional thing?

494
00:27:36,970 --> 00:27:38,560
它是一个过程
It's a procedure

495
00:27:39,488 --> 00:27:45,000
参数是一组子句CLAUSES和环境ENV
of clauses and an environment.

496
00:27:47,712 --> 00:27:48,512
它做些什么呢？
And what does it do?

497
00:27:49,820 --> 00:27:55,472
如果子句为空
It says, if I've no more clauses,

498
00:28:02,608 --> 00:28:03,968
我得有一个返回值
well, I have to give this a value.

499
00:28:04,704 --> 00:28:05,872
可能是一个错误
It could be that it was an error.

500
00:28:06,540 --> 00:28:08,592
如果遍历完了所有条件 都没有符合的
Supposing it run off the end of a conditional,

501
00:28:09,152 --> 00:28:10,060
那么它可能有任意的行为
it's pretty arbitrary.

502
00:28:10,060 --> 00:28:12,880
这完全取决于程序员要怎么处理
It's up to me as programmer to choose what I want to happen.

503
00:28:13,650 --> 00:28:15,456
现在对我来说最方便的是
It's convenient for me, right now, to write down

504
00:28:15,632 --> 00:28:17,536
让它返回一个空表
this has a value which is the empty list,

505
00:28:18,144 --> 00:28:18,832
这无所谓
doesn't matter.

506
00:28:20,100 --> 00:28:20,880
为了检查出错误
For error checking,

507
00:28:20,896 --> 00:28:22,760
有些人喜欢在这里写点别的
some people might prefer something else.

508
00:28:23,110 --> 00:28:24,816
下面的更有意思
But the interesting things are the following ones.

509
00:28:25,392 --> 00:28:27,248
如果我遇到了ELSE子句
If I've got an else clause--

510
00:28:31,000 --> 00:28:32,736
请看 我们有一个由子句组成的表
You see, if I have a list of clauses,

511
00:28:33,216 --> 00:28:34,416
其中每个子句也是一个表
then each clause is a list.

512
00:28:35,440 --> 00:28:40,528
因此谓词就应该是CLAUSES的CAAR部分
And so the predicate part is the CAAR of the clauses.

513
00:28:43,560 --> 00:28:45,024
它是
It's the CAR,

514
00:28:45,040 --> 00:28:49,008
CLAUSES表中第一个元素的CAR部分
which is the first part of the first clause in the list of clauses.

515
00:28:51,090 --> 00:28:51,840
如果它是'ELSE的话
If it's an else,

516
00:28:54,320 --> 00:28:56,510
就意味着整个COND表达式的结果
then it means I want my result of the conditional

517
00:28:56,640 --> 00:28:59,152
就是求值匹配表达式的结果
to be the result of evaluating the matching expression.

518
00:29:00,128 --> 00:29:04,320
所以我求值CADAR部分
So I eval the CADAR.

519
00:29:07,008 --> 00:29:09,568
这是第一个子句的
So this is the first clause,

520
00:29:10,128 --> 00:29:11,632
第二个元素 也就是CADAR
the second element of it, CADAR--

521
00:29:12,810 --> 00:29:17,088
也就是CLAUSES的CAR部分的CADR部分
CADR of a CAR-- of the clauses,

522
00:29:21,232 --> 00:29:22,576
求值的环境是ENV
with respect to the environment.

523
00:29:26,620 --> 00:29:28,608
下一种可能性更有意思
Now the next possibility is more interesting.

524
00:29:29,630 --> 00:29:30,448
如果它返回FALSE的话
If it's false,

525
00:29:33,056 --> 00:29:35,104
如果谓词表中的第一个谓词
if the first predicate in the predicate list

526
00:29:35,744 --> 00:29:37,680
既不是ELSE子句 又不为FALSE
is not an else, and it's not false,

527
00:29:38,320 --> 00:29:39,504
也就是它不是保留字ELSE
if it's not the word else,

528
00:29:40,160 --> 00:29:42,000
并且也不是一个值为FALSE的东西
and if it's not a false thing--

529
00:29:42,032 --> 00:29:43,664
如果为FALSE又要怎么处理呢？
Let's write down what it is if it's a false thing.

530
00:29:44,360 --> 00:29:50,080
如果在相应的环境中
If the result of evaluating the first clause -- first predicate,

531
00:29:52,336 --> 00:29:56,768
求值子句中第一个谓词的结果
the clauses--  respect the environment,

532
00:29:58,190 --> 00:30:01,008
如果求值的结果是FALSE的话
if that evaluation yields false,

533
00:30:01,696 --> 00:30:03,824
这就意味着 还得接着判断后面的子句
then it means, I want to look at the next clause.

534
00:30:04,368 --> 00:30:05,744
第一个就扔掉不管了
So I want to discard the first one.

535
00:30:06,250 --> 00:30:08,336
所以就进入下一个EVCOND循环
So we just go around loop, evcond,

536
00:30:09,952 --> 00:30:16,496
在对应的环境中继续判断子句的CDR部分
the CDR of the clauses relative to that environment.

537
00:30:19,952 --> 00:30:25,150
又或者 我遇到了求值为TRUE的子句
And otherwise, I had a true clause,

538
00:30:26,848 --> 00:30:28,960
这样的话 我想在对应的环境中
what I want is to evaluate

539
00:30:31,856 --> 00:30:41,456
求值CLAUSES的CADAR部分
the CADAR of the clauses relative to that environment.

540
00:30:48,208 --> 00:30:49,616
快了 快完成了
Boy, it's almost done.

541
00:30:51,210 --> 00:30:52,800
基本上完整了
It's quite close to done.

542
00:30:53,730 --> 00:30:55,872
把这一部分结束
I think we're going to finish this part off.

543
00:30:56,210 --> 00:30:58,576
再回顾一下这个求值器
So just buzzing through this evaluator,

544
00:30:58,816 --> 00:31:00,704
它基本上就是这样了
but so far you're seeing almost everything.

545
00:31:01,088 --> 00:31:04,040
接着来看一张幻灯片
Let's look at the next transparency here.

546
00:31:06,320 --> 00:31:10,432
这是BIND的定义
And see IS, Here is bind.

547
00:31:11,980 --> 00:31:14,544
BIND用于在环境中添加新的绑定
Bind is for making more table.

548
00:31:15,460 --> 00:31:18,672
我们要在这里
And what we are going to do here is make a--

549
00:31:19,248 --> 00:31:22,800
为环境结构创建一个新框架
we're going to make a new frame for an environment structure.

550
00:31:22,800 --> 00:31:25,424
环境结构是通过由框架组成的表
The environment structure is going to be represented

551
00:31:25,936 --> 00:31:27,200
来表示的
as a list of frames.

552
00:31:28,080 --> 00:31:30,192
给定一个已有的环境
So given an existing environment structure,

553
00:31:30,320 --> 00:31:32,112
我可以通过把一个新建的框架
I'm going to make a new environment structure

554
00:31:32,256 --> 00:31:33,824
CONS在已有的环境上
by consing a new frame

555
00:31:33,936 --> 00:31:35,696
来获得新的环境
onto the existing environment structure,

556
00:31:36,624 --> 00:31:40,368
正在应用的过程中 那些被绑定变量
where the new frame consists of the result of pairing up the variables,

557
00:31:41,050 --> 00:31:43,790
与传递给过程的参数值结合在一起
which are the bound variables of the procedure I'm applying,

558
00:31:44,128 --> 00:31:48,256
组成了我们所创建的新框架
to the values which are the arguments that were passed that procedure.

559
00:31:49,690 --> 00:31:50,656
BIND其实就是创建表
This is just making a list,

560
00:31:51,648 --> 00:31:54,064
环境就是一组由框架组成的表
adding a new element to our list of frames,

561
00:31:54,300 --> 00:31:55,600
把新的元素加入其中
which is an environment structure,

562
00:31:55,744 --> 00:31:56,896
也就形成了新的环境
to make a new environment.

563
00:31:58,656 --> 00:32:00,656
而PAIR-UP的定义非常简单
Where pair-up is very simple.

564
00:32:01,540 --> 00:32:02,848
PAIR-UP只不过是
Pair-up is nothing more

565
00:32:03,136 --> 00:32:05,568
如果我们有一个变量表和一个值表
than if I have a list of variables and a list of values,

566
00:32:05,936 --> 00:32:08,624
那么 如果它俩的元素个数又相同
well, if I run out of variables and if I run out of values,

567
00:32:08,624 --> 00:32:09,584
就可以让它们一一对应
everything's OK.

568
00:32:09,720 --> 00:32:11,488
否则的话 就是参数传递多了
Otherwise, I've given too many arguments.

569
00:32:12,512 --> 00:32:15,984
如果值的个数比变量的个数多
If I've not run out of variables, but I've run out of values,

570
00:32:16,064 --> 00:32:17,376
那就说明参数传递少了
that I have too few arguments.

571
00:32:18,512 --> 00:32:19,632
通常的情况是
And in the general case,

572
00:32:19,632 --> 00:32:21,488
如果没有出错 又没有完成的话
where I don't have any errors, and I'm not done,

573
00:32:22,060 --> 00:32:25,616
我就添加一个由第一个变量
OK? Then I really am just adding a new pair

574
00:32:25,760 --> 00:32:30,176
和第一个参数组成的新序对
of the first variable with the first argument,

575
00:32:30,944 --> 00:32:32,128
这是第一个值
the first value,

576
00:32:32,760 --> 00:32:36,400
把它们CONS在
onto a list resulting from pairing-up

577
00:32:37,120 --> 00:32:40,640
剩余变量和值组成的表上
the rest of the variables with the rest of the values.

578
00:32:42,950 --> 00:32:44,784
LOOKUP也同样简单
Lookup is of course equally simple.

579
00:32:46,288 --> 00:32:49,632
加入我要在环境中查找一个符号
If I have to look up a symbol in an environment,

580
00:32:49,936 --> 00:32:51,392
那么 如果是空环境
well, if the environment is empty,

581
00:32:51,568 --> 00:32:53,008
那么就说明 该变量尚未绑定
then I've got an unbound variable.

582
00:32:54,650 --> 00:32:55,472
否则
Otherwise,

583
00:32:56,864 --> 00:33:00,368
我就要使用一个特殊的关联表查找过程
what I'm going to do is use a special pair list lookup procedure,

584
00:33:00,384 --> 00:33:01,872
我们不久就会看到它的定义
which we'll have very shortly,

585
00:33:02,240 --> 00:33:05,440
用它在环境的第一个框架中查找该符号
of the symbol in the first frame of the environment.

586
00:33:05,930 --> 00:33:07,216
由于我知道这个环境不是空的
Since I know the environment is not empty,

587
00:33:07,232 --> 00:33:08,400
因此 它至少有一个框架
it must have a first frame.

588
00:33:09,200 --> 00:33:11,140
所以 我就在它第一个框架中查找
So I lookup the symbol in the first frame.

589
00:33:11,568 --> 00:33:13,584
找到的序对会传递给这里的VCELL
That becomes the value cell here.

590
00:33:14,380 --> 00:33:17,616
如果VCELL为空
OK? And then, if the value cell is empty,

591
00:33:18,448 --> 00:33:20,576
那就说明当前框架中没有这个符号
if there is no such value cell,

592
00:33:20,704 --> 00:33:22,848
我就需要在环境中剩下的框架中查找
then I have to continue and look at the rest of the frames.

593
00:33:23,720 --> 00:33:25,040
VCELL为空 意味着当前框架没有相应的符号
It means there was nothing found there.

594
00:33:25,990 --> 00:33:28,896
如果没有找到
So that's a property of ASSQ is it returns emptiness

595
00:33:29,520 --> 00:33:30,800
ASSQ就会返回空表
if it doesn't find something.

596
00:33:32,320 --> 00:33:33,856
如果找到了
but if it did find something,

597
00:33:33,856 --> 00:33:36,064
那么我就使用VCELL的CDR部分
then I'm going to use the CDR of the value cell here,

598
00:33:36,464 --> 00:33:40,256
因为VCELL是变量和值组成的序对
which is the thing that was the pair consisting of the variable and the value.

599
00:33:41,050 --> 00:33:43,936
因此可以用CDR取得对应的值
So the CDR of it is the value part. OK?

600
00:33:45,000 --> 00:33:47,824
ASSQ这个过程你们之前见过
Finally, ASSQ is something you've probably seen already.

601
00:33:47,970 --> 00:33:50,832
ASSQ的参数是一个符号和一个由序对组成的表
ASSQ takes a symbol and a list of pairs,

602
00:33:51,424 --> 00:33:53,408
如果表为空 它就返回空表
and if the list is empty, it's empty.

603
00:33:53,520 --> 00:33:56,304
如果这个符号是ALIST的第一个元素
If the symbol is the first thing in the list--

604
00:33:58,064 --> 00:33:58,912
这里写错了
That's an error.

605
00:33:59,820 --> 00:34:02,176
应该是CAAR
That should be CAAR, C-A-A-R.

606
00:34:03,168 --> 00:34:04,160
大家注意一下
Everybody note that.

607
00:34:07,632 --> 00:34:09,376
就是这里 看到了吗？
Right there, OK?

608
00:34:13,424 --> 00:34:14,416
总之
And in any case,

609
00:34:14,560 --> 00:34:16,816
如果符号等于表的CAAR
f the symbol is the CAAR of the A list,

610
00:34:17,160 --> 00:34:20,976
那么我就返回ALIST中第一个序对
then I want the first, the first pair, in the alist.

611
00:34:22,080 --> 00:34:25,504
换句话说 这个键匹配了正确的条目
So, in other words, if this is the key matching the right entry,

612
00:34:26,240 --> 00:34:26,976
否则的话
otherwise,

613
00:34:27,088 --> 00:34:28,944
我就需要在剩下的表中继续查找
I want to look up that symbol in the rest.

614
00:34:30,080 --> 00:34:33,312
这里有个笔误 很抱歉
Sorry for producing a bug, bugs appear.

615
00:34:35,190 --> 00:34:36,288
好了 不管如何
Well, in any case,

616
00:34:37,056 --> 00:34:39,488
你们基本上已经看到了全貌
you're pretty much seeing the whole thing now.

617
00:34:41,880 --> 00:34:43,296
虽然我们的代码风格非常丑陋
It's a very beautiful thing,

618
00:34:44,192 --> 00:34:46,000
但是作为所有语言的核心
even though it's written in an ugly style,

619
00:34:46,768 --> 00:34:48,304
它却是非常美妙
being the kernel of every language.

620
00:34:49,600 --> 00:34:51,376
我提议 让我们再欣赏一会儿
I suggest that we just-- let's look at it for a while.

621
00:35:00,320 --> 00:35:47,024
[音乐]
[ALSO SPRACH ZARATHUSTRA]

622
00:35:49,750 --> 00:35:50,912
大家有什么问题吗？
Are there any questions?

623
00:36:01,180 --> 00:36:03,296
没有的话就休息一会儿吧
Alright, I suppose it's time to take a small break then.

624
00:36:04,040 --> 00:36:10,736
[音乐]
[JESU, JOY OF MAN'S DESIRING]

625
00:36:13,880 --> 00:36:17,648
《计算机程序的构造和解释》

626
00:36:40,800 --> 00:36:43,936
讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授

627
00:36:43,950 --> 00:36:47,984
《计算机程序的构造和解释》

628
00:36:48,060 --> 00:36:51,936
元循环求值器 I

629
00:36:56,780 --> 00:36:58,992
现在 我们将用一个实例
OK, now we're just going to do a little bit of practice

630
00:36:59,296 --> 00:37:02,672
来理解一下求值器的运作过程
understanding what it is we've just shown you. OK?

631
00:37:03,470 --> 00:37:05,488
我们通过手工进行代换
What we're going to do is go through, in detail,

632
00:37:05,504 --> 00:37:10,368
来深入解释器的详细工作原理
an evaluation by informally substituting through the interpreter.

633
00:37:11,500 --> 00:37:14,944
由于我们的求值器不支持赋值和定义
And since we have no assignments or definitions in this interpreter,

634
00:37:15,200 --> 00:37:17,344
我们也就不用担心副作用
we have no possible side effects,

635
00:37:17,984 --> 00:37:22,032
因此我们可以放心大胆地进行代换
and so the we can do substitution with impunity

636
00:37:22,528 --> 00:37:24,592
不用担心任何副作用
and not worry about results.

637
00:37:25,330 --> 00:37:27,808
我们将要尝试去手工代换
So the particular problem I'd like to look at

638
00:37:28,064 --> 00:37:29,632
这个复杂的表达式
is it an interesting one.

639
00:37:30,690 --> 00:37:34,096
(EVAL
It's the evaluation of

640
00:37:34,910 --> 00:37:48,080
'(((LAMBDA (X) (LAMBDA (Y) (+ X Y)))
quote, open, open, open, lambda of x, lambda of y plus x y,

641
00:37:50,300 --> 00:37:52,624
（闭合括号中）
lambda, lambda,

642
00:37:53,040 --> 00:37:56,128
要把它应用在3和4上
applied to three, applied to four,

643
00:37:56,944 --> 00:37:59,580
求值过程是发生在全局环境E0中的
in some global environment which I'll call e0.

644
00:38:04,930 --> 00:38:05,968
这里的这个表达式
So what we have here

645
00:38:06,368 --> 00:38:08,048
是个参数为X的一元过程
is a procedure of one argument x,

646
00:38:08,090 --> 00:38:11,056
返回一个参数为Y的一元过程
which produces as its value a procedure of one argument y,

647
00:38:11,072 --> 00:38:12,128
后者计算X+Y
which adds x to y.

648
00:38:14,300 --> 00:38:17,960
外层的这个过程应用于数字3
We are applying the procedure of one argument x to three.

649
00:38:17,960 --> 00:38:19,392
所以X应该是3
So x should become three.

650
00:38:21,400 --> 00:38:23,984
返回的结果是一个参数为Y的一元过程
And the result of that should be procedure of one argument y,

651
00:38:24,336 --> 00:38:25,824
该过程将应用于数字4
which will then apply to 4.

652
00:38:28,910 --> 00:38:30,320
然后要做的也很简单
And there is a very simple case,

653
00:38:31,040 --> 00:38:32,736
计算X+Y即可
they will then add those results.

654
00:38:34,790 --> 00:38:35,824
具体做之前
And now in order to do that,

655
00:38:35,840 --> 00:38:37,760
先来构造一个非常简单的环境模型
I want to make a very simple environment model.

656
00:38:37,904 --> 00:38:40,480
到了现在 我相信你们已经想到
And at this point, you should already have in your mind

657
00:38:40,992 --> 00:38:42,592
这个过程产生的环境了
the environments that this produces.

658
00:38:44,460 --> 00:38:46,624
我们从全局环境开始
But we're going to start out with a global environment,

659
00:38:48,592 --> 00:38:50,064
我们把它记作E0
which I'll call e0,

660
00:38:54,608 --> 00:38:55,472
就像这样
which is that.

661
00:38:56,740 --> 00:39:02,464
里面应该有过程+、*的定义
And it's going to have in it things, definitions for plus, and times,

662
00:39:06,304 --> 00:39:10,368
这里 我们用希腊字母来表示过程对象 这样有趣点
and-- using Greek letters, isn't that interesting, for the objects--

663
00:39:11,216 --> 00:39:27,936
-、/、CAR、CDR、CONS以及EQ?
and minus, and quotient, and CAR, and CDR, and CONS, and EQ,

664
00:39:28,592 --> 00:39:31,056
其它需要的基本过程都在全局环境中
and everything else you might imagine in a global environment.

665
00:39:31,270 --> 00:39:33,824
每个符号都对应着一个过程对象
It's got something there for each of those things,

666
00:39:34,620 --> 00:39:36,096
这些都是解释器自带的
something the machine is born with,

667
00:39:37,104 --> 00:39:38,090
这就是E0
that's e0.

668
00:39:39,220 --> 00:39:41,840
现在 这个求值要怎样进行呢？
Now what does it mean to do this evaluation?

669
00:39:42,940 --> 00:39:45,184
我们来看看这些特殊形式
Well, we go through the set of special forms.

670
00:39:45,696 --> 00:39:47,056
首先 这不是数字
First of all, this is not a number.

671
00:39:48,670 --> 00:39:50,380
也不是符号
This is not a symbol.

672
00:39:53,136 --> 00:39:55,600
这不是一个引用表达式
Gee, it's not a quoted expression.

673
00:39:56,608 --> 00:39:58,384
虽然外层是一个引用表达式
This is a quoted expression,

674
00:39:59,470 --> 00:40:00,800
但并不是我想要去求值的那个
but that's not what I mentioned.

675
00:40:00,832 --> 00:40:01,360
我想问的是
The question is,

676
00:40:01,392 --> 00:40:04,960
被引用的这个表达式 是否也是个引用表达式？
whether or not the thing which is quoted is quoted expression?

677
00:40:05,890 --> 00:40:07,960
我是在求值一个表达式
I'm evaluating an expression.

678
00:40:07,960 --> 00:40:09,984
这个引号是为了引用这个特定表达式
This just says it's this particular expression.

679
00:40:11,410 --> 00:40:12,660
而被引用的并非引用表达式
This is not a quoted expression.

680
00:40:13,712 --> 00:40:17,216
当然 它也不是以LAMBDA开头
OK? It's not a thing that begins with lambda.

681
00:40:19,120 --> 00:40:20,672
也不以COND开头
It's not a thing that begins with COND.

682
00:40:22,030 --> 00:40:25,952
因此它是过程的应用
Therefore, it's an application of its of an operated operands.

683
00:40:26,310 --> 00:40:27,120
这是一个组合式
It's a combination.

684
00:40:28,570 --> 00:40:30,704
既然它是组合式
The combination thus has

685
00:40:30,890 --> 00:40:34,000
这就是它的运算符
this as the operator

686
00:40:34,640 --> 00:40:36,080
而这是它的运算对象
and this is the operands.

687
00:40:40,130 --> 00:40:42,416
这就意味着 我要
Well, that means that what I'm going to do is

688
00:40:42,570 --> 00:40:47,904
把它转换成
transform this into apply of eval,

689
00:40:50,128 --> 00:40:57,616
(APPLY (EVAL '((LAMBDA (X) (LAMBDA (y)
of quote, open, open lambda of x, lambda of y--

690
00:40:57,880 --> 00:40:59,120
也就是在E0环境中
I'm evaluating the operator--

691
00:40:59,952 --> 00:41:04,192
求值(+ X Y)
plus x y, in the environment,

692
00:41:07,264 --> 00:41:08,640
不要漏了<E0>
also e0,

693
00:41:12,784 --> 00:41:15,200
要应用到的运算对象则是
with the operands that I'm going to apply this to,

694
00:41:15,260 --> 00:41:17,280
用EVLIST求值参数的结果
the arguments being the result of EVLIST,

695
00:41:21,216 --> 00:41:24,496
也就是'(4)
the list containing four, fin e0.

696
00:41:29,010 --> 00:41:31,264
我用这个特殊的记号来表示<E0>
I'm using this funny notation here for e0

697
00:41:32,320 --> 00:41:34,832
这是为了指代那个环境
because this should be that environment.

698
00:41:35,450 --> 00:41:37,770
我无法为它命名
I haven't a name for it,

699
00:41:37,808 --> 00:41:39,152
因为我没有环境来存放<E0>的名字
because I have no environment to name it in.

700
00:41:41,960 --> 00:41:44,090
你当然可以把<E0>看作是
So this is just a representation

701
00:41:44,176 --> 00:41:46,176
某种引用表达式
what would be a quoted expression, if you will.

702
00:41:47,730 --> 00:41:51,168
在那里 它表示环境这种数据结构
The data structure, which is the environment, goes there.

703
00:41:53,040 --> 00:41:55,040
好的 这是变换后的结果
Well, that's what we're seeing here.

704
00:41:55,850 --> 00:41:56,672
为了执行这个表达式
Well in order to do this,

705
00:41:56,688 --> 00:41:58,048
我还得求值这两个表达式
I have to do this, and I have to do that.

706
00:41:59,610 --> 00:42:00,496
EVLIST简单点
Well this one's easy,

707
00:42:00,576 --> 00:42:03,184
我们先计算这个吧
so why don't we do that one first. OK?

708
00:42:03,770 --> 00:42:07,440
这就被归约为
This turns into apply of eval--

709
00:42:07,456 --> 00:42:08,832
上面的某些部分直接抄过来就好
just copying something now.

710
00:42:09,424 --> 00:42:11,000
代换的过程中少不了照抄
Most of the substitution rule is copying.

711
00:42:18,530 --> 00:42:21,248
抄写的时候我就不多加解释了
So I'm going to not say the words when I copy,

712
00:42:21,712 --> 00:42:23,872
这样能快一点儿
because it's faster.

713
00:42:26,410 --> 00:42:28,640
EVLIST的部分就代换成为
And then the EVLIST is going to turn into a

714
00:42:28,656 --> 00:42:36,720
(CONS (EVAL '4 <E0>)
cons, of eval, of four, in e0--

715
00:42:38,784 --> 00:42:40,176
因为它不是空表
because it was not an empty list--

716
00:42:41,440 --> 00:42:49,392
(EVLIST '() <E0>))
onto the result of EVLISTing, on the empty list, in e0.

717
00:42:52,580 --> 00:42:54,208
我要省略一些步骤了
And I'm going to start leaving out steps soon,

718
00:42:54,240 --> 00:42:55,360
因为太详细就有些无聊了
because it's going to get boring.

719
00:42:59,870 --> 00:43:05,424
下一步跟上面基本上一样
But this is basically the same thing as apply, of eval--

720
00:43:07,504 --> 00:43:08,544
继续照抄
I'm going to keep doing this--

721
00:43:10,688 --> 00:43:20,240
(((LAMBDA (X) (LAMBDA (Y) (+ X Y)) 3) 4) <E0>)
the lambda of x, the lambda of y, plus xy, 3, close, e0.

722
00:43:20,240 --> 00:43:21,200
看来我还宝刀未老嘛
I'm a pretty good machine.

723
00:43:24,240 --> 00:43:26,240
下面对4求值
Well, eval of four,

724
00:43:26,560 --> 00:43:28,440
4是一个数字
that's meets the question, is it a number.

725
00:43:29,008 --> 00:43:33,904
结果就应该是(CONS 4
So that's cons, right, cons of 4.

726
00:43:34,032 --> 00:43:37,472
EVLIST对空表求值 结果也是空表
And EVLIST of the empty list is the empty list,

727
00:43:38,336 --> 00:43:39,240
也就是这个
so that's this.

728
00:43:42,620 --> 00:43:45,088
这个非常容易理解
OK. And that's very simple to understand,

729
00:43:45,104 --> 00:43:47,440
就是一个只含有4的表
because that means the list containing four itself.

730
00:43:48,710 --> 00:43:53,840
继续代换为 (APPLY (EVAL
So this is nothing more than apply of eval,

731
00:43:55,280 --> 00:44:02,512
'((LAMBDA (X) (LAMBDA (Y) (+ X Y))
quote, open, open, lambda of x, lambda of y, plus x y,

732
00:44:03,400 --> 00:44:07,488
3) 4) <E0>)
three applied to, e0, applied to the list four--

733
00:44:08,688 --> 00:44:12,608
应用在'(4)上 这样就完成了
applied to the list four-- bang

734
00:44:13,940 --> 00:44:15,056
这是这一步的结果
So that's that step.

735
00:44:17,008 --> 00:44:19,968
现在让我们进行下一步 更有意思的一步
Now let's look at the next, more interesting thing.

736
00:44:20,360 --> 00:44:21,728
这行代码要如何求值？
What do I do to evaluate that?

737
00:44:23,070 --> 00:44:24,448
为了求值这一部分
Evaluating this means

738
00:44:25,200 --> 00:44:28,656
我得先求值-- 首先 它不是--
means I have to evaluate-- Well, it's not.

739
00:44:29,460 --> 00:44:31,040
这是一个应用
It's nothing but an application.

740
00:44:31,680 --> 00:44:33,104
它并不是特殊形式
It's not one of the special things.

741
00:44:33,570 --> 00:44:36,512
如果应用中的运算符
If the application of this operator,

742
00:44:36,510 --> 00:44:37,376
就是这里
which we see here--

743
00:44:37,664 --> 00:44:38,944
这就是运算符
here's the operator--

744
00:44:40,190 --> 00:44:41,770
应用在这个运算对象上
applied to this operands,

745
00:44:44,544 --> 00:44:45,744
形成了一个组合式
that combination.

746
00:44:46,720 --> 00:44:48,256
现在我们要如何来求值呢？
But we know how to do that,

747
00:44:48,848 --> 00:44:52,370
它是COND语句中的最后一种情况
because that's the last case of the conditional.

748
00:44:52,370 --> 00:44:55,520
在这步求值中 进行的代换是
So substituting in for this evaluation,

749
00:44:55,710 --> 00:44:57,472
把运算符的求值结果
it's apply of eval of the operator

750
00:44:57,504 --> 00:44:59,000
应用在EVLIST的运算对象上
in the EVLIST of the operands.

751
00:45:01,160 --> 00:45:08,208
这也就是 (APPLY (APPLY (EVAL
Well, it's apply, of apply, of eval,

752
00:45:10,576 --> 00:45:21,072
'(LAMBDA (X) (LAMBDA (Y) (+ X Y)))
of quote, open, lambda of x, lambda of y, plus x y,

753
00:45:21,800 --> 00:45:23,450
（闭合括号中）
lambda, lambda,

754
00:45:23,744 --> 00:45:25,424
<E0>)
in environment e0.

755
00:45:30,520 --> 00:45:32,672
我就直接给出运算对象的求值结果了
I'm going to short circuit the evaluation of the operands,

756
00:45:32,688 --> 00:45:34,144
具体过程跟之前是一样的
because they're the same as they were before.

757
00:45:35,230 --> 00:45:36,480
我有一个表'(3)
I got a list containing three,

758
00:45:36,512 --> 00:45:39,160
把它应用于'(4)
apply that, and apply that to four.

759
00:45:42,448 --> 00:45:43,568
我们接着看
Well let's see.

760
00:45:44,410 --> 00:45:46,384
对一个LAMBDA表达式求值
Eval of a lambda expression

761
00:45:48,016 --> 00:45:49,450
会产生一个过程对象
produces a procedure object.

762
00:45:52,030 --> 00:45:57,888
继续变换就是 (APPLY (APPLY
So this is apply, of apply,

763
00:46:00,304 --> 00:46:02,272
然后是一个过程对象 '(CLOSURE
of the procedure object closure,

764
00:46:04,520 --> 00:46:08,688
它里面包含了过程的体
which contains the body of the procedure, x,

765
00:46:08,944 --> 00:46:11,920
它绑定了变量X
which is lambda, which binds x [UNINTELLIGIBLE]

766
00:46:12,130 --> 00:46:15,408
然后是函数体内部
the internals of the body,

767
00:46:15,808 --> 00:46:18,176
它返回一个参数为Y的单参过程
it returns the procedure of one argument y,

768
00:46:18,560 --> 00:46:20,630
这个过程计算X+Y
which adds x to y.

769
00:46:23,210 --> 00:46:25,504
这个过程对象捕获了环境<E0>
Environment e0 is now captured in it,

770
00:46:27,248 --> 00:46:29,632
因为这些求值都是在<E0>中发生的
because this was evaluated with respect to e0.

771
00:46:30,112 --> 00:46:32,432
现在 <E0>也是CLOSURE对象的一部分
e0 is part now of the closure object.

772
00:46:33,040 --> 00:46:38,192
先应用于'(3)
Apply that to open, three, close, apply,

773
00:46:38,816 --> 00:46:41,300
再应用于'(4)
to open, 4, close, apply.

774
00:46:47,390 --> 00:46:49,296
在这步到这步的过程中
So going from this step to this step

775
00:46:49,312 --> 00:46:50,896
我构建了一个过程对象
meant that I made up a procedure object

776
00:46:50,910 --> 00:46:52,032
它捕获了<E0>
which captured in it

777
00:46:53,888 --> 00:46:55,980
并将其作为本身的一部分
e0 as part of the procedure object.

778
00:46:57,150 --> 00:46:58,512
现在 要把它们传递给APPLY了
Now, we're going to pass those to apply.

779
00:46:58,520 --> 00:46:59,712
我们得把这个过程
We have to apply this procedure

780
00:47:00,480 --> 00:47:01,580
应用在对应的参数上
to that set of arguments.

781
00:47:02,710 --> 00:47:06,512
这里的过程并不是基本过程
Well, but that procedure is not primitive.

782
00:47:07,380 --> 00:47:09,888
它有一个类型标志'CLOSURE
It's, in fact, a thing which has got the tag closure,

783
00:47:10,240 --> 00:47:12,096
因此还需要进行参数绑定
and, therefore, what we have to do is do a bind.

784
00:47:13,710 --> 00:47:14,720
必须要绑定
We have to bind.

785
00:47:15,830 --> 00:47:19,408
在这里构造的新环境
A new environment is made at this point,

786
00:47:20,448 --> 00:47:22,800
它有一个父环境
which has as its parent environment

787
00:47:22,944 --> 00:47:27,568
父环境是这里的<E0>
the one over here, e0, that environment.

788
00:47:30,320 --> 00:47:31,570
我们把新环境记作<E1>
And we'll call this one, e1.

789
00:47:34,620 --> 00:47:35,744
这里要绑定些什么呢？
Now what's bound in there?

790
00:47:36,040 --> 00:47:37,488
变量X绑定为值3
x is bound to three.

791
00:47:38,620 --> 00:47:40,448
这里写X=3
So I have x equal three.

792
00:47:41,480 --> 00:47:42,336
就是这些
That's what's in there.

793
00:47:44,940 --> 00:47:46,240
新环境记作E1
And we'll call that e1.

794
00:47:46,240 --> 00:47:48,448
而这个表达式会变换为
So what this transforms into

795
00:47:49,130 --> 00:47:50,720
对一个过程体的求值
is an eval of the body

796
00:47:51,728 --> 00:47:53,070
就是这个 在这里
of this, which is this,

797
00:47:54,400 --> 00:47:55,728
这个过程的体
the body of that procedure,

798
00:47:56,448 --> 00:47:58,528
在刚才创建的<E1>中进行求值
in the environment that you just saw.

799
00:48:00,290 --> 00:48:05,056
也就是 (APPLY (EVAL
So that's an apply, of eval,

800
00:48:06,920 --> 00:48:16,432
'(LAMBDA (Y) (+ X Y)) <E1>)
quote, open, lambda of y, plus x y-- the body-- in e1.

801
00:48:20,496 --> 00:48:22,480
把求值的结果应用于4
And apply the result of that to four,

802
00:48:23,680 --> 00:48:26,736
也就是'(4)
open, close, 4-- list of arguments.

803
00:48:28,432 --> 00:48:29,872
到了这里就很清晰了
Well, that's sensible enough

804
00:48:30,080 --> 00:48:32,272
我知道该如何求值LAMBDA表达式
because evaluating a lambda, I know what to do.

805
00:48:33,110 --> 00:48:34,176
也就是(APPLY
That means I apply,

806
00:48:37,168 --> 00:48:38,928
一个过程对象'(CLOSURE
the procedure which is closure,

807
00:48:43,744 --> 00:48:46,848
它绑定参数Y 计算X+Y
binds one argument y, adds x to y,

808
00:48:49,280 --> 00:48:52,150
并且捕获了环境<E1>
with e1 captured in it.

809
00:48:55,790 --> 00:48:57,424
你应该已经见过了 对吧？
And you should really see this. Right?

810
00:48:57,800 --> 00:49:00,140
我构造了一个CLOSURE对象
I somehow manufactured a closure.

811
00:49:00,140 --> 00:49:01,168
放在这里
I should've put this here.

812
00:49:01,790 --> 00:49:03,040
之前的那个也是
There was one over here too.

813
00:49:05,904 --> 00:49:07,472
这是现在的这个
OK? Well, there's one here now.

814
00:49:08,080 --> 00:49:09,808
它捕获了环境<E1>
I've captured e1,

815
00:49:10,416 --> 00:49:14,256
而这个是参数为Y的一元过程
and this is the procedure of one argument y,

816
00:49:15,456 --> 00:49:16,704
先不管它具体是什么
whatever this is.

817
00:49:18,096 --> 00:49:20,720
我们只知道它是一个CLOSURE
That's what that is there, that closure.

818
00:49:22,576 --> 00:49:26,464
将这个过程应用于'(4)
OK? I'm going to apply that to four.

819
00:49:30,288 --> 00:49:31,776
很简单
OK. Well, that's easy enough.

820
00:49:36,830 --> 00:49:38,736
我需要通过复制一个指针
That means I have to make a new environment

821
00:49:38,864 --> 00:49:40,528
就是这个过程的指针
by copying this pointer,

822
00:49:41,568 --> 00:49:43,216
来构造一个新环境
which was the pointer of the procedure,

823
00:49:44,944 --> 00:49:48,960
同时还得把参数Y跟值4绑定
which binds y equal 4 with that environment.

824
00:49:49,824 --> 00:49:52,224
我把这个新环境 记作<E2>
And here's my new environment, which I'll call e2.

825
00:49:56,030 --> 00:49:58,120
当然 这里的这个应用
And, of course, this application then

826
00:49:58,224 --> 00:50:00,336
其过程体的求值 是在<E2>中进行的
is evaluate the body in e2.

827
00:50:01,584 --> 00:50:07,872
所以这就变成了对过程体的求值
So this is eval, the body,

828
00:50:07,900 --> 00:50:11,856
也就是 (EVAL '(+ X Y) <E2>)
which is plus x y, in the environment e2.

829
00:50:13,710 --> 00:50:14,944
但由于这是一个应用
But this is an application,

830
00:50:15,480 --> 00:50:23,888
所以又代换为 (APPLY (EVAL '+ <E2>)
so this is the apply, of eval, plus in e2,

831
00:50:26,336 --> 00:50:37,340
(EVLIST '(X Y) <E2>))
an EVLIST, quote, open, x y, in e2.

832
00:50:44,880 --> 00:50:45,590
我们来看
Well, but let's see.

833
00:50:45,590 --> 00:50:51,712
下一步代换为 (APPLY
That is apply, the object

834
00:50:52,080 --> 00:50:53,872
求值‘+得到的结果
which is a result of that and plus.

835
00:50:54,190 --> 00:50:55,664
所以我们从<E2>开始找
So here we are in e2,

836
00:50:55,696 --> 00:50:57,728
'+既不在<E2> 也不在<E1>
plus is not here, it's not here,

837
00:50:57,744 --> 00:51:01,056
‘+是<E0>中的基本运算符
yes, but's here as some primitive operator.

838
00:51:01,780 --> 00:51:04,745
这个基本运算符是用于加法的
So it's the primitive operator for addition.

839
00:51:07,472 --> 00:51:14,128
把它应用于 在<E2>中求值X和Y的结果
Apply that to the result of evaluating x and y in e2.

840
00:51:14,370 --> 00:51:17,008
我们知道X是3 Y是4
But we can see that x is three and y is four.

841
00:51:18,112 --> 00:51:23,312
所以这里是'(3 4)
So that's a three and four, here.

842
00:51:24,160 --> 00:51:26,280
然后就神奇地得到结果7
And that magically produces for me a seven.

843
00:51:30,520 --> 00:51:32,448
我再来整理一下这个过程 这样你们
I wanted to go through this so you would see,

844
00:51:32,704 --> 00:51:34,736
就能了解这其中的重要本质
essentially, one important ingredient,

845
00:51:35,760 --> 00:51:37,296
这个过程中传递了些什么？
which is what's being passed around,

846
00:51:37,312 --> 00:51:39,568
每个模块持有什么 又负责什么？
and who owns what, and what his job is.

847
00:51:40,470 --> 00:51:41,616
有哪些模块呢？
So what do we have here?

848
00:51:41,700 --> 00:51:42,624
一个是EVAL
We have eval,

849
00:51:44,800 --> 00:51:45,640
还有个APPLY
We have eval, and we have apply,

850
00:51:45,664 --> 00:51:46,624
两个主要角色
the two main players.

851
00:51:49,370 --> 00:51:51,568
它们之间有个像这样的大循环
And there is a big loop the goes around like this.

852
00:51:52,320 --> 00:52:04,576
其中 EVAL为APPLY生成过程和参数
Which is eval produces a procedure and arguments for apply.

853
00:52:06,270 --> 00:52:08,576
也有些事情 EVAL也可以自己做
Now some things eval could do by itself.

854
00:52:09,504 --> 00:52:10,860
都是一些细小的事情
Those are little self things here.

855
00:52:10,860 --> 00:52:11,744
并不十分有趣
They're not interesting.

856
00:52:12,700 --> 00:52:15,600
同时 EVAL也逐个求值所有的参数
Also eval evaluates all of the arguments, one after another.

857
00:52:16,240 --> 00:52:17,280
也没什么意思
That's not very interesting.

858
00:52:17,650 --> 00:52:20,096
APPLY可以应用像+这类的过程
Apply can apply some procedures like plus,

859
00:52:21,024 --> 00:52:22,040
这很普通
not very interesting.

860
00:52:22,300 --> 00:52:24,640
然而 如果APPLY不能应用像+这样的过程
However, if apply can't apply a procedure like plus,

861
00:52:25,312 --> 00:52:33,312
它就为EVAL生成一个表达式及相应的环境
it produces an expression and environment for eval.

862
00:52:35,470 --> 00:52:37,616
过程的参数封装了
The procedural arguments wrap up

863
00:52:38,240 --> 00:52:40,608
计算所必需的状态
essentially the state of a computation

864
00:52:41,664 --> 00:52:43,424
以及相应的环境
and, certainly, the expression of environment.

865
00:52:43,740 --> 00:52:45,312
但我们接下来要做的
And so what we're actually going to do next

866
00:52:45,328 --> 00:52:46,464
并不是完整的状态
is not the complete state,

867
00:52:46,480 --> 00:52:48,820
因为它没有说明谁需要返回的结果
because it doesn't say who wants the answers.

868
00:52:51,280 --> 00:52:52,208
我们要做的就是
But what we're going to do--

869
00:52:52,240 --> 00:52:54,800
总是把某个表达式以及相应的环境
it's always got something like an expression of environment

870
00:52:54,992 --> 00:52:56,144
或者过程对象以及其参数
or procedure and arguments

871
00:52:56,288 --> 00:52:58,080
在这个循环之间不断传递
as the main loop that we're going around.

872
00:52:58,970 --> 00:53:01,808
这里还有一些小型的子循环 比如EVLIST
There are minor little sub loops like eval through EVLIST,

873
00:53:04,496 --> 00:53:06,768
又或者是EVAL中的EVCOND循环
or eval through evcond,

874
00:53:09,104 --> 00:53:11,968
甚至于APPLY调用PRIMITIVE-APPLY
or apply through a primitive apply.

875
00:53:16,140 --> 00:53:17,648
但是它们并不是最主要的
But they're not the essential things.

876
00:53:18,864 --> 00:53:20,288
这整个就是我想让你们看到的
So that's what I wanted you to see.

877
00:53:21,860 --> 00:53:22,880
有什么问题吗？
Are there any questions?

878
00:53:25,930 --> 00:53:27,376
David 请说
Yes. David

879
00:53:27,740 --> 00:53:33,310
学生：我不明白为什么X是3
AUDIENCE: I'm trying to understand how x got down to three

880
00:53:34,016 --> 00:53:36,304
而不是4
instead of four.

881
00:53:37,070 --> 00:53:38,520
在那个部分
At the early part of the--

882
00:53:38,560 --> 00:53:40,544
教授：是在这里
PROFESSOR: Here.

883
00:53:41,310 --> 00:53:43,310
你想知道X是如何跟3绑定的
You want to know how x got down to three?

884
00:53:43,520 --> 00:53:47,424
学生：因为X是外层过程的参数
AUDIENCE: Because x is the outer procedure,

885
00:53:48,464 --> 00:53:50,992
而内层过程中既有X又有Y
and x and y are the inner procedure.

886
00:53:51,264 --> 00:53:51,888
教授：明白了
PROFESSOR: Fine.

887
00:53:52,848 --> 00:53:54,624
代换的过程中 我已经非常小心了
Well, I was very careful and mechanical.

888
00:53:55,020 --> 00:53:56,928
或许首先 我应该把这些过程
First of all, I should write those procedures

889
00:53:56,944 --> 00:53:58,410
重新编排得更易读一点
again for you, pretty printed.

890
00:54:00,610 --> 00:54:01,472
你之所以有所疑惑
First order of business,

891
00:54:01,488 --> 00:54:02,990
或许是因为你把程序看岔了
because you're probably not reading them well.

892
00:54:03,830 --> 00:54:04,704
所以这里应该是
So I have here

893
00:54:05,150 --> 00:54:09,600
一个以X为参数的过程
that procedure of-- was it x over there--

894
00:54:11,216 --> 00:54:14,990
它返回一个以Y为参数的过程
which is -- value of that procedure of y

895
00:54:15,728 --> 00:54:18,440
后者计算X+Y
which adds x to y,

896
00:54:19,824 --> 00:54:21,104
（闭合括号中）
lambda, lambda,

897
00:54:21,408 --> 00:54:22,896
外面的过程应用到3上
applied that to three,

898
00:54:24,080 --> 00:54:26,128
把得到的结果应用到4上
takes the result of that, and applied that to four.

899
00:54:26,140 --> 00:54:28,810
这个和之前那个是一样的 对吧？
Is that not what I wrote? OK?

900
00:54:28,810 --> 00:54:32,336
现在 你可以立马发现
Now, you should immediately see that

901
00:54:33,776 --> 00:54:34,944
这里是一个应用
here is an application--

902
00:54:35,168 --> 00:54:36,464
我先换根白粉笔
let me get a white piece of chalk--

903
00:54:37,328 --> 00:54:41,120
这一部分是应用 是一个组合式
here is an application, a combination.

904
00:54:43,440 --> 00:54:46,400
这部分是组合式的运算符
OK? That combination has this as the operator

905
00:54:48,144 --> 00:54:49,552
而这是运算对象
and this as the operand.

906
00:54:51,040 --> 00:54:53,056
这个3会跟这里的X绑定
The three is going in for the x here.

907
00:54:54,900 --> 00:54:56,368
而这个组合式的结果
The result of this

908
00:54:56,560 --> 00:54:58,464
是一个参数为Y的一元过程
is a procedure of one argument y,

909
00:54:58,736 --> 00:54:59,792
它将应用于4
which gets applied to four.

910
00:55:00,880 --> 00:55:01,584
明白了吧？
OK?

911
00:55:02,208 --> 00:55:04,080
所以你可能只是看岔了
So you just weren't reading the expression right.

912
00:55:04,400 --> 00:55:07,856
而你们在这里看到的
The way you see that over here. OK.

913
00:55:09,424 --> 00:55:12,960
是一个实际的过程对象 它有一个参数X
is that here I have the actual procedure object, x.

914
00:55:13,340 --> 00:55:15,312
这个CLOSURE将应用于3
It's getting applied to three,

915
00:55:15,952 --> 00:55:17,072
也就是'(3)
the list containing three.

916
00:55:18,980 --> 00:55:21,344
得到的结果再应用于'(4)
What I'm left over with is something which gets applied to four.

917
00:55:24,080 --> 00:55:25,200
还有疑问吗？
Are there any other questions?

918
00:55:28,350 --> 00:55:30,384
那就休息一下吧
Time for our next small break then.

919
00:55:30,832 --> 00:55:31,370
谢谢大家
Thank you.

920
00:55:33,730 --> 00:55:41,408
[音乐]
[JESU, JOY OF MAN'S DESIRING]

921
00:55:42,128 --> 00:55:47,440
《计算机程序的构造和解释》

922
00:55:50,700 --> 00:55:54,080
讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授

923
00:55:54,120 --> 00:55:59,168
《计算机程序的构造和解释》

924
00:55:59,232 --> 00:56:03,952
元循环求值器 I

925
00:56:08,410 --> 00:56:11,296
教授：课上到这里
PROFESSOR: Let's see, at this point,

926
00:56:13,328 --> 00:56:14,592
你们可能开始觉得
you should be getting the feeling,

927
00:56:14,752 --> 00:56:17,960
Sussman教授又在胡说八道些什么
what's this nonsense this Sussman character is feeding me?

928
00:56:20,740 --> 00:56:23,920
他讲的东西奇怪、愚蠢又毫无意义
There's an awful lot of strange nonsense here.

929
00:56:24,800 --> 00:56:27,408
他还宣称要给我们解释Lisp
After all, he purported to explain to me Lisp,

930
00:56:28,016 --> 00:56:29,904
然后在黑板上给我们写了一个Lisp程序
and he wrote me a Lisp program on the blackboard.

931
00:56:31,232 --> 00:56:33,536
他还说：“这个Lisp程序就是Lisp解释器”
The Lisp program was intended to be interpreted for Lisp,

932
00:56:33,850 --> 00:56:35,024
但是为了运行这个Lisp程序
but you need a Lisp interpreter

933
00:56:35,040 --> 00:56:36,300
你还先得有一个Lisp解释器啊
in order to understand that program.

934
00:56:38,370 --> 00:56:40,192
那个程序怎么能告诉我
How could that program have told me anything

935
00:56:40,224 --> 00:56:43,200
有关于Lisp的知识呢？
there is to be known about Lisp?

936
00:56:44,150 --> 00:56:46,224
它为什么又不是空中楼阁呢？
How is that not completely vacuous?

937
00:56:48,490 --> 00:56:50,256
这件事非常奇怪
It's a very strange thing.

938
00:56:50,990 --> 00:56:52,430
它究竟告诉了我什么？
Does it tell me anything at all?

939
00:56:56,070 --> 00:56:57,200
我们发现 其实这整件事
Well, you see, the whole thing

940
00:56:57,328 --> 00:56:59,790
非常像我们在这张幻灯片上看到的
is sort of like these Escher's hands

941
00:57:00,464 --> 00:57:03,552
Escher所画的手
that we see on this slide.

942
00:57:06,180 --> 00:57:07,728
是的 EVAL和APPLY
Yes, eval and apply

943
00:57:07,760 --> 00:57:10,160
彼此画出彼此
each sort of draw each other

944
00:57:11,504 --> 00:57:14,160
并且构造出了真实的东西
and construct the real thing,

945
00:57:14,864 --> 00:57:16,304
它完全是自己画出了自己
which can sit out and draw itself.

946
00:57:17,110 --> 00:57:18,464
Escher真是绝顶聪明
Escher was a very brilliant man,

947
00:57:18,688 --> 00:57:20,416
他只不过叫不出这些精灵的名字
he just didn't know the names of these spirits.

948
00:57:23,910 --> 00:57:25,008
我现在要做的就是
Well, I'm going to do now,

949
00:57:26,096 --> 00:57:28,000
使你们相信
is I'm going to try to convince you

950
00:57:28,160 --> 00:57:29,872
这一切都是有意义的
that both this mean something,

951
00:57:30,160 --> 00:57:31,980
并且
and, as a aside,

952
00:57:32,992 --> 00:57:34,720
我将要解释为什么我们不需要DEFINE
I'm going to show you why you don't need definitions.

953
00:57:36,090 --> 00:57:37,712
事实证明 我们并不需要DEFINE
Just turns out that sort of falls out,

954
00:57:38,096 --> 00:57:41,120
为了进行数学意义上的计算
why definitions are not essential in a mathematical sense

955
00:57:42,512 --> 00:57:44,890
DEFINE并不是必需的
for doing all the things we need to do for computing.

956
00:57:49,104 --> 00:57:50,032
我们来看一下
Well, let's see here.

957
00:57:50,690 --> 00:57:53,312
考虑下面的一小段程序
Consider the following small program,

958
00:57:53,744 --> 00:57:54,640
它有什么作用？
what does it mean?

959
00:57:54,870 --> 00:57:57,648
这是一个计算指数的程序
This is a program for computing exponentials.

960
00:58:07,270 --> 00:58:13,232
EXPT计算X的N次方
The exponential of x to the nth power is if--

961
00:58:16,832 --> 00:58:18,128
如果N为0
n is zero,

962
00:58:19,200 --> 00:58:20,768
那么结果就是1
then the result is one.

963
00:58:22,070 --> 00:58:22,816
否则
Otherwise,

964
00:58:25,568 --> 00:58:28,480
结果就是X乘以
I want the product of x

965
00:58:28,752 --> 00:58:33,930
(EXPT X (- N 1))))
and the result of exponentiating x to the n minus one power.

966
00:58:43,696 --> 00:58:44,560
应该没错
I think I got it right.

967
00:58:46,630 --> 00:58:48,720
一个递归定义
Now this is a recursive definition.

968
00:58:49,470 --> 00:58:52,176
用EXPT自身
It's a definition of the exponentiation

969
00:58:52,464 --> 00:58:54,780
来定义EXPT过程自己
procedure in terms of itself.

970
00:58:56,410 --> 00:58:58,320
就像我之前说的那样
And, as it has been mentioned before,

971
00:58:59,280 --> 00:59:01,680
你们高中数学老师在教这些东西的时候
your high school geometry teacher

972
00:59:01,840 --> 00:59:04,048
你们一定学得很痛苦
probably gave you a hard time about things like that.

973
00:59:05,650 --> 00:59:06,736
这样定义合理吗？
Was that justified?

974
00:59:07,910 --> 00:59:10,848
为什么这种自引用的定义
Why does this self referential definition

975
00:59:10,960 --> 00:59:12,040
能够说得通呢？
make any sense?

976
00:59:13,430 --> 00:59:15,104
首先我要说的是
Well, first of all, I'm going to convince you that

977
00:59:15,136 --> 00:59:17,600
你们高中数学老师并非在胡说八道
your high school geometry teacher was not telling you nonsense.

978
00:59:20,370 --> 00:59:23,424
考虑下面的几组定义
Consider the following set of definitions here.

979
00:59:24,270 --> 00:59:27,424
X+Y=3
x plus y equals three,

980
00:59:28,240 --> 00:59:32,240
X-Y=1
and x minus y equal one.

981
00:59:33,070 --> 00:59:35,568
这个方程用Y来告诉你X
Well, gee, this tells you x in terms of y,

982
00:59:35,584 --> 00:59:37,840
而这个方程或许是用X来告诉你Y
and this one tells you y in terms of x, presumably.

983
00:59:40,150 --> 00:59:42,950
碰巧这组方程有唯一的解
And yet this happens to have a unique solution in x and y.

984
00:59:55,910 --> 00:59:58,112
然而 我也可能有这样的方程
However, I could also write

985
00:59:59,872 --> 01:00:04,256
2X+2Y=6
two x plus two y is six.

986
01:00:06,832 --> 01:00:09,872
这两个方程有无穷多个解
These two equations have an infinite number solutions.

987
01:00:15,730 --> 01:00:17,424
我还可以有像这样的方程
And I could write you, for example,

988
01:00:18,896 --> 01:00:21,536
X-Y=2
x minus y equal 2,

989
01:00:22,144 --> 01:00:24,416
而下面的这两个方程没有解
and these two equations have no solutions.

990
01:00:29,820 --> 01:00:33,040
这里 我有三组线性方程组
Well, I have here three sets of simultaneous linear equations,

991
01:00:35,456 --> 01:00:39,510
分别是这组、这组和这组
this set, this set, and this set.

992
01:00:39,888 --> 01:00:41,792
它们的解的数目完全不同
But they have different numbers of solutions.

993
01:00:42,900 --> 01:00:45,760
解的数目并不取决于方程的形式
The number of solutions is not in the form of the equations.

994
01:00:46,336 --> 01:00:48,208
三组方程都有一样的形式
They all three sets have the same form.

995
01:00:48,544 --> 01:00:50,416
解的数目取决于方程的内容
The number of solutions is in the content.

996
01:00:53,000 --> 01:00:55,152
我不能通过观察方程的形式
I can't tell by looking at the form of a definition

997
01:00:55,168 --> 01:00:56,240
来判断解的数目
whether it makes sense,

998
01:00:56,864 --> 01:00:58,608
必须要看它的内容
only by its detailed content.

999
01:00:59,660 --> 01:01:00,880
比如 对于线性方程组
What are the coefficients,

1000
01:01:01,344 --> 01:01:03,392
它的系数都是什么？
for example, in the case of linear equations?

1001
01:01:05,100 --> 01:01:06,720
我不能够通过观察
So I shouldn't expect to be able to tell

1002
01:01:06,992 --> 01:01:08,336
像这样的简单情况
looking at something like this,

1003
01:01:08,592 --> 01:01:09,952
来判定
from some simple things like,

1004
01:01:10,080 --> 01:01:14,496
EXPT就是这个递归方程的解
oh yes, EXPT is the solution of this recursion equation.

1005
01:01:16,030 --> 01:01:18,416
我不能说 EXPT就是那个过程
Expt is the procedure

1006
01:01:18,912 --> 01:01:21,104
如果我们把它代换入其中
which if substituted in here,

1007
01:01:22,048 --> 01:01:24,064
它就能给我们返回EXPT
gives me expt back.

1008
01:01:25,328 --> 01:01:25,680
能跟上吗？
OK?

1009
01:01:26,040 --> 01:01:29,248
通过观察这个形式 我也无法判别
I can't tell, looking at this form,

1010
01:01:29,808 --> 01:01:32,608
EXPT是否有唯一解
whether or not there's a single, unique solution for EXPT,

1011
01:01:33,232 --> 01:01:35,312
有无穷个解 还是根本没有解
an infinite number of solutions, or no solutions.

1012
01:01:37,200 --> 01:01:38,624
我们要了解它是如何计数的
It's got to be how it counts

1013
01:01:38,640 --> 01:01:40,144
或者是一些类似的计算细节
and things like that, the details.

1014
01:01:40,608 --> 01:01:42,752
这可比在线性代数难多了
And it's harder in programming than linear algebra.

1015
01:01:43,280 --> 01:01:45,210
程序设计中可用的定理并不多
There aren't too many theorems about it in programming.

1016
01:01:48,450 --> 01:01:51,216
我想把这些方程稍稍重写一下
Well, I want to rewrite these equations a little bit,

1017
01:01:51,936 --> 01:01:53,776
就是这里的方程
these over here.

1018
01:01:53,970 --> 01:01:56,624
因为我们要研究的是这种形式的方程
Because what we're investigating is equations like this.

1019
01:01:57,000 --> 01:01:58,384
但是我想用我们比较了解的方程
But I want to play a little with equations

1020
01:01:58,400 --> 01:01:59,530
来做演示
like this that we understand,

1021
01:02:00,704 --> 01:02:02,912
以便于对于这类问题有深入的洞见
just so we get some insight into this kind of question.

1022
01:02:04,720 --> 01:02:06,432
我们可以把这里的方程 改写为
We could rewrite our equations here,

1023
01:02:06,752 --> 01:02:08,672
这样的一种有趣形式
say these two, the ones that are interesting,

1024
01:02:09,776 --> 01:02:14,864
X=3-Y
as x equals three minus y,

1025
01:02:15,888 --> 01:02:19,680
Y=X-1
and y equals x minus one.

1026
01:02:22,010 --> 01:02:24,050
我们把这种变换叫什么来着？
What do we call this transformation?

1027
01:02:24,050 --> 01:02:26,528
这是一个线性变换 记为T
This is a linear transformation, t.

1028
01:02:29,430 --> 01:02:32,256
我们这里就得到了一个方程
Then what we're getting here is an equation

1029
01:02:32,976 --> 01:02:37,370
<X Y> = T<X Y>
x y equals t of x y.

1030
01:02:42,990 --> 01:02:43,984
我要去找什么呢？
What am I looking for?

1031
01:02:44,560 --> 01:02:46,016
我在找T的不动点
I'm looking for a fixed point of t.

1032
01:02:46,976 --> 01:02:59,424
T的不动点就是方程的解
The solution is a fixed point of t.

1033
01:03:01,910 --> 01:03:05,536
所以 如果我们能通过找不动点
So the methods we should have for looking for solutions to equations,

1034
01:03:05,904 --> 01:03:07,488
来求解方程
if I can do it by fixed points,

1035
01:03:08,656 --> 01:03:09,872
这看来是可行的
might be applicable.

1036
01:03:10,880 --> 01:03:12,368
如果我可以用不动点
If I have a means of finding a solution

1037
01:03:12,384 --> 01:03:14,320
来求解方程
to an equations by fixed points--

1038
01:03:15,520 --> 01:03:18,192
当然 也许它不可行
just, might not work--

1039
01:03:18,570 --> 01:03:19,800
不过也可以借鉴来
but it might be applicable

1040
01:03:20,096 --> 01:03:22,272
研究如何求解这类方程
to investigating solutions of equations like this.

1041
01:03:27,240 --> 01:03:29,488
重要的是 我想让你们把它看成一个方程
But what I want you to feel is that this is an equation.

1042
01:03:30,260 --> 01:03:31,216
它是一个表达式
It's an expression

1043
01:03:31,360 --> 01:03:33,580
其中有不同的变量
with several instances of various names

1044
01:03:34,704 --> 01:03:37,664
只不过这些名字还得满足一定的约束
which puts a constraint on the name,

1045
01:03:38,432 --> 01:03:40,528
这些名字限定了对应变量的取值
saying what that name could have as its value,

1046
01:03:41,488 --> 01:03:45,010
我们不能够随意、机械地代换
rather than some sort of mechanical process of substitution right now.

1047
01:03:47,740 --> 01:03:49,776
这就是我尝试求解的方程
This is an equation which I'm going to try to solve.

1048
01:03:51,220 --> 01:03:52,432
我们来试试看
Well, let's play around and solve it.

1049
01:03:53,960 --> 01:03:55,664
首先我需要写下
First of all, I want to write down

1050
01:03:56,640 --> 01:03:59,008
跟T相对应的函数
the function which corresponds to t.

1051
01:04:00,320 --> 01:04:03,008
我写下的这个T对应的函数
First I want to write down the function which corresponds to t

1052
01:04:04,496 --> 01:04:06,960
它的不动点就是这个方程的解
whose fixed point is the answer to this question.

1053
01:04:10,760 --> 01:04:11,280
能明白吗？
OK?

1054
01:04:12,256 --> 01:04:14,304
让我们来看下面这个过程F
Well, let's consider the following procedure f.

1055
01:04:16,870 --> 01:04:18,304
我说 F计算的是这样一个函数
I claim it computes that function.

1056
01:04:19,340 --> 01:04:22,912
F本身是一个参数为G的一元过程
f is that procedure of one argument g,

1057
01:04:25,232 --> 01:04:25,936
它返回
which is

1058
01:04:26,400 --> 01:04:32,000
一个参数为X和N的过程
that procedure of two arguments x and n.

1059
01:04:33,430 --> 01:04:34,736
这个过程的定义是：
Which have the property that

1060
01:04:36,720 --> 01:04:40,432
如果N为0
if n is zero,

1061
01:04:41,728 --> 01:04:43,200
那么结果就是1
then the result is one,

1062
01:04:45,344 --> 01:04:46,176
否则的话
otherwise,

1063
01:04:49,900 --> 01:05:01,408
结果就是(* X (G X (- N 1)))
the result is the product of x and g, applied to x, and minus n1.

1064
01:05:03,370 --> 01:05:07,808
（闭合括号中）
g, times, else, COND, lambda, lambda--

1065
01:05:08,944 --> 01:05:09,408
没问题吧
OK?

1066
01:05:12,304 --> 01:05:14,624
这里 F是一个过程
Here f is a procedure,

1067
01:05:15,050 --> 01:05:17,792
如果我能解出这个方程
which if I had a solution to that equation,

1068
01:05:19,040 --> 01:05:22,048
如果我找到了一个良好的指数过程
if I had a good exponentiation procedure,

1069
01:05:23,420 --> 01:05:26,320
我把这个F应用到那个过程上
and I applied f to that procedure,

1070
01:05:27,600 --> 01:05:31,248
那么返回的应该也是一个良好的指数过程
then the result would be a good exponentiation procedure.

1071
01:05:37,460 --> 01:05:38,576
这是为什么呢？
Because, what does it do?

1072
01:05:39,420 --> 01:05:40,880
这是因为
Well, all it is

1073
01:05:42,368 --> 01:05:44,640
F假设G是一个良好的指数过程
is exposing g were a good exponentiation procedure,

1074
01:05:45,632 --> 01:05:47,584
那么这里就会返回
well then this would produce, as its value,

1075
01:05:47,840 --> 01:05:49,680
一个参数为X和N的过程
a procedure to arguments x and n,

1076
01:05:50,490 --> 01:05:51,520
其中如果N=0
such that if n were 0,

1077
01:05:51,552 --> 01:05:52,416
结果就是1
the result would be one,

1078
01:05:52,448 --> 01:05:54,160
这是非常符合定义的
which is certainly true of exponentiation.

1079
01:05:54,640 --> 01:05:57,056
否则 就返回X乘以
Otherwise, it will be the result of multiplying x

1080
01:05:57,264 --> 01:05:59,264
用给定的指数过程G
by the exponentiation procedure given to me

1081
01:06:00,176 --> 01:06:02,448
计算(G X (- N 1))
with x and n minus one as arguments.

1082
01:06:03,470 --> 01:06:04,784
因此如果G能够
So if this computed the correct

1083
01:06:04,816 --> 01:06:06,300
正确计算X^(N-1)
exponentiation for n minus one,

1084
01:06:07,872 --> 01:06:11,280
那么这个表达式就能正确计算X^N
then this would be the correct exponentiation for exponent n,

1085
01:06:12,176 --> 01:06:14,416
所以整个就会是一个正确的求指数过程
so this would have been the right exponentiation procedure.

1086
01:06:17,500 --> 01:06:19,824
因此 我在这里真正想指出的是
So what I really want to say here is

1087
01:06:21,020 --> 01:06:32,448
过程EXPT是函数F的不动点
E-X-P-T is a fixed point of f.

1088
01:06:36,990 --> 01:06:38,352
现在我们的问题在于
Now our problem is

1089
01:06:38,352 --> 01:06:39,680
不动点可能不止一个
there might be more than one fixed point.

1090
01:06:40,060 --> 01:06:42,192
也可能没有不动点
There might be no fixed points.

1091
01:06:43,270 --> 01:06:44,810
所以我们必须求出不动点
I have to go hunting for the fixed points.

1092
01:06:48,224 --> 01:06:49,376
需要来解这个方程
Got to solve this equation.

1093
01:06:52,160 --> 01:06:54,288
求不动点的方法有很多种
Well there are various ways to hunt for fixed points.

1094
01:06:55,580 --> 01:06:57,088
本门课程的第一节课
Of course, the one we played with

1095
01:06:57,248 --> 01:07:01,160
我们就用余弦函数做了演示
at the beginning of this term worked for cosine.

1096
01:07:02,736 --> 01:07:07,690
先把你的计算器调成弧度制
Going to. Go into radians mode on your calculator

1097
01:07:07,856 --> 01:07:10,512
然后一直按COS键
and push cosine, and just keep doing it,

1098
01:07:11,840 --> 01:07:15,456
最后数字会稳定在0.73、0.74左右
and you get to some number which is about 0.73 or 0.74.

1099
01:07:16,090 --> 01:07:17,184
我记不清是哪个了
I can't remember which.

1100
01:07:20,576 --> 01:07:22,640
通过迭代一个过程
By iterating a procedure, which has

1101
01:07:22,816 --> 01:07:24,400
我们不断迭代
By iterating a function,

1102
01:07:25,600 --> 01:07:27,168
想要寻找不动点的函数
whose fixed point I'm searching for,

1103
01:07:27,500 --> 01:07:31,136
有时候 它就会收敛在一个点上
it is sometimes the case that that function will converge

1104
01:07:31,872 --> 01:07:33,088
这就是不动点
in producing the fixed point.

1105
01:07:33,770 --> 01:07:35,440
碰碰运气
I think we luck out in this case,

1106
01:07:36,448 --> 01:07:37,216
来试试这种方法
so let's look for it.

1107
01:07:39,910 --> 01:07:46,288
来看这张幻灯片
Let's look at this overhead, this slide.

1108
01:07:48,030 --> 01:07:51,712
考虑这么一连串的过程
Consider the following sequence of procedures.

1109
01:07:56,400 --> 01:07:57,792
这里的E0
e0 over here

1110
01:07:59,248 --> 01:08:01,632
这个E0过程什么也不做
the procedure which does nothing at all.

1111
01:08:02,890 --> 01:08:05,104
无论你给它传递什么参数
It's the procedure which produces an error

1112
01:08:05,104 --> 01:08:06,240
它都会产生ERROR
for any arguments you give it.

1113
01:08:07,780 --> 01:08:09,030
基本上没什么用
It's basically useless.

1114
01:08:14,480 --> 01:08:20,080
然而 我可以做近似
Well, however, I can make an approximation.

1115
01:08:20,080 --> 01:08:23,936
让我们考虑下 指数过程的最差近似
Let's consider it the worst possible approximation to exponentiation,

1116
01:08:24,736 --> 01:08:25,536
因为它什么也做不了
because it does nothing.

1117
01:08:26,990 --> 01:08:29,680
假设我调用F
Well, supposing I substituted e0

1118
01:08:30,352 --> 01:08:33,260
用E0去代换G
for g by calling f,

1119
01:08:33,792 --> 01:08:36,304
这里 G就被代换为了E0
as you see over here on e0.

1120
01:08:37,380 --> 01:08:39,776
所以在这里就是E0
So you see over here, have e0 there.

1121
01:08:40,848 --> 01:08:42,352
那么E1又成了什么呢？
Then gee, what's e1?

1122
01:08:43,630 --> 01:08:46,032
如果用E1来计算X^0
e1 is a procedure which exponentiate things

1123
01:08:46,672 --> 01:08:48,784
没什么问题
to the 0th power, with no trouble.

1124
01:08:49,600 --> 01:08:50,752
它返回的结果是正确的
It gets the right answer,

1125
01:08:51,050 --> 01:08:52,352
任何数的0次幂都是1
anything to the zero is one,

1126
01:08:52,688 --> 01:08:54,250
然而计算其它次幂就会出错
and it makes an error on anything else.

1127
01:08:57,390 --> 01:09:01,568
现在如果我用E1来调用F
Well, now what if I take e1

1128
01:09:02,304 --> 01:09:07,408
把G代换为E1 会发生什么？
and substituted it for g by calling f on e1?

1129
01:09:09,580 --> 01:09:11,180
这样的话
Oh gosh,

1130
01:09:12,016 --> 01:09:15,024
我就会得到这个二元过程
I have here a procedure of two arguments.

1131
01:09:15,670 --> 01:09:16,848
想一想 E1这个过程
Now remember e1

1132
01:09:16,960 --> 01:09:19,664
只能正确计算X^0
was appropriate for taking exponentiations of 0,

1133
01:09:21,472 --> 01:09:23,376
它只能计算0次幂
for raising to the 0 exponent.

1134
01:09:24,200 --> 01:09:25,008
所以这里
So here,

1135
01:09:25,520 --> 01:09:27,280
如果N为0 结果就是1
if is n is 0, the result is one,

1136
01:09:27,296 --> 01:09:28,672
E2的这部分也正确
so this guy is good for that too.

1137
01:09:29,520 --> 01:09:32,016
然而 我可以通过把0次幂乘以X
However, I can use something for raising to the 0th power

1138
01:09:32,512 --> 01:09:35,264
来计算1次幂
to multiply it by x to raise something to the first power.

1139
01:09:35,979 --> 01:09:39,670
所以E2可以正确计算0次幂和1次幂
So e2 is good for both power 0 and 1.

1140
01:09:41,600 --> 01:09:41,920
对吧？
OK?

1141
01:09:43,712 --> 01:09:46,672
E3的构造过程和E2是类似的
And e3 is constructed from e2 in the same way.

1142
01:09:47,890 --> 01:09:50,240
当然 E3具有同样的参数
And e3, of course, by the same argument

1143
01:09:50,320 --> 01:09:53,370
能够正确计算0、1、2次幂
is good for powers 0, one, and two.

1144
01:09:55,120 --> 01:09:55,408
对吧？
OK?

1145
01:09:56,090 --> 01:09:59,080
因此我就不加证明地告诉你结论
And so I will assert for you, without proof,

1146
01:09:59,664 --> 01:10:01,728
因为这个证明过程太难了
because the proof is horribly difficult.

1147
01:10:02,520 --> 01:10:03,600
这种事情
And that's the sort of thing that

1148
01:10:03,632 --> 01:10:06,368
是由人们所谓“指称语义学家”完成的
people called denotational semanticists do.

1149
01:10:06,590 --> 01:10:07,648
这个伟大的想法
I suppose it was invented

1150
01:10:07,872 --> 01:10:10,592
应该是由Scott和Strachey提出的
This great idea was invented by Scott and Strachey.

1151
01:10:11,648 --> 01:10:16,320
他们是非常著名的数学家
Ah, sort of. They're very famous mathematician types

1152
01:10:16,864 --> 01:10:21,216
他们发明了这些程序的解释方式
who invented the interpretation for these programs that we have

1153
01:10:22,368 --> 01:10:24,000
就是我刚才讲的那些
that I'm talking to you about right now.

1154
01:10:24,240 --> 01:10:26,176
他们通过拓扑学的方法证明了
And they proved, by topology

1155
01:10:27,040 --> 01:10:29,328
在我们刚才那种情况下
that there is such a fixed point

1156
01:10:29,824 --> 01:10:31,264
不动点是存在的
in the cases that we want.

1157
01:10:32,220 --> 01:10:33,248
这个结论就是：
But the assertion is

1158
01:10:33,400 --> 01:10:44,240
当N趋近于无穷时 EXPT是E(N)的极限
E-X-P-T is limit as n goes to infinity of em.

1159
01:10:45,520 --> 01:10:47,900
我们是通过下面这种方式来构造这个极限的
and And that we've constructed this by the following way.

1160
01:10:50,520 --> 01:10:55,664
EXPT=(F (F (F (F ....
--is Well, it's f of, f of, f of, f of, f of--

1161
01:10:57,616 --> 01:11:00,192
(F 丄)
f applied to anything at all.

1162
01:11:01,120 --> 01:11:02,464
它是什么都无所谓
It didn't matter what that was,

1163
01:11:03,184 --> 01:11:05,008
因为它总会生成一个错误
because, in fact, this always produces an error.

1164
01:11:07,456 --> 01:11:08,416
（闭合括号中）
Applied to this--

1165
01:11:12,896 --> 01:11:14,480
这是F无穷嵌套调用
That's by infinite nesting of f's.

1166
01:11:16,380 --> 01:11:17,712
现在我们的问题
So now my problem

1167
01:11:18,224 --> 01:11:19,760
又变成了如何构造出无穷调用
is to make some infinite things.

1168
01:11:22,590 --> 01:11:24,080
我们需要它们
We need some infinite things.

1169
01:11:24,920 --> 01:11:26,256
我怎样才能把F
How am I going to nest up an f

1170
01:11:26,560 --> 01:11:27,808
嵌套无穷层呢？
an infinite number of times?

1171
01:11:28,980 --> 01:11:30,128
我得把它构造出来
I'd better construct this.

1172
01:11:32,380 --> 01:11:32,930
好吧 我不知道
Well, I don't know.

1173
01:11:32,930 --> 01:11:34,320
到底怎么样构建一个无穷循环呢？
How would I make an infinite loop at all?

1174
01:11:34,810 --> 01:11:36,320
我们先来看个非常简单的无穷循环
Let's take a very simple infinite loop,

1175
01:11:36,576 --> 01:11:38,340
能想到的最简单的无穷循环
the simplest infinite loop imaginable.

1176
01:11:43,550 --> 01:11:47,552
把这样一个参数为X的函数过程
If I were to take that procedure of one argument x

1177
01:11:48,000 --> 01:11:49,792
过程体是(X X)
which applies x to x

1178
01:11:53,552 --> 01:11:53,920
看到了吧？
OK?

1179
01:11:55,056 --> 01:11:58,416
应用在一个参数为X过程上
and apply that to the procedure of one argument x

1180
01:11:59,360 --> 01:12:01,056
后者的过程体也是(X X)
which applies x to x,

1181
01:12:04,832 --> 01:12:06,000
这就形成了一个无穷循环
then this is an infinite loop.

1182
01:12:07,216 --> 01:12:09,312
这个循环之所以是无穷的
The reason why this is an infinite loop is as follows.

1183
01:12:09,980 --> 01:12:11,312
是因为
The way I understand this

1184
01:12:11,520 --> 01:12:13,696
我用实际参数代换掉
is I substitute the argument

1185
01:12:14,224 --> 01:12:16,592
过程体的形式参数
for the formal parameter in the body.

1186
01:12:18,850 --> 01:12:21,600
这样做了以后 这里的每个X
But if I do that, I take for each of these x's,

1187
01:12:22,400 --> 01:12:23,760
都被代换为了这个
I substitute one of these,

1188
01:12:24,368 --> 01:12:26,960
相当于把最初的表达式又复制了一遍
making a copy of the original expression I just started with,

1189
01:12:28,352 --> 01:12:29,376
这就是最简单的无穷循环
the simplest infinite loop.

1190
01:12:35,440 --> 01:12:39,296
现在 我要介绍一个特殊的运算符
Now I want to tell you about a particular operator

1191
01:12:40,384 --> 01:12:43,090
它是通过对这个无穷循环稍作修改而来
which is constructed by a perturbation from this infinite loop.

1192
01:12:46,960 --> 01:12:47,920
我把它记作“Y”
I'll call it y.

1193
01:12:50,896 --> 01:12:55,820
它的全称是：Curry的矛盾Y组合子
OK y -- This is called Curry's Paradoxical Combinator of y

1194
01:12:56,624 --> 01:12:58,992
这是用二十世纪三十年代的逻辑学家
after a fellow by the name of Curry,

1195
01:12:59,344 --> 01:13:01,856
Curry的名字来命名的
who was a logician of the 1930s also.

1196
01:13:04,480 --> 01:13:06,880
Y组合子是一个参数为f的过程
And if I have a procedure of one argument f,

1197
01:13:08,176 --> 01:13:09,330
它的过程体是什么呢？
what's it going to have in it?

1198
01:13:09,330 --> 01:13:11,200
它的内部是某种无穷循环
It's going to have a kind of infinite loop in it,

1199
01:13:11,984 --> 01:13:15,472
是一个参数为x的过程
which is that procedure of one argument x

1200
01:13:15,952 --> 01:13:18,800
它调用(f (x x))
which applies f to x of x,

1201
01:13:21,630 --> 01:13:24,750
这个过程应用在一个参数为X的过程上
applied to that procedure of one argument x,

1202
01:13:25,104 --> 01:13:27,344
后者调用(f (x x))
which applies f to f of x.

1203
01:13:32,300 --> 01:13:33,136
这个是怎么运作的？
Now what's this do?

1204
01:13:34,800 --> 01:13:36,060
假设执行(Y F)
Suppose we apply y to F.

1205
01:13:41,312 --> 01:13:42,576
这非常简单
OK? Well, that's easy enough.

1206
01:13:43,152 --> 01:13:44,624
这里大写的F跟那边的是同一个
That's this capital F over here.

1207
01:13:46,910 --> 01:13:48,160
在这里 很简单
Well, the easiest thing to say there

1208
01:13:48,304 --> 01:13:49,920
我把F代换到这里来
is, I substitute F for here.

1209
01:13:55,320 --> 01:13:57,072
基本上 我就会得到
So that's going to give me, basically--

1210
01:13:58,750 --> 01:14:00,848
因为我待会儿要用这个表达式
because then I'm going to substitute this

1211
01:14:01,456 --> 01:14:02,800
代换这里的x
for x in here.

1212
01:14:04,176 --> 01:14:05,232
这里就是(F
That F of

1213
01:14:08,970 --> 01:14:10,096
我还是把这步写出来吧
Let me actually do it in steps,

1214
01:14:10,224 --> 01:14:11,456
这样你们就能看得更全面
so you can see it completely.

1215
01:14:11,920 --> 01:14:14,272
我会非常小心 好吗？
I'm going to be very careful. OK?

1216
01:14:15,020 --> 01:14:18,256
这里是 ((LAMBDA (x)
This is open, open, lambda of x ,

1217
01:14:19,088 --> 01:14:22,112
(F (x x))
capital F, x, x,

1218
01:14:26,880 --> 01:14:35,552
把它应用到自身 (LAMBDA (x) (F (x x)))
applied to itself, F of x of x.

1219
01:14:37,910 --> 01:14:39,664
把这个表达式代换进去
Substituting this for this in here,

1220
01:14:40,064 --> 01:14:40,912
就得到
this is

1221
01:14:43,130 --> 01:14:48,352
把这个代进去 得到什么呢？
F applied to-- what is it-- substituting this in here

1222
01:14:48,656 --> 01:14:54,810
(F (LAMBDA (x) (F (x x)))
open, open, lambda of x, F, of x and x,

1223
01:14:57,072 --> 01:14:58,176
应用到
applied to

1224
01:14:59,180 --> 01:15:06,480
(LAMBDA (x) (F (x x))))
lambda of x, F of x of x, F,

1225
01:15:06,992 --> 01:15:10,448
（闭合括号中）
lambda, pair, F.

1226
01:15:11,510 --> 01:15:12,400
哇 这又是什么？
Oh, but what is this?

1227
01:15:13,420 --> 01:15:16,352
我刚才计算的这一部分
This thing over here that I just computed,

1228
01:15:17,136 --> 01:15:18,560
就是这里的这部分
is this thing over here.

1229
01:15:20,192 --> 01:15:21,840
只不过它被包在另一个F里面
But I just wrapped another F around it.

1230
01:15:23,370 --> 01:15:24,672
因此 通过把Y应用在F上
So by applying y to F,

1231
01:15:24,688 --> 01:15:26,224
我构造出了F的无穷嵌套
I make an infinite series of F's.

1232
01:15:27,850 --> 01:15:29,450
我如果让它一直这样进行下去
If I just let this run forever,

1233
01:15:29,696 --> 01:15:31,776
我在外层就会得到越来越多的F
I'll just keep making more and more F's outside.

1234
01:15:33,170 --> 01:15:34,800
我运行一个无用的循环
I ran an infinite loop which is useless,

1235
01:15:35,200 --> 01:15:37,024
但内部是无用的并不重要
but it doesn't matter that the inside is useless.

1236
01:15:39,856 --> 01:15:47,856
因此 我们有 (Y F)=(F (Y F))
OK? So y of F is F applied to y of F.

1237
01:15:50,336 --> 01:15:52,144
Y组合子十分神奇
So y is a magical thing

1238
01:15:53,856 --> 01:15:56,256
如果把它应用于某个函数
which, when applied to some function,

1239
01:15:57,376 --> 01:16:00,384
它就会返回这个函数的不动点
produces the object which is the fixed point of that function,

1240
01:16:01,696 --> 01:16:04,256
当然是在不动点存在的前提下
if it exists, and if this all works.

1241
01:16:07,910 --> 01:16:10,080
这是因为 如果我把(Y F)带入F
Because, indeed, if I take y of F

1242
01:16:10,128 --> 01:16:11,120
结果还是(Y F)
I get y of F out.

1243
01:16:16,240 --> 01:16:18,864
现在我想让你们在
Now I want you to think this in terms of

1244
01:16:19,856 --> 01:16:22,384
EVAL-APPLY解释器方面思考一下
the eval-apply interpreter for a bit.

1245
01:16:23,860 --> 01:16:26,272
我在这里写了一大堆递归方程组
I wrote down a whole bunch of recursion equations out there.

1246
01:16:28,540 --> 01:16:30,224
那些联立方程组像
They're simultaneous in the same way

1247
01:16:30,224 --> 01:16:31,232
这些方程一样联立起来
these are simultaneous equations.

1248
01:16:31,470 --> 01:16:33,310
但EXPT不是联立方程
Exponentiation was not a simultaneous equation.

1249
01:16:33,310 --> 01:16:35,792
只是一个需要我赋义的变量
It was only one variable I was looking for a meaning for.

1250
01:16:38,150 --> 01:16:40,768
而Lisp则是某个过程的不动点
But what Lisp is is the fixed point of the process

1251
01:16:40,816 --> 01:16:42,570
对这个过程来说 如果我知道Lisp的定义
that's which says, if I knew what Lisp was

1252
01:16:42,592 --> 01:16:46,512
然后在递归方程等号的右边
and substituted it in for eval, and apply, and so on,

1253
01:16:46,590 --> 01:16:49,792
用它来代换EVAL、APPLY等变量
on the right hand sides of all those recursion equations,

1254
01:16:50,940 --> 01:16:53,968
如果它是一个良好定义的Lisp的话
then if it was a real good Lisp, is a real one,

1255
01:16:54,368 --> 01:16:56,304
那么递归方程等号左边 也是一个良好定义的Lisp
then the left hand side would also be Lisp.

1256
01:16:58,220 --> 01:16:59,824
这样 那个定义就讲得通了
So I made sense of that definition.

1257
01:17:02,420 --> 01:17:05,410
不过是否有解却不太明显
Now whether or not there's an answer isn't so obvious.

1258
01:17:05,696 --> 01:17:06,752
我也说不清
I can't attack that.

1259
01:17:07,740 --> 01:17:09,216
现在我要介绍的论证
Now these arguments that I'm giving you now

1260
01:17:09,264 --> 01:17:10,272
相当危险
are quite dangerous.

1261
01:17:10,660 --> 01:17:11,648
具体看这里
Let's look over here.

1262
01:17:13,056 --> 01:17:14,610
这些是关于极限的论证
On the. These are limit arguments.

1263
01:17:14,610 --> 01:17:15,392
我们要讨论的极限
We're talking about limits,

1264
01:17:15,456 --> 01:17:17,680
是微积分或者拓扑学的概念
and it's really calculus, or topology,

1265
01:17:17,872 --> 01:17:20,032
或者说是类似的 数学分析中的概念
or something like that, a kind of analysis.

1266
01:17:20,768 --> 01:17:23,380
这个论证是你们都承认的
OK？Now here's an argument that you all believe.

1267
01:17:23,380 --> 01:17:25,296
我想让你们意识到
And I want to make sure you realize

1268
01:17:25,424 --> 01:17:27,664
我可以把你们耍得团团转
that I could be bullshitting you.

1269
01:17:28,864 --> 01:17:30,480
准备好了吗？ 这是什么？
Alright? What is this?

1270
01:17:34,250 --> 01:17:39,520
u = 1 + 1/2 + 1/4 + .......
u is the sum of 1/2, 1/4, and 1/8, and so on,

1271
01:17:39,744 --> 01:17:41,328
这是几何级数求和
the sum of a geometric series.

1272
01:17:42,820 --> 01:17:44,688
当然 我也可以耍点小把戏
And, of course, I could play a game here.

1273
01:17:44,820 --> 01:17:47,570
u - 1 = 1/2 + 1/4 + 1/8 ......
u minus one is 1/2, plus 1/4, plus 1/8, and so on.

1274
01:17:51,904 --> 01:17:54,464
这里我可以
But now if I multiple. What I could do here--

1275
01:17:56,096 --> 01:17:57,936
糟糕了 这里漏掉了括号
Ooops. There is a parentheses error here.

1276
01:17:58,920 --> 01:18:01,456
这里应该是
But I can put here two times u minus one

1277
01:18:01,744 --> 01:18:03,990
2(u - 1) = 1 + 1/2 + 1/4 + 1/8 ........
is one plus 1/2, plus 1/4, plus 1/8.

1278
01:18:07,570 --> 01:18:08,544
这里能修改一下吗？
Can I fix that?

1279
01:18:14,010 --> 01:18:16,430
哦 可以
Yes, well.

1280
01:18:18,192 --> 01:18:18,656
看到了吗？
OK?

1281
01:18:19,520 --> 01:18:20,640
这样 我就得到
But that gives me back

1282
01:18:23,536 --> 01:18:26,640
2(u - 1) = u
two times u minus one is u,

1283
01:18:27,808 --> 01:18:29,584
因此我们推断出 u=2
therefore, we conclude that u is two.

1284
01:18:30,300 --> 01:18:31,376
这是正确的
And this actually is true.

1285
01:18:31,968 --> 01:18:33,328
这个推理过程没有问题
There's no problem like that.

1286
01:18:34,048 --> 01:18:37,552
但如果我要是做点别的什么呢？
But supposing I did something different.

1287
01:18:38,540 --> 01:18:39,488
假设我要求和的式子
Supposing I start up with something

1288
01:18:39,504 --> 01:18:41,200
明显没有和
which manifestly has no sum.

1289
01:18:41,568 --> 01:18:46,992
v = 1 + 2 + 4 + ........
v is one, plus two, plus four, plus 8, plus dot, dot, dot. OK?

1290
01:18:47,390 --> 01:18:51,392
v - 1 = 2 + 4 + 8 + ......
Well, v minus one is surely two, plus four, plus eight, plus dot, dot, dot. Right?

1291
01:18:52,272 --> 01:18:56,032
(v - 1)/2 = v
v minus one over two, gee, that looks like v again.

1292
01:18:57,410 --> 01:19:00,544
这里我就可以推断出
From that I should be able to conclude that--

1293
01:19:01,376 --> 01:19:02,912
显然这里又写错了
that's also wrong, apparently.

1294
01:19:03,070 --> 01:19:04,510
应该是 v = -1
v equals minus one.

1295
01:19:12,450 --> 01:19:13,824
这里应该是-1
That should be a minus one.

1296
01:19:15,280 --> 01:19:16,912
这个结论明显是错误的
And that's certainly a false conclusion.

1297
01:19:22,000 --> 01:19:23,472
当你处理极限的时候
So when you play with limits,

1298
01:19:24,224 --> 01:19:27,856
在某种方式下可行的论证
arguments that may work in one case

1299
01:19:29,424 --> 01:19:30,750
在其它情况下可能又不行了
they may not work in some other case.

1300
01:19:30,750 --> 01:19:31,696
要多加注意
You have to be very careful.

1301
01:19:32,240 --> 01:19:33,872
参数必须具有良好的形式
The arguments have to be well-formed.

1302
01:19:36,144 --> 01:19:39,232
但我不清楚 通常来说
And I don't know, in general,

1303
01:19:39,856 --> 01:19:41,936
像这样的论证有什么样的要求
what the story is about arguments like this.

1304
01:19:43,270 --> 01:19:45,248
我们要研习一大堆拓扑学文献来寻找答案
We can read a pile of topology and find out.

1305
01:19:46,272 --> 01:19:48,640
但是至少你们现在理解了
But, surely, at least you understand now,

1306
01:19:49,104 --> 01:19:51,136
为什么我们在黑板上写的这些东西
why it might be some meaning

1307
01:19:51,152 --> 01:19:52,768
是有一定语义的
to the things we've been writing on the blackboard.

1308
01:19:53,664 --> 01:19:55,616
你们也理解了它的语义
And you understand what that might mean.

1309
01:19:56,480 --> 01:19:58,352
我想现在是时候
So, I suppose, it's almost about time

1310
01:19:59,070 --> 01:20:03,840
祝贺你们成为
for you to merit being made a member

1311
01:20:04,280 --> 01:20:05,552
神圣的递归秩序中的
of the grand recursive order

1312
01:20:05,568 --> 01:20:07,040
一名LAMBDA演算黑客了
of lambda calculus hackers.

1313
01:20:08,848 --> 01:20:10,176
这是我们的徽章
I would. This is the badge.

1314
01:20:10,820 --> 01:20:12,544
因为你已经理解了
Because you now understand, for example,

1315
01:20:13,400 --> 01:20:15,200
它上面的那句话
what it says at the very top,

1316
01:20:16,896 --> 01:20:18,416
(Y F) = (F (Y F))
y F equals F y F.

1317
01:20:21,040 --> 01:20:21,664
这节课讲完了
Thank you.

1318
01:20:21,856 --> 01:20:22,752
有什么问题吗？
Are there any questions?

1319
01:20:24,710 --> 01:20:25,150
Lev 请说
Yes, Lev.

1320
01:20:25,370 --> 01:20:27,392
学生：目前的状况来看
AUDIENCE: With this, it seems that

1321
01:20:27,408 --> 01:20:30,224
正如你指出的那样 我们不再需要DEFINE
there's no need to define, as you imply,

1322
01:20:30,240 --> 01:20:32,704
不需要先存储一个值 以后再用
to just remember a value, to apply it later.

1323
01:20:32,992 --> 01:20:33,328
教授：对
PROFESSOR: Yeah.

1324
01:20:33,504 --> 01:20:36,448
学生：DEFINE在语言中好像有一些副作用
AUDIENCE: Defines were kind of a side-effect it seemed in the language.

1325
01:20:36,490 --> 01:20:38,528
（听不清）并且依赖于时序
[INTERPOSING] are order dependent.

1326
01:20:39,300 --> 01:20:42,064
不用DEFINE 是否消除了副作用？
Does this eliminate the side-effect from the.

1327
01:20:42,280 --> 01:20:44,688
教授： 实际上
PROFESSOR: Well. The answer is,

1328
01:20:44,880 --> 01:20:46,440
解释器并不是像这样实现的
this is not the way these things were implemented.

1329
01:20:47,520 --> 01:20:47,936
明白了吧？
OK?

1330
01:20:48,920 --> 01:20:53,152
在实际的实现中 DEFINE这个运算
Define, indeed is implemented as an operation

1331
01:20:53,184 --> 01:20:55,536
确实修改了环境
that actually modifies an environment structure,

1332
01:20:57,952 --> 01:21:02,336
改变了执行DEFINE的那个框架
changes the frame that the define is executed in.

1333
01:21:03,690 --> 01:21:06,512
这样做是有很多原因的
And there are many reasons for that,

1334
01:21:07,390 --> 01:21:08,640
其中之一就是
but a lot of this has to do with

1335
01:21:08,672 --> 01:21:10,090
方便交互式系统
making an interactive system.

1336
01:21:11,340 --> 01:21:14,128
就是说 如果你构造了一个系统
What this is saying is that if you've made a system,

1337
01:21:14,350 --> 01:21:15,200
而且你知道
and you know

1338
01:21:15,420 --> 01:21:16,608
你不打算进行调试
and you know you're not going to do any debugging

1339
01:21:16,608 --> 01:21:17,550
或之类的事儿
or anything like that,

1340
01:21:17,840 --> 01:21:20,720
你想立马知道所有的东西
and you know everything there is all at once,

1341
01:21:20,750 --> 01:21:21,248
你想知道的是
and you want to say,

1342
01:21:21,264 --> 01:21:23,120
方程组的最终解是什么？
what is the meaning of a final set of equations?

1343
01:21:24,090 --> 01:21:25,264
然后系统返回你相应的值
This gives you a meaning for it.

1344
01:21:25,790 --> 01:21:27,456
但如果想要让系统变成交互式的
But in order to make an interactive system,

1345
01:21:27,456 --> 01:21:28,752
这样你可以在不影响其它部分的情况下
where you can change the meaning of one

1346
01:21:28,768 --> 01:21:31,680
增量式地修改某一部分
without changing everything else, incrementally,

1347
01:21:32,336 --> 01:21:35,040
没有DEFINE的话 就不能这么做了
you can't do that by implementing it this way.

1348
01:21:40,990 --> 01:21:41,248
你说
Yes.

1349
01:21:42,304 --> 01:21:44,256
学生：就是那张“危险”的幻灯片
AUDIENCE: Another question on your danger slide.

1350
01:21:44,650 --> 01:21:47,136
好像你举的两个例子
It seemed that the two examples that you gave

1351
01:21:47,160 --> 01:21:49,070
与其收敛与否有关系？
had to do with convergence and non-convergence?

1352
01:21:49,184 --> 01:21:49,568
教授：是的
PROFESSOR: Right.

1353
01:21:50,300 --> 01:21:52,624
学生：函数理论中是否有
AUDIENCE: And that may or may not have something to do with

1354
01:21:52,760 --> 01:21:54,688
像线性系统
with function theory in a way which

1355
01:21:54,720 --> 01:21:56,600
或者非线性系统中的
would lead you to think of it in terms of linear systems,

1356
01:21:57,744 --> 01:21:59,008
那种思考方式
or non-linear systems.

1357
01:21:59,344 --> 01:22:01,760
函数的收敛性能否先验地知道
How does this convergence relate to being able to

1358
01:22:02,352 --> 01:22:05,536
哪些属性可能被违反？
see a priori what properties of that might be violated?

1359
01:22:05,792 --> 01:22:06,576
教授：我不知道
PROFESSOR: I don't know.

1360
01:22:07,680 --> 01:22:10,096
我也不知道它需要什么条件
The answer is, I don't know under what circumstances.

1361
01:22:10,610 --> 01:22:12,048
我不知道怎么在一节课内
I don't know how to translate that

1362
01:22:12,528 --> 01:22:14,736
就给你们讲清楚
into less than an hour of talk more.

1363
01:22:16,910 --> 01:22:18,480
有什么条件来判别它们
What are the conditions under which,

1364
01:22:18,864 --> 01:22:20,768
是否收敛？
for which we know that these things converge?

1365
01:22:22,864 --> 01:22:23,312
确实
And indeed,

1366
01:22:23,328 --> 01:22:26,350
这些都是为了告诉你 基于收敛的论证
all that was telling you that arguments that are based on convergence

1367
01:22:28,240 --> 01:22:29,472
都不可靠
are flaky

1368
01:22:29,664 --> 01:22:31,584
如果你事先不知道收敛性的话
if you don't know the convergence beforehand.

1369
01:22:32,810 --> 01:22:34,208
你可能做出错误的论证
You can make wrong arguments.

1370
01:22:34,440 --> 01:22:37,312
你可以先假设知道了答案 然后进行演绎
You can make deductions, as if you know the answer,

1371
01:22:37,392 --> 01:22:39,936
看它会不会产生什么明显的矛盾
and not be stopped somewhere by some obvious contradiction.

1372
01:22:40,976 --> 01:22:42,288
学生：我们是否可以说
AUDIENCE: So can we say then that

1373
01:22:42,336 --> 01:22:44,880
如果数学表达式F收敛
if F is a convergent mathematical expression,

1374
01:22:45,008 --> 01:22:47,360
那么它的递归性质就--
then the recursion property can be--

1375
01:22:47,584 --> 01:22:51,296
教授：我认为 在技术上有一类F
PROFESSOR: Well, I think there's a technical kind of F,

1376
01:22:52,120 --> 01:22:54,224
通过一些技术准则
OK? There is a technical description

1377
01:22:54,240 --> 01:22:55,900
我们可以找到这样的F
of those F's that have the property

1378
01:22:55,984 --> 01:23:01,312
当你像这样迭代地应用它们时
that when you iteratively apply them like this,

1379
01:23:01,520 --> 01:23:02,256
它一定会收敛
you converge.

1380
01:23:03,020 --> 01:23:06,512
这类准则包括：单调、连续
Things that are monotonic, and continuous,

1381
01:23:07,328 --> 01:23:07,952
我想想
OK?

1382
01:23:08,384 --> 01:23:09,370
我把其它的准则忘了
and I forgot what else.

1383
01:23:09,370 --> 01:23:11,136
还有一些列像这样的
There is a whole bunch of little conditions like that

1384
01:23:11,680 --> 01:23:12,992
判别准则
which have this property.

1385
01:23:13,430 --> 01:23:16,000
现在的难点是 给定F然后进行推理
Now the real problem is deducing from looking at the F,

1386
01:23:16,928 --> 01:23:17,888
这是F的定义
its definition here,

1387
01:23:18,170 --> 01:23:19,660
它满足这些准则吗？
whether not it has those properties,

1388
01:23:20,272 --> 01:23:21,328
这很难判断
and that's very hard.

1389
01:23:22,010 --> 01:23:24,000
那些准则都很简单得可以写下来
The properties are easy. You can write them down.

1390
01:23:24,580 --> 01:23:26,320
你可以看Joe Stoy写的一本书
You can look in a book by Joe Stoy.

1391
01:23:26,672 --> 01:23:29,584
那本书非常不错
It's a great book-- Stoy.

1392
01:23:32,220 --> 01:23:34,064
叫做The Scott-Strachey
It's called, The Scott-Strachey

1393
01:23:34,496 --> 01:23:38,460
《指称语义：基于Scott-Strachey方法》
The Scott-Strachey Method of Denotational Semantics,

1394
01:23:39,552 --> 01:23:40,768
作者是Joe Stoy
and it's by Joe Stoy,

1395
01:23:40,800 --> 01:23:41,760
由MIT出版社出版
MIT Press.

1396
01:23:48,064 --> 01:23:49,888
他把这一方面讲得非常详细
And he works out all this in great detail,

1397
01:23:50,208 --> 01:23:51,376
绝对会让你吓一大跳
enough to horrify you.

1398
01:23:55,056 --> 01:23:56,192
但是这本书仍然值得一读
But it really is readable.

1399
01:24:09,150 --> 01:24:10,080
好吧 谢谢大家
OK, well, thank you.

1400
01:24:11,490 --> 01:24:12,992
这节课到此为止
Time for the bigger break, I suppose.

1401
01:24:14,176 --> 01:24:20,928
MIT OpenCourseWare
http://ocw.mit.edu

1402
01:24:20,920 --> 01:24:34,496
本项目主页
https://github.com/DeathKing/Learning-SICP

