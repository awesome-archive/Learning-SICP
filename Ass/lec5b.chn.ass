[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Active Line: 974
Video Position: 116001

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.01,0:00:02.46,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:02.60,0:00:10.00,staff,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:02.60,0:00:10.00,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:02.60,0:00:10.00,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:02.60,0:00:10.00,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N张大伟\N（DreamAndDead）
Dialogue: 0,0:00:02.60,0:00:10.00,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:10.10,0:00:14.60,Declare,,0,0,0,,{\an2\fad(500,500)}计算对象
Dialogue: 0,0:00:21.17,0:00:24.12,Default,,0,0,0,,现在我们已经学习了
Dialogue: 0,0:00:24.43,0:00:27.40,Default,,0,0,0,,如何创建局部状态和如何建模对象
Dialogue: 0,0:00:28.33,0:00:32.67,Default,,0,0,0,,我想我们应该找点复杂的东西
Dialogue: 0,0:00:34.03,0:00:36.36,Default,,0,0,0,,来实践一下学过的这些知识
Dialogue: 0,0:00:40.43,0:00:43.48,Default,,0,0,0,,我可以这么说 假设我们处在现实世界中
Dialogue: 0,0:00:44.11,0:00:46.25,Default,,0,0,0,,我们把这个世界看作是
Dialogue: 0,0:00:46.99,0:00:51.08,Default,,0,0,0,,由许多的事物构成的
Dialogue: 0,0:00:52.06,0:00:55.98,Default,,0,0,0,,每个事物都有其独立的局部状态
Dialogue: 0,0:00:57.24,0:00:59.87,Default,,0,0,0,,正是这些独立的状态使其成为事物
Dialogue: 0,0:01:01.28,0:01:04.27,Default,,0,0,0,,因此我们说 在这个世界的模型中
Dialogue: 0,0:01:04.28,0:01:09.90,Default,,0,0,0,,我们在大脑中和计算机中对那个世界建模
Dialogue: 0,0:01:10.94,0:01:12.54,Default,,0,0,0,,我想要建立一种对应关系
Dialogue: 0,0:01:12.78,0:01:15.21,Default,,0,0,0,,把现实世界和计算机中的对象联系起来
Dialogue: 0,0:01:15.87,0:01:17.74,Default,,0,0,0,,把现实世界中对象间的关系
Dialogue: 0,0:01:17.96,0:01:21.72,Default,,0,0,0,,与计算机中的模型对象间的关系 对应起来
Dialogue: 0,0:01:23.18,0:01:25.52,Default,,0,0,0,,把现实世界中关联对象的函数
Dialogue: 0,0:01:25.93,0:01:28.11,Default,,0,0,0,,与计算机中的函数 对应起来
Dialogue: 0,0:01:30.84,0:01:33.82,Default,,0,0,0,,这让我们获得了模块性
Dialogue: 0,0:01:34.74,0:01:36.75,Default,,0,0,0,,如果我们认为现实世界是像那样的
Dialogue: 0,0:01:37.36,0:01:38.72,Default,,0,0,0,,也就是由许多小的事物构成的
Dialogue: 0,0:01:39.20,0:01:41.47,Default,,0,0,0,,当然 我们可以把世界安排成那样
Dialogue: 0,0:01:42.03,0:01:43.95,Default,,0,0,0,,我们只能对像那样的事物建模
Dialogue: 0,0:01:45.45,0:01:49.02,Default,,0,0,0,,这样 我们的程序就可以从现实世界中继承模块化
Dialogue: 0,0:01:50.45,0:01:53.58,Default,,0,0,0,,这就是发明面向对象编程的初衷
Dialogue: 0,0:01:55.42,0:01:58.19,Default,,0,0,0,,我所见过的最完美的对象（系统）
Dialogue: 0,0:01:58.89,0:02:04.17,Default,,0,0,0,,电气系统 就是非常非常完美的对象系统
Dialogue: 0,0:02:06.40,0:02:12.99,Default,,0,0,0,,电气系统真的是物理学家构造的非常非常好的一种对象
Dialogue: 0,0:02:14.22,0:02:16.76,Default,,0,0,0,,这里 我有一些机器零件
Dialogue: 0,0:02:17.12,0:02:18.28,Default,,0,0,0,,就是这些零件
Dialogue: 0,0:02:20.04,0:02:22.88,Default,,0,0,0,,有一个电线连接起了
Dialogue: 0,0:02:23.66,0:02:26.40,Default,,0,0,0,,零件的两个部分
Dialogue: 0,0:02:27.56,0:02:30.86,Default,,0,0,0,,电气世界中 有一个非常棒的特性
Dialogue: 0,0:02:31.64,0:02:33.12,Default,,0,0,0,,就是我可以说这是一个对象
Dialogue: 0,0:02:34.01,0:02:34.97,Default,,0,0,0,,这又是一个对象
Dialogue: 0,0:02:35.71,0:02:37.53,Default,,0,0,0,,它们间的关联一目了然
Dialogue: 0,0:02:38.24,0:02:43.32,Default,,0,0,0,,而且 如果我没有用电线连接 它们便没有关联
Dialogue: 0,0:02:44.74,0:02:46.12,Default,,0,0,0,,比如我有一个灯泡
Dialogue: 0,0:02:46.52,0:02:50.32,Default,,0,0,0,,一个灯泡和一个已经接在插座上的电源
Dialogue: 0,0:02:51.63,0:02:53.53,Default,,0,0,0,,关联非常明了
Dialogue: 0,0:02:53.62,0:02:55.42,Default,,0,0,0,,这就是已知所有的连接方式了
Dialogue: 0,0:02:56.22,0:03:02.33,Default,,0,0,0,,就算我把连接电灯和电源的电线打个结
Dialogue: 0,0:03:02.68,0:03:03.64,Default,,0,0,0,,灯仍然是亮的
Dialogue: 0,0:03:04.04,0:03:04.76,Default,,0,0,0,,没什么影响
Dialogue: 0,0:03:07.44,0:03:12.40,Default,,0,0,0,,物理学上这样安排 可以使连接变成抽象的
Dialogue: 0,0:03:13.08,0:03:15.27,Default,,0,0,0,,至少在低频状态下是可以的
Dialogue: 0,0:03:17.84,0:03:20.88,Default,,0,0,0,,而且这就是全部的关联方式了
Dialogue: 0,0:03:22.35,0:03:23.87,Default,,0,0,0,,当然 我们来进一步
Dialogue: 0,0:03:23.90,0:03:27.31,Default,,0,0,0,,讨论一种在电气系统中最为广泛的抽象
Dialogue: 0,0:03:27.85,0:03:29.42,Default,,0,0,0,,数字电路
Dialogue: 0,0:03:31.69,0:03:33.66,Default,,0,0,0,,这里有一些对象
Dialogue: 0,0:03:34.64,0:03:40.12,Default,,0,0,0,,例如 在数字电路里中 我们有非门
Dialogue: 0,0:03:41.39,0:03:42.78,Default,,0,0,0,,有与门
Dialogue: 0,0:03:43.99,0:03:45.40,Default,,0,0,0,,还有或门
Dialogue: 0,0:03:47.21,0:03:50.12,Default,,0,0,0,,我们用一种特殊的“电线” 把它们连接起来
Dialogue: 0,0:03:52.00,0:03:54.94,Default,,0,0,0,,这些“电线”代表抽象信号
Dialogue: 0,0:03:55.61,0:03:57.18,Default,,0,0,0,,我们不关心具体的物理因素
Dialogue: 0,0:03:57.21,0:03:59.72,Default,,0,0,0,,像电压、电流或者组合因素等
Dialogue: 0,0:04:00.01,0:04:03.44,Default,,0,0,0,,又或者是水压 等等
Dialogue: 0,0:04:05.20,0:04:07.32,Default,,0,0,0,,这些抽象变量代表某类信号
Dialogue: 0,0:04:09.42,0:04:12.89,Default,,0,0,0,,我们用电路连接元件 构建系统
Dialogue: 0,0:04:14.07,0:04:16.22,Default,,0,0,0,,现在 我要向你们介绍一门新的语言
Dialogue: 0,0:04:17.63,0:04:20.17,Default,,0,0,0,,我们要构建一门内嵌于Lisp中的语言
Dialogue: 0,0:04:22.14,0:04:25.08,Default,,0,0,0,,这是一种内部DSL 是类似于之前讲过的图形语言那种
Dialogue: 0,0:04:26.16,0:04:27.32,Default,,0,0,0,,而不是昨天那种
Dialogue: 0,0:04:27.88,0:04:31.61,Default,,0,0,0,,那种模式匹配语言 -- 那是外部DSL
Dialogue: 0,0:04:32.80,0:04:36.30,Default,,0,0,0,,模式匹配语言是由Lisp程序所解释的
Dialogue: 0,0:04:38.16,0:04:40.52,Default,,0,0,0,,而之前那种图形语言
Dialogue: 0,0:04:40.56,0:04:44.27,Default,,0,0,0,,是在Lisp中构造我们想要的过程 来封装图形结构
Dialogue: 0,0:04:45.48,0:04:46.75,Default,,0,0,0,,举例来说
Dialogue: 0,0:04:47.72,0:04:50.64,Default,,0,0,0,,首先我要有一些基本对象
Dialogue: 0,0:04:51.05,0:04:52.12,Default,,0,0,0,,比如这个和这个
Dialogue: 0,0:04:53.50,0:04:55.18,Default,,0,0,0,,然后用电线去组合它们
Dialogue: 0,0:04:55.98,0:04:59.37,Default,,0,0,0,,我用(MAKE-WIRE)来构造一个电线
Dialogue: 0,0:04:59.87,0:05:01.24,Default,,0,0,0,,A就代表了一根电线
Dialogue: 0,0:05:01.74,0:05:02.69,Default,,0,0,0,,B也是
Dialogue: 0,0:05:02.69,0:05:03.46,Default,,0,0,0,,C也是
Dialogue: 0,0:05:03.46,0:05:04.23,Default,,0,0,0,,D也是
Dialogue: 0,0:05:04.23,0:05:04.83,Default,,0,0,0,,还有E
Dialogue: 0,0:05:04.83,0:05:05.64,Default,,0,0,0,,S也是
Dialogue: 0,0:05:06.88,0:05:12.75,Default,,0,0,0,,而或门有两个输入 分别是A和B
Dialogue: 0,0:05:13.16,0:05:14.75,Default,,0,0,0,,它的输出是D
Dialogue: 0,0:05:15.07,0:05:16.12,Default,,0,0,0,,我们用这样的记号来表示
Dialogue: 0,0:05:18.14,0:05:22.14,Default,,0,0,0,,与门 输入是A和B 输出是C
Dialogue: 0,0:05:22.22,0:05:23.24,Default,,0,0,0,,我们这样表示
Dialogue: 0,0:05:24.82,0:05:28.46,Default,,0,0,0,,通过一系列像这样的声明
Dialogue: 0,0:05:29.29,0:05:31.64,Default,,0,0,0,,我可以组合出任意的电路
Dialogue: 0,0:05:32.75,0:05:34.64,Default,,0,0,0,,我已经告诉了你们创建数字电路
Dialogue: 0,0:05:35.31,0:05:38.51,Default,,0,0,0,,的基本元素和组合方法了
Dialogue: 0,0:05:40.09,0:05:43.04,Default,,0,0,0,,然后就该说抽象的方法了
Dialogue: 0,0:05:43.69,0:05:52.24,Default,,0,0,0,,举例来说 这是一个半加器
Dialogue: 0,0:05:52.67,0:05:55.55,Default,,0,0,0,,如果你学过电路设计肯定知道这个东西
Dialogue: 0,0:05:56.93,0:06:00.44,Default,,0,0,0,,输入两个数A和B
Dialogue: 0,0:06:00.62,0:06:02.12,Default,,0,0,0,,输出两者之和以及进位
Dialogue: 0,0:06:04.35,0:06:06.80,Default,,0,0,0,,事实上 完全可以用我刚刚说的来组合电路
Dialogue: 0,0:06:07.45,0:06:10.99,Default,,0,0,0,,盒子外面 半加器盒子的外面有一些接口
Dialogue: 0,0:06:11.13,0:06:14.11,Default,,0,0,0,,这些盒子的边界 我们总是抽象成盒子
Dialogue: 0,0:06:14.79,0:06:19.70,Default,,0,0,0,,从盒子里引出A、B、S、C四根线
Dialogue: 0,0:06:19.70,0:06:21.79,Default,,0,0,0,,这些是已经声明了的变量
Dialogue: 0,0:06:23.39,0:06:26.25,Default,,0,0,0,,由LAMBDA表达式声明的几个变量
Dialogue: 0,0:06:26.28,0:06:28.01,Default,,0,0,0,,定义了这个半加器
Dialogue: 0,0:06:31.40,0:06:35.96,Default,,0,0,0,,在盒子的内部 我构造了电线D和E
Dialogue: 0,0:06:36.00,0:06:37.44,Default,,0,0,0,,这是为了连接内部结构
Dialogue: 0,0:06:37.74,0:06:40.40,Default,,0,0,0,,这条是E 这条是D
Dialogue: 0,0:06:41.32,0:06:43.50,Default,,0,0,0,,内部连接的线路并没有引出盒子之外
Dialogue: 0,0:06:45.05,0:06:46.83,Default,,0,0,0,,就像电路图那样连起来
Dialogue: 0,0:06:48.79,0:06:50.89,Default,,0,0,0,,大家可以看得出来
Dialogue: 0,0:06:51.05,0:06:53.02,Default,,0,0,0,,这个语言非常有层次性
Dialogue: 0,0:06:53.85,0:06:55.71,Default,,0,0,0,,如果一门语言没有层次性
Dialogue: 0,0:06:55.95,0:06:59.96,Default,,0,0,0,,如果你不能把一个复合对象当成基本对象来使用
Dialogue: 0,0:07:00.38,0:07:01.53,Default,,0,0,0,,这门语言肯定是有问题的
Dialogue: 0,0:07:02.59,0:07:04.22,Default,,0,0,0,,至少我是这么认为的
Dialogue: 0,0:07:06.41,0:07:09.58,Default,,0,0,0,,之前 我们都是在研究数学函数
Dialogue: 0,0:07:09.60,0:07:11.12,Default,,0,0,0,,或者是计算数学函数的东西
Dialogue: 0,0:07:11.15,0:07:12.65,Default,,0,0,0,,这些都是我们之前研究的东西
Dialogue: 0,0:07:13.85,0:07:16.65,Default,,0,0,0,,而我们现在
Dialogue: 0,0:07:16.67,0:07:17.63,Default,,0,0,0,,不这么做了
Dialogue: 0,0:07:17.85,0:07:20.88,Default,,0,0,0,,我们从一些电气对象开始
Dialogue: 0,0:07:21.04,0:07:22.64,Default,,0,0,0,,构建更多的对象
Dialogue: 0,0:07:23.35,0:07:28.83,Default,,0,0,0,,我们用Lisp里的LAMBDA将其粘合起来
Dialogue: 0,0:07:30.38,0:07:32.93,Default,,0,0,0,,“LAMBDA: 终极之粘合剂”
Dialogue: 0,0:07:33.32,0:07:36.35,Default,,0,0,0,,当然 半加器可以用于
Dialogue: 0,0:07:37.64,0:07:41.04,Default,,0,0,0,,构造一种更复杂的抽象结构 -- 全加器
Dialogue: 0,0:07:41.60,0:07:45.05,Default,,0,0,0,,如这里所示 全加器由两个半加器构成
Dialogue: 0,0:07:45.47,0:07:47.87,Default,,0,0,0,,用一些额外的电线连接起来
Dialogue: 0,0:07:48.08,0:07:51.29,Default,,0,0,0,,就像这里所示的S、C1、C2以及一个或门
Dialogue: 0,0:07:52.19,0:07:53.60,Default,,0,0,0,,而对于一个全加器
Dialogue: 0,0:07:53.87,0:08:00.78,Default,,0,0,0,,它的输入有：两个待加的数 一个进位值
Dialogue: 0,0:08:01.36,0:08:04.17,Default,,0,0,0,,输出是：两数之和以及进位
Dialogue: 0,0:08:05.90,0:08:10.70,Default,,0,0,0,,构建好全加器以后 还可以把它们链起来组成更大的加法器
Dialogue: 0,0:08:12.99,0:08:14.83,Default,,0,0,0,,现在我们有了一门完整的语言
Dialogue: 0,0:08:16.06,0:08:21.76,Default,,0,0,0,,它有基本元素、组合方法以及抽象方法
Dialogue: 0,0:08:22.27,0:08:23.36,Default,,0,0,0,,现在 我们怎样实现这门语言？
Dialogue: 0,0:08:25.00,0:08:26.84,Default,,0,0,0,,其实并不难
Dialogue: 0,0:08:27.07,0:08:27.96,Default,,0,0,0,,首先来看基本元素
Dialogue: 0,0:08:28.12,0:08:30.11,Default,,0,0,0,,这是唯一的问题
Dialogue: 0,0:08:31.16,0:08:32.56,Default,,0,0,0,,不需要再做其它事情了
Dialogue: 0,0:08:33.74,0:08:38.00,Default,,0,0,0,,因为我们直接借用了Lisp中的组合方法以及抽象方法
Dialogue: 0,0:08:39.96,0:08:41.88,Default,,0,0,0,,我们的语言 继承自Lisp并内嵌于其中
Dialogue: 0,0:08:43.77,0:08:45.44,Default,,0,0,0,,好 我们先来看一个基本元素
Dialogue: 0,0:08:45.86,0:08:47.40,Default,,0,0,0,,就拿非门来说吧
Dialogue: 0,0:08:51.54,0:08:54.67,Default,,0,0,0,,非门有两个引脚 分别是输入和输出
Dialogue: 0,0:08:57.31,0:09:02.62,Default,,0,0,0,,它要对输入信号做出响应
Dialogue: 0,0:09:04.30,0:09:07.00,Default,,0,0,0,,它需要对输入电线说 --
Dialogue: 0,0:09:07.64,0:09:10.14,Default,,0,0,0,,我们现在把它们视作对象
Dialogue: 0,0:09:10.44,0:09:12.41,Default,,0,0,0,,其具体细节我们稍后讨论
Dialogue: 0,0:09:13.23,0:09:14.84,Default,,0,0,0,,它对其输入电线的说
Dialogue: 0,0:09:15.82,0:09:18.48,Default,,0,0,0,,“当你的值变发生改变时 告诉我一声”
Dialogue: 0,0:09:20.12,0:09:22.11,Default,,0,0,0,,所以非门这个对象
Dialogue: 0,0:09:22.41,0:09:24.38,Default,,0,0,0,,会对输入电线这个对象说 --
Dialogue: 0,0:09:25.13,0:09:26.40,Default,,0,0,0,,“Hi 我是George”
Dialogue: 0,0:09:26.87,0:09:31.02,Default,,0,0,0,,“我的工作就是 对你的变化做出响应”
Dialogue: 0,0:09:31.72,0:09:34.19,Default,,0,0,0,,“所以当你变化的时候 告诉我一声”
Dialogue: 0,0:09:34.73,0:09:35.72,Default,,0,0,0,,“这样我才能进一步的处理”
Dialogue: 0,0:09:36.88,0:09:40.30,Default,,0,0,0,,这是通过在这里 在输入电线上
Dialogue: 0,0:09:41.40,0:09:44.64,Default,,0,0,0,,添加一个叫做INVERT-IN的动作来实现的
Dialogue: 0,0:09:45.07,0:09:46.94,Default,,0,0,0,,INVERT-IN在这里定义
Dialogue: 0,0:09:47.05,0:09:48.76,Default,,0,0,0,,它是一个无参过程
Dialogue: 0,0:09:49.98,0:09:54.59,Default,,0,0,0,,它将线路上的信号逻辑取反
Dialogue: 0,0:09:56.06,0:09:58.64,Default,,0,0,0,,经过一段时长为INVERTER-DELAT的延时以后 --
Dialogue: 0,0:09:59.26,0:10:01.15,Default,,0,0,0,,每个电路对象都有延时 --
Dialogue: 0,0:10:02.88,0:10:04.46,Default,,0,0,0,,然后我们会 --
Dialogue: 0,0:10:04.67,0:10:07.14,Default,,0,0,0,,我们再把输出设置为新的值
Dialogue: 0,0:10:10.16,0:10:11.36,Default,,0,0,0,,非常简单
Dialogue: 0,0:10:12.40,0:10:15.28,Default,,0,0,0,,你可以想象输出电线也同样是信号敏感的
Dialogue: 0,0:10:15.77,0:10:18.27,Default,,0,0,0,,当信号改变的时候
Dialogue: 0,0:10:19.28,0:10:21.15,Default,,0,0,0,,它会“告知”其它对象
Dialogue: 0,0:10:21.79,0:10:24.78,Default,,0,0,0,,“快醒醒！我的值已经改变啦”
Dialogue: 0,0:10:26.05,0:10:30.14,Default,,0,0,0,,所以当你把非门和与门或者元件连在一起的时候
Dialogue: 0,0:10:30.46,0:10:32.20,Default,,0,0,0,,它们之间将会有大量的通信
Dialogue: 0,0:10:32.86,0:10:35.07,Default,,0,0,0,,以确保信号正确地传播
Dialogue: 0,0:10:36.81,0:10:38.62,Default,,0,0,0,,到目前为止 没什么新奇的东西
Dialogue: 0,0:10:38.62,0:10:40.72,Default,,0,0,0,,我们只是针对某个特定的表示法
Dialogue: 0,0:10:40.72,0:10:45.24,Default,,0,0,0,,也就是这个例子中的1、0 -- 实现了LOGICAL-NOT而已
Dialogue: 0,0:10:46.73,0:10:49.16,Default,,0,0,0,,与门就相对复杂一些
Dialogue: 0,0:10:49.78,0:10:55.80,Default,,0,0,0,,与门有两个输入A1和A2 输出是OUTPUT
Dialogue: 0,0:10:56.73,0:11:00.64,Default,,0,0,0,,但是其结构和非门没有什么大的不同
Dialogue: 0,0:11:00.86,0:11:03.44,Default,,0,0,0,,只不过是 当输入信号改变的时候
Dialogue: 0,0:11:04.52,0:11:09.07,Default,,0,0,0,,与门调用的是AND-ACTION过程罢了
Dialogue: 0,0:11:10.91,0:11:12.88,Default,,0,0,0,,当然 它所做的只是
Dialogue: 0,0:11:12.91,0:11:15.37,Default,,0,0,0,,对输入信号进行逻辑“与”运算
Dialogue: 0,0:11:16.19,0:11:18.76,Default,,0,0,0,,在经过AND-GATE-DELAY的延时之后
Dialogue: 0,0:11:20.46,0:11:24.36,Default,,0,0,0,,调用这个过程 更新输出信号值
Dialogue: 0,0:11:25.47,0:11:28.35,Default,,0,0,0,,那么 我们如何用“按愿望思维”来构造这一切呢？
Dialogue: 0,0:11:28.35,0:11:31.08,Default,,0,0,0,,如大家所见 这里有一个赋值运算
Dialogue: 0,0:11:32.02,0:11:32.78,Default,,0,0,0,,但并不是SET!
Dialogue: 0,0:11:34.57,0:11:36.78,Default,,0,0,0,,这是一个派生出来的运算
Dialogue: 0,0:11:36.78,0:11:38.73,Default,,0,0,0,,就像可以从CAR和CDR派生出其它函数一样
Dialogue: 0,0:11:40.80,0:11:44.81,Default,,0,0,0,,因此 按照约定 我加上“!”（表示这个过程有副作用）
Dialogue: 0,0:11:46.34,0:11:49.18,Default,,0,0,0,,这里有个过程ADD-ACTION!
Dialogue: 0,0:11:49.44,0:11:54.67,Default,,0,0,0,,它用来提醒与门中的局部线路A1
Dialogue: 0,0:11:55.63,0:11:58.68,Default,,0,0,0,,当它改变的时候记得执行过程AND-ACTION-PROCEDURE
Dialogue: 0,0:11:59.58,0:12:02.91,Default,,0,0,0,,A2也是一样
Dialogue: 0,0:12:06.31,0:12:07.23,Default,,0,0,0,,非常简单
Dialogue: 0,0:12:09.96,0:12:12.09,Default,,0,0,0,,现在我们再来看看
Dialogue: 0,0:12:12.70,0:12:16.12,Default,,0,0,0,,各部分间是如何通信的
Dialogue: 0,0:12:18.54,0:12:19.66,Default,,0,0,0,,例如
Dialogue: 0,0:12:23.12,0:12:24.27,Default,,0,0,0,,有一个非常简单的电路
Dialogue: 0,0:12:24.27,0:12:30.46,Default,,0,0,0,,它有一个与门 带有两个输入A、B
Dialogue: 0,0:12:31.92,0:12:38.00,Default,,0,0,0,,与门通过电线C跟非门相连
Dialogue: 0,0:12:39.72,0:12:41.53,Default,,0,0,0,,非门的输出是D
Dialogue: 0,0:12:44.20,0:12:47.34,Default,,0,0,0,,这就是物理世界
Dialogue: 0,0:12:47.36,0:12:49.02,Default,,0,0,0,,一个对物理世界的抽象
Dialogue: 0,0:12:49.86,0:12:53.40,Default,,0,0,0,,要不了几分钱就可以从Radio Shack买到这些元件
Dialogue: 0,0:12:54.88,0:12:56.32,Default,,0,0,0,,那些元件的作用和画在这里的差不多
Dialogue: 0,0:12:57.16,0:13:00.22,Default,,0,0,0,,元件上都标有类似于LS04的标签
Dialogue: 0,0:13:01.53,0:13:08.16,Default,,0,0,0,,现在来看其中的计算模型
Dialogue: 0,0:13:09.01,0:13:10.94,Default,,0,0,0,,它又对应着什么
Dialogue: 0,0:13:11.13,0:13:14.09,Default,,0,0,0,,计算机中的对象对应着我们思维中的什么
Dialogue: 0,0:13:15.85,0:13:19.13,Default,,0,0,0,,我需要把现实世界中的每个对象与计算机中的对应起来
Dialogue: 0,0:13:19.79,0:13:24.27,Default,,0,0,0,,把两个世界中对象之间的关系也对应起来
Dialogue: 0,0:13:26.06,0:13:26.80,Default,,0,0,0,,这是我的目标
Dialogue: 0,0:13:28.56,0:13:29.45,Default,,0,0,0,,让我们来看看怎么做
Dialogue: 0,0:13:30.90,0:13:34.20,Default,,0,0,0,,这一团东西代表信号A
Dialogue: 0,0:13:35.71,0:13:36.94,Default,,0,0,0,,这是信号A
Dialogue: 0,0:13:37.94,0:13:39.32,Default,,0,0,0,,画得像一团云
Dialogue: 0,0:13:39.90,0:13:42.80,Default,,0,0,0,,再画另一个信号 -- B
Dialogue: 0,0:13:46.68,0:13:47.47,Default,,0,0,0,,它是另一个信号
Dialogue: 0,0:13:49.14,0:13:50.91,Default,,0,0,0,,这两个信号
Dialogue: 0,0:13:51.10,0:13:52.81,Default,,0,0,0,,要通过某种方式连在一起
Dialogue: 0,0:13:53.72,0:13:58.75,Default,,0,0,0,,连在这个盒子上 -- 这就代表与门
Dialogue: 0,0:14:00.32,0:14:02.04,Default,,0,0,0,,这就是与门的动作过程
Dialogue: 0,0:14:07.66,0:14:08.59,Default,,0,0,0,,它将产生
Dialogue: 0,0:14:09.15,0:14:13.29,Default,,0,0,0,,它将与另外一个称作C的信号对象交互
Dialogue: 0,0:14:16.22,0:14:18.88,Default,,0,0,0,,哦 说错了 是一条电线C
Dialogue: 0,0:14:20.59,0:14:26.28,Default,,0,0,0,,这跟电线 又将连在另一个动作过程上
Dialogue: 0,0:14:26.28,0:14:30.33,Default,,0,0,0,,在我们的电气世界中 这个过程跟一个非门关联
Dialogue: 0,0:14:32.86,0:14:40.65,Default,,0,0,0,,我还有另外一根电线 -- D
Dialogue: 0,0:14:42.97,0:14:45.29,Default,,0,0,0,,整体布局就是这样
Dialogue: 0,0:14:46.00,0:14:49.44,Default,,0,0,0,,现在必须来研究它们 有关计算的内部机制了
Dialogue: 0,0:14:51.50,0:14:53.69,Default,,0,0,0,,每一跟电线都必须知道
Dialogue: 0,0:14:53.69,0:14:56.36,Default,,0,0,0,,自己承载的信号是什么
Dialogue: 0,0:14:57.34,0:15:00.00,Default,,0,0,0,,我们用变量SIGNAL来表示
Dialogue: 0,0:15:02.97,0:15:04.04,Default,,0,0,0,,SIGNAL的值就是信号
Dialogue: 0,0:15:05.68,0:15:07.74,Default,,0,0,0,,也不要忘了它所关联的环境
Dialogue: 0,0:15:08.89,0:15:11.34,Default,,0,0,0,,对于每个元件来说 一定有一个环境绑定了信号
Dialogue: 0,0:15:15.40,0:15:16.88,Default,,0,0,0,,因此 这里也有一个SIGNAL变量
Dialogue: 0,0:15:19.40,0:15:21.92,Default,,0,0,0,,SIGNAL的值不是0就是1
Dialogue: 0,0:15:22.81,0:15:23.48,Default,,0,0,0,,这儿也有个SIGNAL
Dialogue: 0,0:15:28.00,0:15:30.56,Default,,0,0,0,,现在 一旦这里的信号改变
Dialogue: 0,0:15:31.26,0:15:34.11,Default,,0,0,0,,我们需要通知一系列的对象
Dialogue: 0,0:15:36.66,0:15:37.66,Default,,0,0,0,,我们得通知这个与门
Dialogue: 0,0:15:39.30,0:15:43.96,Default,,0,0,0,,这里有个表 我们把它叫做AP
Dialogue: 0,0:15:44.50,0:15:45.60,Default,,0,0,0,,它可能是一个表
Dialogue: 0,0:15:46.44,0:15:49.00,Default,,0,0,0,,在本例中 表里面的第一项条目是这个东西
Dialogue: 0,0:15:50.50,0:15:54.81,Default,,0,0,0,,这个元件也有一个称为AP的表
Dialogue: 0,0:15:54.81,0:15:58.17,Default,,0,0,0,,也可能有一些其它对象 时刻等待着A来通知“它们”
Dialogue: 0,0:15:59.02,0:16:01.31,Default,,0,0,0,,所以这里可能有其它对象 比如
Dialogue: 0,0:16:01.72,0:16:03.23,Default,,0,0,0,,一些其它我们不知道的对象
Dialogue: 0,0:16:03.63,0:16:04.88,Default,,0,0,0,,这些是与A连接的其它对象
Dialogue: 0,0:16:07.20,0:16:09.64,Default,,0,0,0,,这里的AP表
Dialogue: 0,0:16:11.12,0:16:12.40,Default,,0,0,0,,也指向这个与门
Dialogue: 0,0:16:13.07,0:16:16.35,Default,,0,0,0,,相类似的 这里的AP表
Dialogue: 0,0:16:16.78,0:16:18.53,Default,,0,0,0,,也要指向这里
Dialogue: 0,0:16:18.53,0:16:20.89,Default,,0,0,0,,这里是C要通知的元件
Dialogue: 0,0:16:21.77,0:16:23.18,Default,,0,0,0,,D也一样
Dialogue: 0,0:16:24.28,0:16:25.24,Default,,0,0,0,,但是我不知道它要通知谁
Dialogue: 0,0:16:25.26,0:16:26.65,Default,,0,0,0,,因为我的图中没有画出来
Dialogue: 0,0:16:27.19,0:16:28.36,Default,,0,0,0,,可能是和D连接起来的其它元件
Dialogue: 0,0:16:30.32,0:16:32.62,Default,,0,0,0,,同样的
Dialogue: 0,0:16:33.80,0:16:36.96,Default,,0,0,0,,当AND-ACTION过程被唤醒时
Dialogue: 0,0:16:37.02,0:16:41.31,Default,,0,0,0,,也就是说 之前你拜托某人将你唤醒
Dialogue: 0,0:16:41.45,0:16:44.84,Default,,0,0,0,,你拜托它们 当它们的信号发生改变时通知你
Dialogue: 0,0:16:46.97,0:16:48.81,Default,,0,0,0,,你得去检查它的信号是什么
Dialogue: 0,0:16:49.32,0:16:52.25,Default,,0,0,0,,这样你就可以计算逻辑与 输出信号给下一个元件
Dialogue: 0,0:16:57.09,0:16:58.75,Default,,0,0,0,,所里 这里就必须要有
Dialogue: 0,0:16:58.84,0:17:03.00,Default,,0,0,0,,有信息说 A1是这个元件
Dialogue: 0,0:17:03.90,0:17:06.48,Default,,0,0,0,,A2就是这个元件
Dialogue: 0,0:17:08.93,0:17:09.98,Default,,0,0,0,,不只是这样
Dialogue: 0,0:17:11.79,0:17:15.20,Default,,0,0,0,,当我在计算逻辑与时 我还得告诉这个元件一些信息
Dialogue: 0,0:17:16.30,0:17:21.05,Default,,0,0,0,,还有一个输出 输出给这个元件
Dialogue: 0,0:17:25.80,0:17:30.03,Default,,0,0,0,,同样地 非门也有一个输入
Dialogue: 0,0:17:32.38,0:17:34.92,Default,,0,0,0,,当信号被唤醒并告知它信号被修改时
Dialogue: 0,0:17:36.75,0:17:38.64,Default,,0,0,0,,非门会询问该信号
Dialogue: 0,0:17:38.64,0:17:40.09,Default,,0,0,0,,你的值是什么
Dialogue: 0,0:17:41.05,0:17:43.47,Default,,0,0,0,,信号通过像这样发消息 告知“信号已改变”
Dialogue: 0,0:17:43.52,0:17:45.53,Default,,0,0,0,,它就反过来查询这个新的信号值
Dialogue: 0,0:17:46.90,0:17:50.12,Default,,0,0,0,,取到值之后 它将会
Dialogue: 0,0:17:50.14,0:17:55.86,Default,,0,0,0,,计算输出 并改变这个信号的值
Dialogue: 0,0:18:00.60,0:18:01.24,Default,,0,0,0,,以此类推
Dialogue: 0,0:18:02.84,0:18:04.56,Default,,0,0,0,,因此我也必须有这么多的连接
Dialogue: 0,0:18:06.24,0:18:09.23,Default,,0,0,0,,现在我们回头观察一下 这个与门
Dialogue: 0,0:18:10.26,0:18:12.09,Default,,0,0,0,,回到这张幻灯片
Dialogue: 0,0:18:13.67,0:18:15.04,Default,,0,0,0,,这几个部分的内容
Dialogue: 0,0:18:16.04,0:18:19.32,Default,,0,0,0,,对每个与门 都有A1、A2两个输入 一个OUTPUT输出
Dialogue: 0,0:18:21.03,0:18:23.53,Default,,0,0,0,,这些都是
Dialogue: 0,0:18:25.08,0:18:28.16,Default,,0,0,0,,在AND-GATE被调用时的环境中
Dialogue: 0,0:18:28.41,0:18:31.24,Default,,0,0,0,,这些参数创建了一个框架
Dialogue: 0,0:18:33.31,0:18:35.90,Default,,0,0,0,,这个框架用来存放A1、A2和OUTPUT的值
Dialogue: 0,0:18:36.67,0:18:39.20,Default,,0,0,0,,它们都要与电线相绑定
Dialogue: 0,0:18:39.60,0:18:44.25,Default,,0,0,0,,这些电线就是通过参数传进来的
Dialogue: 0,0:18:46.24,0:18:47.31,Default,,0,0,0,,在这个环境下
Dialogue: 0,0:18:47.74,0:18:49.85,Default,,0,0,0,,我构建一个过程
Dialogue: 0,0:18:50.97,0:18:53.68,Default,,0,0,0,,就在这里
Dialogue: 0,0:18:54.59,0:18:57.31,Default,,0,0,0,,在该环境下定义的AND-ACTION-PROCEDURE
Dialogue: 0,0:18:58.35,0:19:00.70,Default,,0,0,0,,这个实际上是对一个LAMBDA表达式求值
Dialogue: 0,0:19:01.62,0:19:05.48,Default,,0,0,0,,它跟求值该LAMBDA表达式时的环境相绑定
Dialogue: 0,0:19:07.16,0:19:09.34,Default,,0,0,0,,找到它的局部环境
Dialogue: 0,0:19:11.70,0:19:13.47,Default,,0,0,0,,因此AND-ACTION-PROCEDURE过程能够
Dialogue: 0,0:19:13.64,0:19:16.94,Default,,0,0,0,,存取这里看到的A1、A2和OUTPUT
Dialogue: 0,0:19:17.31,0:19:19.64,Default,,0,0,0,,A1、A2、OUTPUT
Dialogue: 0,0:19:22.36,0:19:23.95,Default,,0,0,0,,我们还没有深入探索“电线”的内部结构
Dialogue: 0,0:19:26.03,0:19:26.99,Default,,0,0,0,,那是仅剩的部分
Dialogue: 0,0:19:29.03,0:19:29.92,Default,,0,0,0,,来看看“电线”
Dialogue: 0,0:19:33.52,0:19:36.25,Default,,0,0,0,,麻烦请开一下投影仪
Dialogue: 0,0:19:39.50,0:19:42.56,Default,,0,0,0,,“电线”是有那么一点复杂
Dialogue: 0,0:19:43.09,0:19:44.64,Default,,0,0,0,,哦 摁错了
Dialogue: 0,0:19:47.05,0:19:48.75,Default,,0,0,0,,是非常复杂 像这样
Dialogue: 0,0:19:50.06,0:19:53.10,Default,,0,0,0,,但是还是来看一下 到底是什么
Dialogue: 0,0:19:54.72,0:19:56.67,Default,,0,0,0,,“电线”是这样的一种东西
Dialogue: 0,0:19:57.76,0:20:03.52,Default,,0,0,0,,有两个主要部分 都是它的状态
Dialogue: 0,0:20:05.01,0:20:07.39,Default,,0,0,0,,我们这里看到的 一个是信号值
Dialogue: 0,0:20:07.45,0:20:10.06,Default,,0,0,0,,这里 当我们调用MAKE-WIRE创建一条电线时
Dialogue: 0,0:20:10.46,0:20:13.02,Default,,0,0,0,,我们首先要创建一些变量
Dialogue: 0,0:20:14.94,0:20:16.08,Default,,0,0,0,,分别是这条电线的
Dialogue: 0,0:20:17.10,0:20:19.29,Default,,0,0,0,,SIGNAL和ACTION-PROCS
Dialogue: 0,0:20:22.32,0:20:23.44,Default,,0,0,0,,在这个上下文中
Dialogue: 0,0:20:23.76,0:20:27.04,Default,,0,0,0,,我们定义了一系列的过程
Dialogue: 0,0:20:27.84,0:20:31.15,Default,,0,0,0,,其中一个是(SET-MY-SIGNAL! NEW)
Dialogue: 0,0:20:32.85,0:20:37.42,Default,,0,0,0,,它所做的只是 取一个新值NEW
Dialogue: 0,0:20:37.93,0:20:40.36,Default,,0,0,0,,如果NEW和SIGNAL一样 信号没有变化 就没必要做什么了
Dialogue: 0,0:20:40.36,0:20:42.62,Default,,0,0,0,,否则 把SIGNAL的值赋值为NEW
Dialogue: 0,0:20:42.75,0:20:44.60,Default,,0,0,0,,再调用ACTION-PROCS里的所有过程
Dialogue: 0,0:20:46.52,0:20:52.51,Default,,0,0,0,,那些我之前引入的过程
Dialogue: 0,0:20:54.63,0:21:01.53,Default,,0,0,0,,也就是我在定义与门时就定义的过程
Dialogue: 0,0:21:04.13,0:21:05.60,Default,,0,0,0,,是在代码最后调用ADD-ACTION-PROCEDURE实现的
Dialogue: 0,0:21:07.41,0:21:10.80,Default,,0,0,0,,然后 我还得定义一个过程 用来接受动作
Dialogue: 0,0:21:10.81,0:21:11.82,Default,,0,0,0,,也就是这段代码
Dialogue: 0,0:21:12.80,0:21:15.13,Default,,0,0,0,,它增加了AP表
Dialogue: 0,0:21:15.56,0:21:21.63,Default,,0,0,0,,这是通过使用SET!将PROC与旧的AP表CONS起来实现的
Dialogue: 0,0:21:21.79,0:21:24.25,Default,,0,0,0,,而这个PROC是作为参数传递进来的
Dialogue: 0,0:21:25.40,0:21:27.58,Default,,0,0,0,,由于技术原因 最后还要再运行一次PROC
Dialogue: 0,0:21:27.78,0:21:29.20,Default,,0,0,0,,我不会再对此详细展开
Dialogue: 0,0:21:29.39,0:21:33.15,Default,,0,0,0,,这是一种事件驱动的模拟
Dialogue: 0,0:21:34.59,0:21:36.00,Default,,0,0,0,,要想把这个讲清楚还是得花点时间
Dialogue: 0,0:21:36.95,0:21:39.40,Default,,0,0,0,,最后 我还要定义一个“分派器”
Dialogue: 0,0:21:39.96,0:21:43.58,Default,,0,0,0,,这是一种将消息分派给电线的方法
Dialogue: 0,0:21:45.37,0:21:48.65,Default,,0,0,0,,它将用于从中抽取出不同的信息
Dialogue: 0,0:21:49.07,0:21:51.48,Default,,0,0,0,,比如这里 当前的信号值是多少？
Dialogue: 0,0:21:53.82,0:21:55.66,Default,,0,0,0,,设置新信号值的方法是什么？
Dialogue: 0,0:21:57.18,0:21:58.28,Default,,0,0,0,,我想要这个方法
Dialogue: 0,0:22:00.10,0:22:02.60,Default,,0,0,0,,我怎么样去添加另外的动作过程呢？
Dialogue: 0,0:22:05.51,0:22:09.36,Default,,0,0,0,,最后 以DISPATCH过程为返回值返回
Dialogue: 0,0:22:09.94,0:22:11.87,Default,,0,0,0,,因此 我所构造的电线
Dialogue: 0,0:22:12.00,0:22:13.55,Default,,0,0,0,,是一种可以接收消息的对象
Dialogue: 0,0:22:14.25,0:22:16.01,Default,,0,0,0,,它接收的消息类似于
Dialogue: 0,0:22:16.44,0:22:18.36,Default,,0,0,0,,“你的哪个方法可以用来添加动作过程？”
Dialogue: 0,0:22:19.92,0:22:21.00,Default,,0,0,0,,它返回一个过程
Dialogue: 0,0:22:21.64,0:22:23.05,Default,,0,0,0,,它返回ADD-ACTION-PROCUDURE
Dialogue: 0,0:22:23.07,0:22:26.54,Default,,0,0,0,,我可以将其应用在一个动作过程上
Dialogue: 0,0:22:27.05,0:22:29.01,Default,,0,0,0,,从而实现将一个动作过程加入电线的AP表中
Dialogue: 0,0:22:31.62,0:22:32.82,Default,,0,0,0,,这是一种“许可”
Dialogue: 0,0:22:33.20,0:22:36.08,Default,,0,0,0,,使得你可以去修改自身的AP表
Dialogue: 0,0:22:37.82,0:22:40.16,Default,,0,0,0,,实际上 你可以在这里看到
Dialogue: 0,0:22:41.71,0:22:42.32,Default,,0,0,0,,下一张幻灯片
Dialogue: 0,0:22:43.53,0:22:43.82,Default,,0,0,0,,噢
Dialogue: 0,0:22:47.76,0:22:49.12,Default,,0,0,0,,没什么有意思的
Dialogue: 0,0:22:49.12,0:22:50.65,Default,,0,0,0,,CALL-EACH调用每个动作过程
Dialogue: 0,0:22:50.89,0:22:52.57,Default,,0,0,0,,这只是对一个表不断做CDR
Dialogue: 0,0:22:52.73,0:22:54.60,Default,,0,0,0,,没什么好说的
Dialogue: 0,0:22:54.99,0:22:56.25,Default,,0,0,0,,我们早就知道了
Dialogue: 0,0:22:57.56,0:23:00.67,Default,,0,0,0,,然而 如果我想知道线路上的信号值
Dialogue: 0,0:23:01.02,0:23:02.54,Default,,0,0,0,,我询问该线路：你的 --
Dialogue: 0,0:23:02.54,0:23:03.09,Default,,0,0,0,,回想一下 什么是线路？
Dialogue: 0,0:23:03.09,0:23:05.40,Default,,0,0,0,,线路对象只是在创建它时所返回的分派过程而已
Dialogue: 0,0:23:05.86,0:23:06.48,Default,,0,0,0,,只是一个过程
Dialogue: 0,0:23:06.83,0:23:12.27,Default,,0,0,0,,我向该分派器发送一个消息'GET-SIGNAL
Dialogue: 0,0:23:12.91,0:23:15.40,Default,,0,0,0,,实际得到的是一个方法 用于取得线路信号值
Dialogue: 0,0:23:16.90,0:23:17.96,Default,,0,0,0,,进一步 我就可以得到信号值
Dialogue: 0,0:23:19.22,0:23:20.52,Default,,0,0,0,,如果我想要设置一个信号值
Dialogue: 0,0:23:22.65,0:23:23.96,Default,,0,0,0,,我想要改变一个信号值
Dialogue: 0,0:23:24.51,0:23:26.76,Default,,0,0,0,,我要做的是
Dialogue: 0,0:23:26.92,0:23:29.69,Default,,0,0,0,,以一个线路和信号的新值作为参数
Dialogue: 0,0:23:30.01,0:23:32.43,Default,,0,0,0,,我向线路请求许可 来设置它的信号值
Dialogue: 0,0:23:32.84,0:23:37.61,Default,,0,0,0,,我会用该许可 -- 也就是一个过程 -- 应用在一个新值上
Dialogue: 0,0:23:38.70,0:23:40.51,Default,,0,0,0,,我们再过来看投影
Dialogue: 0,0:23:41.64,0:23:43.24,Default,,0,0,0,,好的 谢谢
Dialogue: 0,0:23:44.20,0:23:45.63,Default,,0,0,0,,我们看这里的投影
Dialogue: 0,0:23:45.92,0:23:48.75,Default,,0,0,0,,我们看到 如果我请求设置信号的方法
Dialogue: 0,0:23:49.34,0:23:50.44,Default,,0,0,0,,也就是这段代码
Dialogue: 0,0:23:52.25,0:23:55.69,Default,,0,0,0,,返回的是一个定义在线路内部的SET-MY-SIGNAL!方法
Dialogue: 0,0:23:56.25,0:23:57.69,Default,,0,0,0,,回过头来看它的定义
Dialogue: 0,0:23:58.72,0:23:59.74,Default,,0,0,0,,它的定义是
Dialogue: 0,0:24:00.43,0:24:02.68,Default,,0,0,0,,将我的一个内部变量SIGNAL的值设为
Dialogue: 0,0:24:02.73,0:24:05.50,Default,,0,0,0,,这个内部变量 用于存储信号值
Dialogue: 0,0:24:07.61,0:24:10.03,Default,,0,0,0,,将其值设为通过参数传递的NEW
Dialogue: 0,0:24:10.78,0:24:13.01,Default,,0,0,0,,然后调用AP表中的过程 来唤醒它们
Dialogue: 0,0:24:16.34,0:24:16.99,Default,,0,0,0,,非常简单
Dialogue: 0,0:24:19.24,0:24:20.76,Default,,0,0,0,,回头来看刚才的幻灯片
Dialogue: 0,0:24:22.48,0:24:24.32,Default,,0,0,0,,还有最后一点
Dialogue: 0,0:24:24.36,0:24:27.31,Default,,0,0,0,,我想你们现在应该很轻易地就能理解了
Dialogue: 0,0:24:27.77,0:24:29.15,Default,,0,0,0,,关于我们如何添加新的动作过程
Dialogue: 0,0:24:30.10,0:24:35.18,Default,,0,0,0,,我们需要WIRE和ACTION-PROC两个参数
Dialogue: 0,0:24:36.47,0:24:39.31,Default,,0,0,0,,然后请求添加动作过程的许可
Dialogue: 0,0:24:40.05,0:24:44.22,Default,,0,0,0,,得到许可后 用该许可去添加新的动作过程
Dialogue: 0,0:24:45.84,0:24:47.08,Default,,0,0,0,,所以 这确实是一个“对象”
Dialogue: 0,0:24:48.57,0:24:50.32,Default,,0,0,0,,还有些细节
Dialogue: 0,0:24:52.46,0:24:58.39,Default,,0,0,0,,比如 我怎么来控制它？
Dialogue: 0,0:24:58.39,0:24:59.69,Default,,0,0,0,,这些延时怎么实现？
Dialogue: 0,0:25:00.99,0:25:02.54,Default,,0,0,0,,我们来快速过一遍
Dialogue: 0,0:25:05.50,0:25:07.98,Default,,0,0,0,,下一张
Dialogue: 0,0:25:08.36,0:25:08.88,Default,,0,0,0,,我们来看看
Dialogue: 0,0:25:09.57,0:25:14.17,Default,,0,0,0,,我们细看与门、或门的定义
Dialogue: 0,0:25:15.31,0:25:17.00,Default,,0,0,0,,会发现当输入信号改变时
Dialogue: 0,0:25:17.24,0:25:18.19,Default,,0,0,0,,会有“延时”
Dialogue: 0,0:25:18.77,0:25:21.24,Default,,0,0,0,,然后它将调用过程
Dialogue: 0,0:25:21.63,0:25:23.00,Default,,0,0,0,,来改变输出
Dialogue: 0,0:25:26.04,0:25:27.92,Default,,0,0,0,,这个要如何实现？
Dialogue: 0,0:25:28.12,0:25:29.92,Default,,0,0,0,,我们将要建立一种机制
Dialogue: 0,0:25:30.30,0:25:32.00,Default,,0,0,0,,一种相当复杂的机制
Dialogue: 0,0:25:32.33,0:25:33.76,Default,,0,0,0,,我们得非常细心地来看
Dialogue: 0,0:25:34.72,0:25:37.23,Default,,0,0,0,,一段延时之后 我们将执行一个动作
Dialogue: 0,0:25:37.39,0:25:38.12,Default,,0,0,0,,DELAY是一个数
Dialogue: 0,0:25:38.16,0:25:39.23,Default,,0,0,0,,而ACTION是一个过程
Dialogue: 0,0:25:40.59,0:25:43.72,Default,,0,0,0,,我们引入一种称为THE-AGENDA的特殊数据结构
Dialogue: 0,0:25:45.50,0:25:48.80,Default,,0,0,0,,用于组织时间与动作
Dialogue: 0,0:25:49.51,0:25:50.88,Default,,0,0,0,,一会儿再来仔细研究
Dialogue: 0,0:25:50.88,0:25:52.54,Default,,0,0,0,,先把这里说完
Dialogue: 0,0:25:53.07,0:25:58.28,Default,,0,0,0,,THE-AGENDA将记录执行动作的时刻
Dialogue: 0,0:25:59.13,0:26:02.46,Default,,0,0,0,,我们把它设定在未来的某个时刻
Dialogue: 0,0:26:02.51,0:26:05.68,Default,,0,0,0,,也就是在CURRENT-TIME加上DELAT的时刻
Dialogue: 0,0:26:05.69,0:26:07.13,Default,,0,0,0,,触发关联的动作
Dialogue: 0,0:26:09.02,0:26:10.56,Default,,0,0,0,,我们把准备好要执行的动作
Dialogue: 0,0:26:11.02,0:26:12.40,Default,,0,0,0,,添加入THE-AGENDA中
Dialogue: 0,0:26:15.28,0:26:18.03,Default,,0,0,0,,要使这个“机器”运行起来并不困难
Dialogue: 0,0:26:18.66,0:26:21.48,Default,,0,0,0,,我们利用这个PROPAGATE过程来完成这件事
Dialogue: 0,0:26:22.71,0:26:25.95,Default,,0,0,0,,如果THE-AGENDA为空 就没有要做的
Dialogue: 0,0:26:27.44,0:26:28.16,Default,,0,0,0,,否则
Dialogue: 0,0:26:29.76,0:26:31.53,Default,,0,0,0,,我们就取出THE-AGENDA的第一个元素
Dialogue: 0,0:26:31.71,0:26:33.34,Default,,0,0,0,,它是一个无参过程
Dialogue: 0,0:26:34.20,0:26:36.03,Default,,0,0,0,,所以这里有额外的括号
Dialogue: 0,0:26:36.03,0:26:37.85,Default,,0,0,0,,我们对其进行无参调用
Dialogue: 0,0:26:39.19,0:26:40.17,Default,,0,0,0,,这就执行了之前存入的动作
Dialogue: 0,0:26:42.20,0:26:44.17,Default,,0,0,0,,然后我们从THE-AGENDA中删除第一个元素
Dialogue: 0,0:26:44.59,0:26:46.14,Default,,0,0,0,,然后再进入传播循环
Dialogue: 0,0:26:48.91,0:26:50.75,Default,,0,0,0,,这就是整体的结构
Dialogue: 0,0:26:53.38,0:26:55.93,Default,,0,0,0,,还有点其它的
Dialogue: 0,0:26:57.43,0:27:00.01,Default,,0,0,0,,现在 我们来看看THE-AGENDA的内部结构
Dialogue: 0,0:27:00.57,0:27:01.55,Default,,0,0,0,,请看投影仪
Dialogue: 0,0:27:02.80,0:27:04.67,Default,,0,0,0,,该如何使用这个玩意儿呢？
Dialogue: 0,0:27:04.67,0:27:07.41,Default,,0,0,0,,我需要给你们说明下这个模拟器的用法
Dialogue: 0,0:27:07.85,0:27:09.93,Default,,0,0,0,,你们可能觉得这个模拟器太简陋了
Dialogue: 0,0:27:10.40,0:27:12.01,Default,,0,0,0,,甚至你们认为它根本没什么用
Dialogue: 0,0:27:12.57,0:27:13.76,Default,,0,0,0,,而实际上是
Dialogue: 0,0:27:13.98,0:27:15.39,Default,,0,0,0,,这样的模拟器曾被用于
Dialogue: 0,0:27:15.72,0:27:17.44,Default,,0,0,0,,操纵相当大型的计算机
Dialogue: 0,0:27:18.68,0:27:20.64,Default,,0,0,0,,那是一个真实的事例
Dialogue: 0,0:27:22.36,0:27:24.06,Default,,0,0,0,,当然 并不完全是这里的这个模拟器
Dialogue: 0,0:27:24.06,0:27:25.39,Default,,0,0,0,,我会告诉你它们的区别
Dialogue: 0,0:27:25.84,0:27:28.70,Default,,0,0,0,,区别就是 操纵大型机的模拟器有更多的基本元素
Dialogue: 0,0:27:29.82,0:27:32.22,Default,,0,0,0,,不只是有非门 与门之类的
Dialogue: 0,0:27:33.20,0:27:35.72,Default,,0,0,0,,还有边缘触发器
Dialogue: 0,0:27:36.25,0:27:39.88,Default,,0,0,0,,翻转触发器 锁存器
Dialogue: 0,0:27:40.70,0:27:44.52,Default,,0,0,0,,电平触发器 加法器等等之类的
Dialogue: 0,0:27:45.17,0:27:47.31,Default,,0,0,0,,困难之处在于
Dialogue: 0,0:27:47.45,0:27:50.86,Default,,0,0,0,,就在于需要很多页的文档
Dialogue: 0,0:27:51.20,0:27:52.89,Default,,0,0,0,,来描述这些基本元素
Dialogue: 0,0:27:54.69,0:27:56.74,Default,,0,0,0,,同时它们还有很多的参数
Dialogue: 0,0:27:56.74,0:27:57.98,Default,,0,0,0,,不是只有一个延时这么简单
Dialogue: 0,0:27:58.48,0:28:00.81,Default,,0,0,0,,还有建立时间 维持时间之类的
Dialogue: 0,0:28:01.22,0:28:03.40,Default,,0,0,0,,但是 如果不算上那部分的复杂度
Dialogue: 0,0:28:03.82,0:28:08.20,Default,,0,0,0,,我们用来构建真实计算机的模拟器的结构
Dialogue: 0,0:28:09.08,0:28:12.89,Default,,0,0,0,,跟你们在这里看到的的是一致的
Dialogue: 0,0:28:15.11,0:28:19.27,Default,,0,0,0,,无论如何 这里都是一些简单的东西
Dialogue: 0,0:28:19.27,0:28:22.59,Default,,0,0,0,,像这个 设置非门的延时时间 构建一个 AGENDA
Dialogue: 0,0:28:23.03,0:28:25.52,Default,,0,0,0,,我们可以构建一些输入（线路）
Dialogue: 0,0:28:26.03,0:28:29.18,Default,,0,0,0,,这里的四条线路分别是：INPUT-1、INPUT-2、SUM和CARRY
Dialogue: 0,0:28:29.46,0:28:31.88,Default,,0,0,0,,我将要放置一种被称为“探针”的特殊对象
Dialogue: 0,0:28:32.51,0:28:34.64,Default,,0,0,0,,放在一些线路上
Dialogue: 0,0:28:34.97,0:28:36.24,Default,,0,0,0,,放在SUM和CARRY上
Dialogue: 0,0:28:37.23,0:28:40.56,Default,,0,0,0,,探针是一种对象 它可以 --
Dialogue: 0,0:28:40.70,0:28:43.60,Default,,0,0,0,,当你改变它所附着线路的信号时
Dialogue: 0,0:28:43.72,0:28:44.83,Default,,0,0,0,,它会输出一条消息
Dialogue: 0,0:28:46.12,0:28:46.92,Default,,0,0,0,,这很容易实现
Dialogue: 0,0:28:48.44,0:28:49.52,Default,,0,0,0,,一旦我们设置好它们
Dialogue: 0,0:28:49.55,0:28:51.45,Default,,0,0,0,,当你在放置探针的时候
Dialogue: 0,0:28:51.45,0:28:52.41,Default,,0,0,0,,它首先会输出
Dialogue: 0,0:28:52.67,0:28:56.01,Default,,0,0,0,,SUM在0时刻的值为0
Dialogue: 0,0:28:57.29,0:28:58.43,Default,,0,0,0,,这个我已经注意到了
Dialogue: 0,0:28:59.40,0:29:04.75,Default,,0,0,0,,CARRY在0时刻的值也是0
Dialogue: 0,0:29:06.04,0:29:09.28,Default,,0,0,0,,我们继续来构建更多结构
Dialogue: 0,0:29:09.62,0:29:12.28,Default,,0,0,0,,比如 可以像这里一样构建一种结构
Dialogue: 0,0:29:14.06,0:29:18.20,Default,,0,0,0,,用INPUT-1、INPUT-2、SUM和CARRY组成一个半加器
Dialogue: 0,0:29:18.42,0:29:20.42,Default,,0,0,0,,然后我们把INPUT-1上的信号变为1
Dialogue: 0,0:29:20.62,0:29:21.72,Default,,0,0,0,,然后开始传播
Dialogue: 0,0:29:21.88,0:29:22.84,Default,,0,0,0,,在时刻8的时候
Dialogue: 0,0:29:23.90,0:29:26.12,Default,,0,0,0,,如果你想的话 也可以单步跟踪传播过程
Dialogue: 0,0:29:26.52,0:29:29.20,Default,,0,0,0,,SUM的值变为1
Dialogue: 0,0:29:29.52,0:29:30.44,Default,,0,0,0,,然后就结束了
Dialogue: 0,0:29:31.16,0:29:32.25,Default,,0,0,0,,好像没什么意思
Dialogue: 0,0:29:32.63,0:29:33.90,Default,,0,0,0,,我们还可以设置信号
Dialogue: 0,0:29:34.06,0:29:36.73,Default,,0,0,0,,把INPUT-2也变为1
Dialogue: 0,0:29:36.89,0:29:38.09,Default,,0,0,0,,如果再进行传播
Dialogue: 0,0:29:38.36,0:29:39.95,Default,,0,0,0,,在时刻11
Dialogue: 0,0:29:40.12,0:29:41.42,Default,,0,0,0,,CARRY变为1
Dialogue: 0,0:29:41.55,0:29:44.19,Default,,0,0,0,,在时刻16 SUM变为0
Dialogue: 0,0:29:45.39,0:29:48.99,Default,,0,0,0,,如果你仔细研究那个电路图
Dialogue: 0,0:29:48.99,0:29:50.12,Default,,0,0,0,,它确实是这个结果
Dialogue: 0,0:29:50.62,0:29:51.53,Default,,0,0,0,,也并没有什么特别的
Dialogue: 0,0:29:51.53,0:29:54.12,Default,,0,0,0,,但是却清楚地表明了这一些都是如何运作的
Dialogue: 0,0:30:01.83,0:30:03.29,Default,,0,0,0,,我现在给你们展示的是
Dialogue: 0,0:30:03.48,0:30:05.52,Default,,0,0,0,,一种宏观的图景
Dialogue: 0,0:30:06.60,0:30:08.56,Default,,0,0,0,,你如何在一个很大的规模中
Dialogue: 0,0:30:08.72,0:30:12.04,Default,,0,0,0,,你何去实现某种事件驱动的模拟
Dialogue: 0,0:30:13.29,0:30:14.56,Default,,0,0,0,,你应该如何去组织
Dialogue: 0,0:30:14.88,0:30:16.70,Default,,0,0,0,,来获得良好的层次性结构
Dialogue: 0,0:30:16.99,0:30:21.00,Default,,0,0,0,,使得你可以构建可具体化的抽象盒子
Dialogue: 0,0:30:21.56,0:30:24.96,Default,,0,0,0,,但我还没有告诉你AGENDA是如何运作的
Dialogue: 0,0:30:25.78,0:30:26.54,Default,,0,0,0,,下一小节再说
Dialogue: 0,0:30:28.63,0:30:32.94,Default,,0,0,0,,这将涉及到一些关于数据变化之类的事情
Dialogue: 0,0:30:34.31,0:30:35.86,Default,,0,0,0,,在我继续之前 有什么问题吗？
Dialogue: 0,0:30:47.16,0:30:48.24,Default,,0,0,0,,没有的话 那就休息一下
Dialogue: 0,0:30:50.24,0:31:00.62,Default,,0,0,0,,[音乐]
Dialogue: 0,0:31:00.62,0:31:06.00,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:31:11.23,0:31:17.69,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:31:17.76,0:31:21.34,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:31:21.34,0:31:25.18,Declare,,0,0,0,,{\an2\fad(500,500)}计算对象
Dialogue: 0,0:31:28.94,0:31:35.06,Default,,0,0,0,,我们已经做了一个模拟器
Dialogue: 0,0:31:35.39,0:31:37.77,Default,,0,0,0,,这是一种事件驱动的模拟
Dialogue: 0,0:31:38.17,0:31:42.75,Default,,0,0,0,,其中 计算机中的对象与现实中的对象一一对应
Dialogue: 0,0:31:43.92,0:31:47.28,Default,,0,0,0,,现实世界中按时发生的状态改变
Dialogue: 0,0:31:47.98,0:31:50.83,Default,,0,0,0,,被组织成了计算机中的时间
Dialogue: 0,0:31:52.99,0:31:56.04,Default,,0,0,0,,如果现实中某件事后于另一件事发生
Dialogue: 0,0:31:56.46,0:31:57.96,Default,,0,0,0,,那么在计算机中
Dialogue: 0,0:31:58.89,0:32:02.25,Default,,0,0,0,,两个事件也保持同样的先后顺序发生
Dialogue: 0,0:32:04.42,0:32:07.16,Default,,0,0,0,,排列这些时间 就是我们要用到赋值的地方
Dialogue: 0,0:32:08.22,0:32:11.21,Default,,0,0,0,,现在我要介绍一种方法来组织时间
Dialogue: 0,0:32:11.80,0:32:14.86,Default,,0,0,0,,AGENDA -- 或者有时候所谓的“优先队列”
Dialogue: 0,0:32:16.04,0:32:18.57,Default,,0,0,0,,我们首先需要认识到
Dialogue: 0,0:32:18.62,0:32:21.00,Default,,0,0,0,,为了创建AGENDA 我们需要些什么东西？
Dialogue: 0,0:32:28.33,0:32:31.28,Default,,0,0,0,,首先我要在这里写下一些
Dialogue: 0,0:32:31.39,0:32:33.88,Default,,0,0,0,,用于操作AGENDA的基本运算
Dialogue: 0,0:32:35.96,0:32:37.95,Default,,0,0,0,,我不会给出具体代码
Dialogue: 0,0:32:38.14,0:32:39.58,Default,,0,0,0,,因为它们都非常简单
Dialogue: 0,0:32:40.32,0:32:42.60,Default,,0,0,0,,而且你们手上也有
Dialogue: 0,0:32:43.68,0:32:44.38,Default,,0,0,0,,有哪些运算呢？
Dialogue: 0,0:32:44.38,0:32:53.50,Default,,0,0,0,,MAKE-AGENDA可以新建一个AGENDA
Dialogue: 0,0:32:57.36,0:33:01.77,Default,,0,0,0,,CURRENT-TIME可以获得一个AGENDA的当前时间
Dialogue: 0,0:33:07.47,0:33:12.80,Default,,0,0,0,,返回一个数 -- 也就是当前时间
Dialogue: 0,0:33:16.99,0:33:21.37,Default,,0,0,0,,EMPTY-AGENDA?可用于判断一个AGENDA是否为空
Dialogue: 0,0:33:30.20,0:33:32.57,Default,,0,0,0,,返回TRUE或FALSE
Dialogue: 0,0:33:42.72,0:33:44.72,Default,,0,0,0,,我们也可以向AGENDA中添加对象
Dialogue: 0,0:33:52.71,0:33:56.06,Default,,0,0,0,,实际上 向AGENDA中添加的是一个运算 -- 或者说是需要完成的操作
Dialogue: 0,0:33:56.91,0:33:58.14,Default,,0,0,0,,它需要时间TIME
Dialogue: 0,0:33:59.63,0:34:00.56,Default,,0,0,0,,待添加的动作ACTION
Dialogue: 0,0:34:02.86,0:34:04.64,Default,,0,0,0,,以及AGENDA本身
Dialogue: 0,0:34:07.58,0:34:10.25,Default,,0,0,0,,它把ACTION 放入AGENDA中合适的地方
Dialogue: 0,0:34:10.71,0:34:12.73,Default,,0,0,0,,FIRST-ITEM用于从AGENDA取出第一个事项
Dialogue: 0,0:34:14.24,0:34:15.39,Default,,0,0,0,,那是我首先需要做的事情
Dialogue: 0,0:34:21.84,0:34:23.84,Default,,0,0,0,,该事项是一个动作
Dialogue: 0,0:34:26.46,0:34:28.73,Default,,0,0,0,,我还可以把第一个事项从AGENDA中移除
Dialogue: 0,0:34:29.54,0:34:31.16,Default,,0,0,0,,这是操作AGENDA的一个必要运算
Dialogue: 0,0:34:31.40,0:34:33.02,Default,,0,0,0,,这个运算实现起来非常繁杂
Dialogue: 0,0:34:42.53,0:34:43.36,Default,,0,0,0,,从AGENDA中移除
Dialogue: 0,0:34:45.98,0:34:49.85,Default,,0,0,0,,现在我们来看如何具体组织数据结构
Dialogue: 0,0:34:52.96,0:34:56.04,Default,,0,0,0,,AGENDA应该是一种表
Dialogue: 0,0:34:58.43,0:35:01.20,Default,,0,0,0,,一种可修改的表
Dialogue: 0,0:35:01.57,0:35:04.03,Default,,0,0,0,,因为我们要向其中添加元素
Dialogue: 0,0:35:05.80,0:35:06.89,Default,,0,0,0,,删除元素等等
Dialogue: 0,0:35:07.77,0:35:10.27,Default,,0,0,0,,所以我们需要一种可修改的表
Dialogue: 0,0:35:11.07,0:35:12.51,Default,,0,0,0,,它通过时间组织起来
Dialogue: 0,0:35:13.82,0:35:15.57,Default,,0,0,0,,让它有序 也许会有益处
Dialogue: 0,0:35:18.33,0:35:20.88,Default,,0,0,0,,但是也有可能同一时间会发生很多事
Dialogue: 0,0:35:22.04,0:35:23.42,Default,,0,0,0,,或者说几乎同时
Dialogue: 0,0:35:23.80,0:35:24.72,Default,,0,0,0,,因此我们需要
Dialogue: 0,0:35:24.91,0:35:27.52,Default,,0,0,0,,把它们按发生时间为事件分组
Dialogue: 0,0:35:29.04,0:35:31.61,Default,,0,0,0,,所以我要把AGENDA组织成由SEGMENT构成的表
Dialogue: 0,0:35:32.78,0:35:35.69,Default,,0,0,0,,我来画一下这个结构
Dialogue: 0,0:35:36.68,0:35:37.93,Default,,0,0,0,,方便理解
Dialogue: 0,0:35:39.62,0:35:40.49,Default,,0,0,0,,这是一个AGENDA
Dialogue: 0,0:35:41.11,0:35:42.87,Default,,0,0,0,,以一个名字开始
Dialogue: 0,0:35:47.85,0:35:50.19,Default,,0,0,0,,我把它画在表结构的外部
Dialogue: 0,0:35:52.60,0:35:53.39,Default,,0,0,0,,这是它的头部
Dialogue: 0,0:35:54.14,0:35:55.44,Default,,0,0,0,,这个头部的存在也是很必要的
Dialogue: 0,0:35:55.84,0:35:57.63,Default,,0,0,0,,待会你就会知道
Dialogue: 0,0:36:00.68,0:36:03.40,Default,,0,0,0,,再画一个SEGMENT
Dialogue: 0,0:36:03.96,0:36:05.62,Default,,0,0,0,,这是一个由SEGMENT构成的表
Dialogue: 0,0:36:08.31,0:36:10.54,Default,,0,0,0,,假设这个AGENDA有两个SEGMENT
Dialogue: 0,0:36:11.58,0:36:15.07,Default,,0,0,0,,不断对这个表取CAR即可得到
Dialogue: 0,0:36:16.41,0:36:20.57,Default,,0,0,0,,每个SEGMENT都有一个时间
Dialogue: 0,0:36:24.20,0:36:26.64,Default,,0,0,0,,比如说这里是10
Dialogue: 0,0:36:26.83,0:36:30.51,Default,,0,0,0,,也就是说 这个SEGMENT里的事件发生在10时刻
Dialogue: 0,0:36:33.16,0:36:36.52,Default,,0,0,0,,这里是另外一种数据结构
Dialogue: 0,0:36:36.56,0:36:38.01,Default,,0,0,0,,我先不具体描述
Dialogue: 0,0:36:38.49,0:36:41.08,Default,,0,0,0,,它是一个队列 表示在10时刻要做的事
Dialogue: 0,0:36:42.24,0:36:43.33,Default,,0,0,0,,它是一个队列
Dialogue: 0,0:36:43.33,0:36:44.70,Default,,0,0,0,,一会儿再细说
Dialogue: 0,0:36:45.20,0:36:50.35,Default,,0,0,0,,不过抽象地看 队列就是一系列在固定时间要做的事
Dialogue: 0,0:36:50.40,0:36:52.04,Default,,0,0,0,,我可以向其中添加其它要做的事
Dialogue: 0,0:36:53.10,0:36:53.80,Default,,0,0,0,,这是一个队列
Dialogue: 0,0:36:56.14,0:36:59.11,Default,,0,0,0,,这个是时间 这个是SEGMENT
Dialogue: 0,0:37:03.23,0:37:06.36,Default,,0,0,0,,在这个AGENDA中 还有另一个SEGMENT
Dialogue: 0,0:37:08.94,0:37:11.20,Default,,0,0,0,,假设它在30时刻发生
Dialogue: 0,0:37:13.50,0:37:15.92,Default,,0,0,0,,类似地 它也有一个队列
Dialogue: 0,0:37:16.92,0:37:20.24,Default,,0,0,0,,里面是在30时刻要去做的事
Dialogue: 0,0:37:23.21,0:37:25.66,Default,,0,0,0,,当然 我们的AGENDA还需要支持其它操作
Dialogue: 0,0:37:27.09,0:37:29.20,Default,,0,0,0,,假设我想将一个在10时刻发生的事
Dialogue: 0,0:37:29.47,0:37:31.61,Default,,0,0,0,,添加到AGENDA中
Dialogue: 0,0:37:33.03,0:37:34.16,Default,,0,0,0,,这并不难
Dialogue: 0,0:37:34.70,0:37:38.65,Default,,0,0,0,,我遍历到这里 找到时刻是10的SEGMENT
Dialogue: 0,0:37:39.73,0:37:42.14,Default,,0,0,0,,这样的SEGMENT也可能不存在
Dialogue: 0,0:37:42.93,0:37:44.56,Default,,0,0,0,,一会儿再考虑这种情况
Dialogue: 0,0:37:45.42,0:37:47.56,Default,,0,0,0,,如果我找到了时刻为10的SEGMENT
Dialogue: 0,0:37:47.87,0:37:50.43,Default,,0,0,0,,如果我想要把一个事情放入其中
Dialogue: 0,0:37:50.56,0:37:52.16,Default,,0,0,0,,我只要增加该队列即可
Dialogue: 0,0:37:53.85,0:37:56.22,Default,,0,0,0,,这个说起来倒是很容易
Dialogue: 0,0:37:56.57,0:37:59.26,Default,,0,0,0,,我在这里添加需要在那时做的事
Dialogue: 0,0:38:01.43,0:38:04.25,Default,,0,0,0,,现在 假设我想在时刻20做点什么
Dialogue: 0,0:38:05.31,0:38:07.90,Default,,0,0,0,,然而并没有时刻是20的SEGMENT
Dialogue: 0,0:38:08.99,0:38:10.64,Default,,0,0,0,,我不得不构造一个新的SEGMENT
Dialogue: 0,0:38:11.34,0:38:15.64,Default,,0,0,0,,我想把这个SEGMENT 放在10与30之间
Dialogue: 0,0:38:17.61,0:38:19.32,Default,,0,0,0,,这着实要花点功夫
Dialogue: 0,0:38:20.17,0:38:21.52,Default,,0,0,0,,先用CONS
Dialogue: 0,0:38:24.26,0:38:29.94,Default,,0,0,0,,我要为这个AGENDA构建一个新的SEGMENT
Dialogue: 0,0:38:33.60,0:38:34.81,Default,,0,0,0,,这里的连接必须要变
Dialogue: 0,0:38:35.40,0:38:36.30,Default,,0,0,0,,就像这样
Dialogue: 0,0:38:37.54,0:38:42.80,Default,,0,0,0,,我将要修改AGENDA的CDR部分的CDR部分
Dialogue: 0,0:38:44.88,0:38:49.45,Default,,0,0,0,,让它指向一个新的CONS单元
Dialogue: 0,0:38:50.11,0:38:54.65,Default,,0,0,0,,由一个新的SEGMENT和AGENDA的CDDDDR部分所构成的单元
Dialogue: 0,0:38:57.18,0:39:01.88,Default,,0,0,0,,我们有一个发生在20时刻的新的SEGMENT
Dialogue: 0,0:39:02.30,0:39:03.72,Default,,0,0,0,,它自己维护了一个队列
Dialogue: 0,0:39:04.84,0:39:06.29,Default,,0,0,0,,这个队列中只有一个元素
Dialogue: 0,0:39:10.73,0:39:12.52,Default,,0,0,0,,如果我想在后面添加点什么
Dialogue: 0,0:39:12.54,0:39:15.87,Default,,0,0,0,,我就需要替换这个东西的CDR部分
Dialogue: 0,0:39:16.99,0:39:19.21,Default,,0,0,0,,替换掉这个表的CDR部分
Dialogue: 0,0:39:20.59,0:39:23.31,Default,,0,0,0,,我们就对该数据结构进行修改
Dialogue: 0,0:39:24.04,0:39:25.79,Default,,0,0,0,,因此我需要新的基本运算
Dialogue: 0,0:39:27.21,0:39:28.62,Default,,0,0,0,,因为原有的基础运算达不到这一点
Dialogue: 0,0:39:29.44,0:39:33.88,Default,,0,0,0,,如果我想在5时刻做点什么事
Dialogue: 0,0:39:37.12,0:39:39.20,Default,,0,0,0,,我就得去修改这个东西
Dialogue: 0,0:39:40.81,0:39:42.12,Default,,0,0,0,,因为我得添加到这里
Dialogue: 0,0:39:43.29,0:39:46.22,Default,,0,0,0,,这也就是我预留了一个“头”序对的原因
Dialogue: 0,0:39:47.56,0:39:48.59,Default,,0,0,0,,它预留了空间
Dialogue: 0,0:39:49.40,0:39:52.11,Default,,0,0,0,,我需要有空间去做改变
Dialogue: 0,0:39:53.88,0:39:56.56,Default,,0,0,0,,需要有存储空间 去改变
Dialogue: 0,0:39:58.60,0:40:02.54,Default,,0,0,0,,从AGENDA中删除东西并不困难
Dialogue: 0,0:40:02.54,0:40:04.62,Default,,0,0,0,,移除第一个元素相当容易
Dialogue: 0,0:40:04.92,0:40:06.14,Default,,0,0,0,,这也是我需要考虑的唯一情况
Dialogue: 0,0:40:06.49,0:40:10.19,Default,,0,0,0,,我可以先找到第一个SEGMENT
Dialogue: 0,0:40:11.22,0:40:14.00,Default,,0,0,0,,先判断它的队列是否为空
Dialogue: 0,0:40:14.81,0:40:16.17,Default,,0,0,0,,如果队列不是空的
Dialogue: 0,0:40:16.32,0:40:18.62,Default,,0,0,0,,那么 我就会把元素从中删除
Dialogue: 0,0:40:19.21,0:40:19.74,Default,,0,0,0,,像这样
Dialogue: 0,0:40:20.10,0:40:21.92,Default,,0,0,0,,如果这时队列变为空的
Dialogue: 0,0:40:22.64,0:40:24.22,Default,,0,0,0,,就还要继续把SEGMENT删掉
Dialogue: 0,0:40:24.22,0:40:26.49,Default,,0,0,0,,然后 让这个单元指向这里
Dialogue: 0,0:40:28.22,0:40:31.08,Default,,0,0,0,,这个数据结构操作起来很复杂
Dialogue: 0,0:40:32.25,0:40:35.37,Default,,0,0,0,,它的具体实现也不是很有趣
Dialogue: 0,0:40:36.44,0:40:38.48,Default,,0,0,0,,现在我们来探讨一下队列
Dialogue: 0,0:40:38.92,0:40:39.76,Default,,0,0,0,,它们很相似
Dialogue: 0,0:40:41.16,0:40:43.52,Default,,0,0,0,,每一个AGENDA都有一个队列
Dialogue: 0,0:40:44.34,0:40:45.02,Default,,0,0,0,,队列是什么？
Dialogue: 0,0:40:49.47,0:40:51.85,Default,,0,0,0,,队列能够进行下述基本运算：
Dialogue: 0,0:40:52.78,0:41:02.17,Default,,0,0,0,,MAKE-QUEUE构建一个新队列
Dialogue: 0,0:41:07.77,0:41:17.10,Default,,0,0,0,,INSERT-QUEUE!向队列中插入新元素
Dialogue: 0,0:41:24.51,0:41:28.65,Default,,0,0,0,,DELETE-QUEUE!从队列中删除元素
Dialogue: 0,0:41:40.44,0:41:52.04,Default,,0,0,0,,FRONT-QUEUE查看队列中第一个元素
Dialogue: 0,0:41:53.13,0:41:55.14,Default,,0,0,0,,还需要检测队列是否为空
Dialogue: 0,0:42:07.11,0:42:08.70,Default,,0,0,0,,当你定义像这样的运算时
Dialogue: 0,0:42:09.02,0:42:10.44,Default,,0,0,0,,我希望你能够注意
Dialogue: 0,0:42:10.64,0:42:14.09,Default,,0,0,0,,按照我这样的习惯去为它们命名
Dialogue: 0,0:42:15.12,0:42:19.15,Default,,0,0,0,,“!”表示操作具有副作用 “?”代表定义谓词
Dialogue: 0,0:42:19.87,0:42:21.85,Default,,0,0,0,,就比如说 这里应该加上一个“!”
Dialogue: 0,0:42:24.65,0:42:26.96,Default,,0,0,0,,嗯 空检测谓词的“?”也不要遗漏了
Dialogue: 0,0:42:29.24,0:42:30.72,Default,,0,0,0,,那么 我要如何构建一个队列呢？
Dialogue: 0,0:42:31.72,0:42:34.11,Default,,0,0,0,,队列是一种 可以向其尾部添加东西
Dialogue: 0,0:42:35.12,0:42:36.83,Default,,0,0,0,,也可以从前面取出东西的结构
Dialogue: 0,0:42:37.84,0:42:40.51,Default,,0,0,0,,我可以从队列头删除元素 向队列尾添加元素
Dialogue: 0,0:42:41.23,0:42:43.24,Default,,0,0,0,,我可以用一种很简单的结构来实现
Dialogue: 0,0:42:43.88,0:42:45.72,Default,,0,0,0,,我们当然可以使用CONS来构造
Dialogue: 0,0:42:47.08,0:42:47.79,Default,,0,0,0,,这是一个队列
Dialogue: 0,0:42:49.91,0:42:52.36,Default,,0,0,0,,它有一个队列头
Dialogue: 0,0:42:53.58,0:42:54.92,Default,,0,0,0,,它包含两个部分
Dialogue: 0,0:42:55.28,0:42:56.25,Default,,0,0,0,,其中一个是头指针
Dialogue: 0,0:42:58.78,0:42:59.82,Default,,0,0,0,,另一个是尾指针
Dialogue: 0,0:43:03.12,0:43:06.33,Default,,0,0,0,,假设我有一个包含两个元素的队列
Dialogue: 0,0:43:09.13,0:43:12.09,Default,,0,0,0,,假设第一个元素是1
Dialogue: 0,0:43:12.46,0:43:16.53,Default,,0,0,0,,而第二个元素假定是2
Dialogue: 0,0:43:21.40,0:43:23.52,Default,,0,0,0,,我之所以要在这里设置两个指针
Dialogue: 0,0:43:24.09,0:43:25.61,Default,,0,0,0,,一个头指针和一个尾指针
Dialogue: 0,0:43:25.72,0:43:27.10,Default,,0,0,0,,这样 当向尾部添加元素的时候
Dialogue: 0,0:43:27.48,0:43:29.45,Default,,0,0,0,,就不用从最开始开始遍历
Dialogue: 0,0:43:31.85,0:43:34.80,Default,,0,0,0,,例如 我想要向队列添加入一个新元素
Dialogue: 0,0:43:35.26,0:43:41.02,Default,,0,0,0,,如果想添加一个稍后使用的元素
Dialogue: 0,0:43:41.08,0:43:42.40,Default,,0,0,0,,只需要先用CONS构建一个序对
Dialogue: 0,0:43:43.47,0:43:46.59,Default,,0,0,0,,假设它包含一个值 -- 3
Dialogue: 0,0:43:47.53,0:43:51.34,Default,,0,0,0,,再添加到队列里
Dialogue: 0,0:43:51.52,0:43:53.77,Default,,0,0,0,,这里就需要把这个元素CDR部分的指针
Dialogue: 0,0:43:56.94,0:43:58.76,Default,,0,0,0,,指向这个元素
Dialogue: 0,0:44:00.10,0:44:04.32,Default,,0,0,0,,同时也更新尾指针 让它指向新的地方
Dialogue: 0,0:44:09.12,0:44:12.68,Default,,0,0,0,,如果我想查看队列的第一个元素
Dialogue: 0,0:44:12.96,0:44:17.12,Default,,0,0,0,,我只需要通过头指针去寻找 即可轻松找到
Dialogue: 0,0:44:18.89,0:44:23.26,Default,,0,0,0,,如果我想调用DELETE-QUEUE删除元素
Dialogue: 0,0:44:24.14,0:44:26.35,Default,,0,0,0,,只需要把头指针向后移到就行
Dialogue: 0,0:44:27.71,0:44:29.31,Default,,0,0,0,,新的头指针指向这里
Dialogue: 0,0:44:31.70,0:44:33.13,Default,,0,0,0,,就是这么简单
Dialogue: 0,0:44:34.48,0:44:35.76,Default,,0,0,0,,为了实现这些操作
Dialogue: 0,0:44:37.24,0:44:40.83,Default,,0,0,0,,我们还需要一些新的基本运算
Dialogue: 0,0:44:41.48,0:44:42.56,Default,,0,0,0,,我先列出它们的名字
Dialogue: 0,0:44:42.99,0:44:46.28,Default,,0,0,0,,然后我们再来看 它们的原理和使用方法
Dialogue: 0,0:44:47.35,0:44:55.04,Default,,0,0,0,,SET-CAR!能够为序对的CAR部分
Dialogue: 0,0:44:55.88,0:44:59.36,Default,,0,0,0,,赋予一个新的值
Dialogue: 0,0:45:02.37,0:45:09.92,Default,,0,0,0,,SET-CDR!可以为序对的CDR部分赋新值
Dialogue: 0,0:45:13.02,0:45:14.78,Default,,0,0,0,,现在来看看它们到底做了什么
Dialogue: 0,0:45:16.03,0:45:20.51,Default,,0,0,0,,为了删除队列中的第一个元素 我需要修改这里的CAR部分
Dialogue: 0,0:45:20.96,0:45:22.52,Default,,0,0,0,,这是CAR部分 我需要修改它的值
Dialogue: 0,0:45:23.47,0:45:24.96,Default,,0,0,0,,我需要能够修改CDR部分
Dialogue: 0,0:45:25.28,0:45:27.08,Default,,0,0,0,,以便我能够移动尾指针
Dialogue: 0,0:45:27.21,0:45:28.76,Default,,0,0,0,,也使得我能够扩充队列
Dialogue: 0,0:45:30.16,0:45:31.60,Default,,0,0,0,,之前介绍的所有运算
Dialogue: 0,0:45:31.90,0:45:35.90,Default,,0,0,0,,上一块黑板上的所有东西 都是基于这些运算的
Dialogue: 0,0:45:38.17,0:45:40.14,Default,,0,0,0,,先讲到这里 大家休息一下
Dialogue: 0,0:45:41.24,0:45:52.67,Default,,0,0,0,,[音乐]
Dialogue: 0,0:45:52.67,0:45:57.84,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:46:18.64,0:46:22.80,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:46:22.80,0:46:27.15,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:46:27.16,0:46:30.76,Declare,,0,0,0,,{\an2\fad(500,500)}计算对象
Dialogue: 0,0:46:38.81,0:46:43.53,Default,,0,0,0,,最初 我们说序对是通过CONS构造而来的
Dialogue: 0,0:46:44.57,0:46:46.80,Default,,0,0,0,,我们提到了几条公理
Dialogue: 0,0:46:48.09,0:46:50.76,Default,,0,0,0,,它们是怎样的呢？ 它们是形如 --
Dialogue: 0,0:46:52.28,0:47:03.64,Default,,0,0,0,,对于任意的X和Y (CAR (CONS X Y)) = X
Dialogue: 0,0:47:05.31,0:47:12.92,Default,,0,0,0,,以及 (CDR (CONS X Y)) = Y
Dialogue: 0,0:47:14.80,0:47:20.00,Default,,0,0,0,,但是 它们并没有陈述CONS单元 是否有像人一样的“身份”
Dialogue: 0,0:47:21.85,0:47:25.58,Default,,0,0,0,,实际上 它描述的是一种抽象
Dialogue: 0,0:47:25.74,0:47:27.95,Default,,0,0,0,,也就是CONS是由几个部分组成
Dialogue: 0,0:47:29.74,0:47:33.18,Default,,0,0,0,,如果两个CONS组成部分相同的  它俩则是同样的
Dialogue: 0,0:47:33.93,0:47:35.71,Default,,0,0,0,,至少从这些公理来看是这样的
Dialogue: 0,0:47:37.32,0:47:39.21,Default,,0,0,0,,但是引入了赋值以后
Dialogue: 0,0:47:39.84,0:47:42.32,Default,,0,0,0,,实际上 可变数据就是一种赋值
Dialogue: 0,0:47:42.88,0:47:44.43,Default,,0,0,0,,我们有SET-CAR!和SET-CDR!
Dialogue: 0,0:47:45.55,0:47:48.94,Default,,0,0,0,,引入这些运算后 这些公理就不完整了
Dialogue: 0,0:47:49.83,0:47:52.03,Default,,0,0,0,,但是这里写的也是对的
Dialogue: 0,0:47:53.25,0:47:54.94,Default,,0,0,0,,只不过描述的不再完整
Dialogue: 0,0:47:56.07,0:48:01.68,Default,,0,0,0,,因为如果我要修改一个特定的CONS的CAR部分
Dialogue: 0,0:48:03.02,0:48:04.03,Default,,0,0,0,,问题是
Dialogue: 0,0:48:04.24,0:48:08.64,Default,,0,0,0,,我会同时修改到相同CONS单元的CAR部分么？
Dialogue: 0,0:48:10.09,0:48:13.04,Default,,0,0,0,,假如我用CONS来构建有理数
Dialogue: 0,0:48:14.86,0:48:17.10,Default,,0,0,0,,比如说3/4
Dialogue: 0,0:48:17.34,0:48:20.25,Default,,0,0,0,,假设我有两个3/4
Dialogue: 0,0:48:21.57,0:48:22.75,Default,,0,0,0,,这两个一样吗？
Dialogue: 0,0:48:24.06,0:48:24.89,Default,,0,0,0,,或者又不一样？
Dialogue: 0,0:48:25.34,0:48:26.96,Default,,0,0,0,,当然 对于数字来说 这并不重要
Dialogue: 0,0:48:27.86,0:48:30.49,Default,,0,0,0,,修改一个数的分母并没有数学意义
Dialogue: 0,0:48:33.02,0:48:35.32,Default,,0,0,0,,我们只能够说创建一个数 具有不同的分母
Dialogue: 0,0:48:36.84,0:48:39.88,Default,,0,0,0,,而直接修改一个数的分母这种观念
Dialogue: 0,0:48:40.00,0:48:43.58,Default,,0,0,0,,在数学意义上是一种非常奇怪而不受支持的行为
Dialogue: 0,0:48:44.77,0:48:47.40,Default,,0,0,0,,然而 当这些CONS单元表示的是现实世界中的事物
Dialogue: 0,0:48:48.97,0:48:50.43,Default,,0,0,0,,那么修改它的CAR部分
Dialogue: 0,0:48:50.60,0:48:52.20,Default,,0,0,0,,就像除掉指甲壳的一块一样
Dialogue: 0,0:48:53.69,0:48:56.56,Default,,0,0,0,,所以 每一个CONS都有自己的“身份”
Dialogue: 0,0:48:57.77,0:48:59.92,Default,,0,0,0,,我来先说明“身份”是什么意思
Dialogue: 0,0:49:01.28,0:49:03.05,Default,,0,0,0,,来看些例子
Dialogue: 0,0:49:04.32,0:49:15.20,Default,,0,0,0,,假如(DEFINE A (CONS 1 2))
Dialogue: 0,0:49:18.32,0:49:19.76,Default,,0,0,0,,这是代表什么呢？ 首先
Dialogue: 0,0:49:20.67,0:49:25.20,Default,,0,0,0,,这是说我在某个环境中创建了符号A
Dialogue: 0,0:49:25.96,0:49:28.67,Default,,0,0,0,,而它的值是一个序对
Dialogue: 0,0:49:29.47,0:49:34.06,Default,,0,0,0,,这个序对由两个分别指向1和2的指针组成
Dialogue: 0,0:49:35.34,0:49:36.16,Default,,0,0,0,,就像这样
Dialogue: 0,0:49:38.12,0:49:39.60,Default,,0,0,0,,又假设
Dialogue: 0,0:49:40.22,0:49:47.58,Default,,0,0,0,,(DEFINE B (CONS A A))
Dialogue: 0,0:49:53.88,0:49:56.81,Default,,0,0,0,,虽然无所谓 不过我还是更喜欢用大写
Dialogue: 0,0:49:57.63,0:49:59.88,Default,,0,0,0,,(DEFINE B (CONS A A))
Dialogue: 0,0:50:03.97,0:50:06.03,Default,,0,0,0,,这里用了两次A
Dialogue: 0,0:50:07.84,0:50:10.57,Default,,0,0,0,,现在就要考虑序对的身份问题了
Dialogue: 0,0:50:11.30,0:50:12.64,Default,,0,0,0,,这两个A是同一个东西
Dialogue: 0,0:50:13.69,0:50:14.81,Default,,0,0,0,,这也就是说
Dialogue: 0,0:50:15.29,0:50:17.61,Default,,0,0,0,,我创建了另一个序对
Dialogue: 0,0:50:18.81,0:50:20.20,Default,,0,0,0,,我把它记作B
Dialogue: 0,0:50:22.38,0:50:27.60,Default,,0,0,0,,它由两个指向A的指针组成
Dialogue: 0,0:50:28.92,0:50:32.20,Default,,0,0,0,,对于这个对象来说 此时我有三个名字来指称它
Dialogue: 0,0:50:33.10,0:50:34.16,Default,,0,0,0,,A是一个
Dialogue: 0,0:50:34.88,0:50:36.46,Default,,0,0,0,,(CAR B)是一个
Dialogue: 0,0:50:37.23,0:50:38.86,Default,,0,0,0,,(CDR B)也是一个
Dialogue: 0,0:50:39.36,0:50:41.15,Default,,0,0,0,,都是这个序对的别名
Dialogue: 0,0:50:44.23,0:50:49.28,Default,,0,0,0,,假设现在我要执行
Dialogue: 0,0:50:53.77,0:51:08.38,Default,,0,0,0,,(SET-CAR! (CAR B) 3)
Dialogue: 0,0:51:12.75,0:51:17.45,Default,,0,0,0,,我先去找B的CAR部分 也就是它
Dialogue: 0,0:51:17.83,0:51:20.93,Default,,0,0,0,,再修改它的CAR部分 修改为3
Dialogue: 0,0:51:24.76,0:51:25.69,Default,,0,0,0,,这样我也就修改了A
Dialogue: 0,0:51:27.24,0:51:33.64,Default,,0,0,0,,如果我问 现在A的CAR部分是多少
Dialogue: 0,0:51:35.34,0:51:37.56,Default,,0,0,0,,结果是3
Dialogue: 0,0:51:38.68,0:51:43.39,Default,,0,0,0,,尽管在这里 A是由1和2构成的序对
Dialogue: 0,0:51:45.29,0:51:47.44,Default,,0,0,0,,我通过改变B而改变了A
Dialogue: 0,0:51:48.56,0:51:49.64,Default,,0,0,0,,它们之间存在共享
Dialogue: 0,0:51:52.25,0:51:53.47,Default,,0,0,0,,有时候我们需要这样的结构
Dialogue: 0,0:51:54.24,0:51:56.12,Default,,0,0,0,,当然 在类似于队列这类的数据结构中
Dialogue: 0,0:51:56.24,0:52:02.38,Default,,0,0,0,,我们正是这样来定义、组织数据结果来获得数据共享的
Dialogue: 0,0:52:04.35,0:52:05.66,Default,,0,0,0,,但是有一些非预期的共享
Dialogue: 0,0:52:07.76,0:52:09.72,Default,,0,0,0,,对象间的非预期交互
Dialogue: 0,0:52:10.78,0:52:14.08,Default,,0,0,0,,是大型程序中产生的BUG的主要来源
Dialogue: 0,0:52:15.44,0:52:21.66,Default,,0,0,0,,通过使对象具有“身份”、允许共享
Dialogue: 0,0:52:21.87,0:52:23.76,Default,,0,0,0,,给同一个对象取多个别名
Dialogue: 0,0:52:24.08,0:52:25.05,Default,,0,0,0,,我们获得了强大的能力
Dialogue: 0,0:52:25.13,0:52:28.46,Default,,0,0,0,,但是同时也为此引出的BUG和复杂度而付出代价
Dialogue: 0,0:52:32.19,0:52:36.24,Default,,0,0,0,,为了把这个讲透彻一点 我们再举一个例子
Dialogue: 0,0:52:37.10,0:52:39.87,Default,,0,0,0,,比如(CADR B)
Dialogue: 0,0:52:42.46,0:52:46.56,Default,,0,0,0,,看起来和(CAR B)没有一点关系
Dialogue: 0,0:52:46.88,0:52:49.02,Default,,0,0,0,,但是它的值是什么？
Dialogue: 0,0:52:49.35,0:52:53.56,Default,,0,0,0,,先取B的CDR部分 再取结果的CAR部分
Dialogue: 0,0:52:53.56,0:52:54.86,Default,,0,0,0,,哦 还是3
Dialogue: 0,0:52:56.48,0:53:00.43,Default,,0,0,0,,有了共享这样的机制 局部的含义也不是那么清楚了
Dialogue: 0,0:53:01.12,0:53:02.48,Default,,0,0,0,,所以我们要非常小心的操作
Dialogue: 0,0:53:06.64,0:53:12.64,Default,,0,0,0,,目前为止 我已经介绍了好几个赋值运算
Dialogue: 0,0:53:13.18,0:53:17.61,Default,,0,0,0,,比如SET!、SET-CAR!、SET-CDR!
Dialogue: 0,0:53:18.51,0:53:21.39,Default,,0,0,0,,或许我应该不用SET-CAR!、SET-CDR! 它们引入太多问题了
Dialogue: 0,0:53:22.82,0:53:23.66,Default,,0,0,0,,而事实则是
Dialogue: 0,0:53:24.12,0:53:26.11,Default,,0,0,0,,一旦把骆驼的鼻子牵进帐篷
Dialogue: 0,0:53:26.24,0:53:27.34,Default,,0,0,0,,它的身体可就自己跟进来了
Dialogue: 0,0:53:30.16,0:53:31.26,Default,,0,0,0,,只要有SET!
Dialogue: 0,0:53:31.61,0:53:35.85,Default,,0,0,0,,这些糟糕的东西都可能发生
Dialogue: 0,0:53:38.55,0:53:39.80,Default,,0,0,0,,我们来分析一下
Dialogue: 0,0:53:40.69,0:53:43.72,Default,,0,0,0,,前些日子 讲到复合数据的时候
Dialogue: 0,0:53:45.13,0:53:51.20,Default,,0,0,0,,哈罗德教授向你们展示了 用消息接收的方式来定义CONS
Dialogue: 0,0:53:52.48,0:53:56.06,Default,,0,0,0,,我将给你们展示一种更加糟糕的方式
Dialogue: 0,0:53:57.13,0:54:00.04,Default,,0,0,0,,凭“空”定义CONS
Dialogue: 0,0:54:02.56,0:54:03.02,Default,,0,0,0,,“什么”都不用
Dialogue: 0,0:54:04.44,0:54:08.12,Default,,0,0,0,,用传统的函数式的方法如何定义CONS呢？
Dialogue: 0,0:54:09.26,0:54:11.66,Default,,0,0,0,,纯粹只用LAMBDA表达式
Dialogue: 0,0:54:13.39,0:54:14.40,Default,,0,0,0,,把序对表示成过程
Dialogue: 0,0:54:17.39,0:54:19.66,Default,,0,0,0,,现在我要修改这个定义
Dialogue: 0,0:54:20.30,0:54:23.16,Default,,0,0,0,,使得只具有一种赋值
Dialogue: 0,0:54:24.28,0:54:27.93,Default,,0,0,0,,用SET!来代替SET-CAR!和SET-CDR!
Dialogue: 0,0:54:28.58,0:54:37.39,Default,,0,0,0,,如果我把CONS定义为
Dialogue: 0,0:54:38.91,0:54:42.56,Default,,0,0,0,,定义为一个过程 该过程接收参数M
Dialogue: 0,0:54:43.39,0:54:46.32,Default,,0,0,0,,该过程将M应用在X与Y上
Dialogue: 0,0:54:51.12,0:54:53.10,Default,,0,0,0,,这是阿隆佐·丘奇发明的方法
Dialogue: 0,0:54:53.77,0:54:55.72,Default,,0,0,0,,他是20世纪最伟大的程序员
Dialogue: 0,0:54:55.79,0:54:57.15,Default,,0,0,0,,尽管当时电脑还没有被发明
Dialogue: 0,0:54:57.87,0:54:59.13,Default,,0,0,0,,但他在20世纪30年代就提出了这个方法
Dialogue: 0,0:54:59.42,0:55:02.22,Default,,0,0,0,,他是一个逻辑学家 在普林斯顿大学做研究
Dialogue: 0,0:55:08.66,0:55:10.43,Default,,0,0,0,,定义(CAR X)为
Dialogue: 0,0:55:13.10,0:55:16.92,Default,,0,0,0,,把X应用在一个二元过程上
Dialogue: 0,0:55:17.15,0:55:20.60,Default,,0,0,0,,参数分别是A和D 而结果是选出A
Dialogue: 0,0:55:23.71,0:55:24.97,Default,,0,0,0,,而(CDR X)则是
Dialogue: 0,0:55:33.10,0:55:34.78,Default,,0,0,0,,这样的一个过程
Dialogue: 0,0:55:35.08,0:55:40.25,Default,,0,0,0,,把X应用在一个参数分别是A和D的过程上
Dialogue: 0,0:55:40.92,0:55:42.04,Default,,0,0,0,,该过程选择出D
Dialogue: 0,0:55:46.67,0:55:49.88,Default,,0,0,0,,可能你们还没意识到这些就是CAR、CDR和CONS
Dialogue: 0,0:55:50.51,0:55:53.61,Default,,0,0,0,,但我将要给你们演示它符合之前的公理
Dialogue: 0,0:55:54.11,0:55:54.81,Default,,0,0,0,,举一个例子
Dialogue: 0,0:55:55.61,0:55:57.56,Default,,0,0,0,,我们来看一下
Dialogue: 0,0:55:58.29,0:56:06.27,Default,,0,0,0,,考虑一下语句语句(CAR (CONS 35 47))
Dialogue: 0,0:56:09.93,0:56:10.96,Default,,0,0,0,,它的结果是多少呢？
Dialogue: 0,0:56:11.12,0:56:15.24,Default,,0,0,0,,它是通过把35和47代换进
Dialogue: 0,0:56:15.37,0:56:18.20,Default,,0,0,0,,语句体中的X和Y得到的
Dialogue: 0,0:56:19.71,0:56:20.69,Default,,0,0,0,,非常容易
Dialogue: 0,0:56:20.69,0:56:30.88,Default,,0,0,0,,就得到了语句(CAR (LAMBDA (M) (M 35 47)))
Dialogue: 0,0:56:35.53,0:56:39.36,Default,,0,0,0,,这个的结果是把这个对象
Dialogue: 0,0:56:39.44,0:56:41.85,Default,,0,0,0,,代换进这里的X而得到的
Dialogue: 0,0:56:42.83,0:56:47.66,Default,,0,0,0,,代换的结果是((LAMBDA (M --
Dialogue: 0,0:56:48.33,0:56:52.19,Default,,0,0,0,,用这个对象代换这里的X
Dialogue: 0,0:56:52.88,0:56:54.35,Default,,0,0,0,,这是表的头部
Dialogue: 0,0:56:54.88,0:57:00.32,Default,,0,0,0,,体的部分是(M 35 47)
Dialogue: 0,0:57:03.10,0:57:07.31,Default,,0,0,0,,把它应用于一个参数分别的A和D的过程上
Dialogue: 0,0:57:07.48,0:57:08.67,Default,,0,0,0,,后者返回参数A
Dialogue: 0,0:57:10.91,0:57:14.62,Default,,0,0,0,,然后我们用这个来代换这里的M
Dialogue: 0,0:57:15.96,0:57:21.71,Default,,0,0,0,,这个就相当于把(LAMBDA (A D) A)
Dialogue: 0,0:57:22.22,0:57:24.84,Default,,0,0,0,,应用在35和47上
Dialogue: 0,0:57:26.33,0:57:27.37,Default,,0,0,0,,结果就是35
Dialogue: 0,0:57:27.40,0:57:31.21,Default,,0,0,0,,它就是用35和47分别代换A、D 最后返回A
Dialogue: 0,0:57:35.60,0:57:37.24,Default,,0,0,0,,所以我根本不需要任何数据
Dialogue: 0,0:57:37.88,0:57:38.75,Default,,0,0,0,,甚至连数字都不需要
Dialogue: 0,0:57:40.92,0:57:42.64,Default,,0,0,0,,这就是 阿隆佐·邱奇的技巧
Dialogue: 0,0:57:52.42,0:57:56.17,Default,,0,0,0,,现在呢我们来对这个定义做点修改
Dialogue: 0,0:57:56.76,0:57:58.49,Default,,0,0,0,,作为逻辑学家 他可能会不太开心
Dialogue: 0,0:57:59.20,0:58:01.96,Default,,0,0,0,,但作为程序员 -- 请看投影仪
Dialogue: 0,0:58:03.26,0:58:04.16,Default,,0,0,0,,我们来看看
Dialogue: 0,0:58:05.39,0:58:07.58,Default,,0,0,0,,我修改了CONS的定义
Dialogue: 0,0:58:09.57,0:58:12.35,Default,,0,0,0,,和丘奇的定义很相似 但是不完全相同
Dialogue: 0,0:58:14.41,0:58:15.50,Default,,0,0,0,,具体到底是什么？
Dialogue: 0,0:58:16.07,0:58:18.72,Default,,0,0,0,,CONS有两个参数：X和Y
Dialogue: 0,0:58:19.50,0:58:22.51,Default,,0,0,0,,但它返回一个参数为M的过程
Dialogue: 0,0:58:23.39,0:58:25.64,Default,,0,0,0,,跟之前一样M会应用于X和Y上
Dialogue: 0,0:58:26.19,0:58:29.29,Default,,0,0,0,,但它额外还有两个“许可”
Dialogue: 0,0:58:30.17,0:58:32.01,Default,,0,0,0,,其中一个是把X赋值为N
Dialogue: 0,0:58:32.60,0:58:34.40,Default,,0,0,0,,另一个则是把Y赋值为N
Dialogue: 0,0:58:34.44,0:58:35.68,Default,,0,0,0,,只要我提供了相应的N
Dialogue: 0,0:58:40.94,0:58:44.72,Default,,0,0,0,,所以出了邱奇原本的定义之外
Dialogue: 0,0:58:45.72,0:58:51.66,Default,,0,0,0,,最大的不同在于CONS的返回值
Dialogue: 0,0:58:52.12,0:58:53.82,Default,,0,0,0,,不单会把它的参数应用于
Dialogue: 0,0:58:54.91,0:58:59.44,Default,,0,0,0,,用于构成序对的X和Y之上
Dialogue: 0,0:58:59.69,0:59:03.58,Default,,0,0,0,,它还有用于为X和Y赋值的两个“许可”
Dialogue: 0,0:59:06.54,0:59:08.08,Default,,0,0,0,,当然 就如之前一样
Dialogue: 0,0:59:08.83,0:59:10.51,Default,,0,0,0,,CAR看起来也很相似
Dialogue: 0,0:59:11.69,0:59:14.36,Default,,0,0,0,,就像邱奇定义的那样
Dialogue: 0,0:59:14.54,0:59:16.00,Default,,0,0,0,,(CAR X)只不过是把X应用在
Dialogue: 0,0:59:16.86,0:59:19.00,Default,,0,0,0,,过程上 -- 本例中是四个参数
Dialogue: 0,0:59:19.29,0:59:21.04,Default,,0,0,0,,然后从中选出第一个
Dialogue: 0,0:59:22.54,0:59:24.16,Default,,0,0,0,,这就和之前一样
Dialogue: 0,0:59:25.42,0:59:26.96,Default,,0,0,0,,结果将会返回X
Dialogue: 0,0:59:29.04,0:59:35.40,Default,,0,0,0,,X的值被包含在求值这个LAMBDA表达式所产生的过程中
Dialogue: 0,0:59:35.45,0:59:37.84,Default,,0,0,0,,X和Y的值也是在这个环境中定义的
Dialogue: 0,0:59:41.94,0:59:43.15,Default,,0,0,0,,这是我们对CONS的定义
Dialogue: 0,0:59:45.64,0:59:47.53,Default,,0,0,0,,那么 激动人心的地方来了
Dialogue: 0,0:59:47.73,0:59:48.96,Default,,0,0,0,,当然CDR的定义也类似
Dialogue: 0,0:59:49.39,0:59:50.35,Default,,0,0,0,,激动人心的地方
Dialogue: 0,0:59:51.23,0:59:52.52,Default,,0,0,0,,SET-CAR!和SET-CDR!的实现
Dialogue: 0,0:59:53.45,0:59:55.52,Default,,0,0,0,,说实话 它们也不是特别复杂
Dialogue: 0,0:59:55.80,1:00:00.64,Default,,0,0,0,,语句(SET-CAR! X Y)
Dialogue: 0,1:00:01.63,1:00:03.85,Default,,0,0,0,,无非就是把序对X应用于
Dialogue: 0,1:00:04.11,1:00:06.76,Default,,0,0,0,,注意X是一个一元过程
Dialogue: 0,1:00:07.69,1:00:09.80,Default,,0,0,0,,该过程的体是将参数应用在四个对象上
Dialogue: 0,1:00:11.24,1:00:15.85,Default,,0,0,0,,我们把X应用于一个四元过程上
Dialogue: 0,1:00:16.00,1:00:18.08,Default,,0,0,0,,X的值、Y的值
Dialogue: 0,1:00:18.32,1:00:20.54,Default,,0,0,0,,修改X的许可、修改Y的许可
Dialogue: 0,1:00:21.32,1:00:26.09,Default,,0,0,0,,语句的体则是用相应的许可 将X设置为新的值
Dialogue: 0,1:00:31.65,1:00:33.54,Default,,0,0,0,,当然SET-CDR!和它类似
Dialogue: 0,1:00:36.25,1:00:39.44,Default,,0,0,0,,你也看到了 我这里并没有引入新的基本运算
Dialogue: 0,1:00:40.11,1:00:44.36,Default,,0,0,0,,具体要不要这样来实现是一个工程性问题
Dialogue: 0,1:00:45.34,1:00:47.39,Default,,0,0,0,,当然出于工程上的考量
Dialogue: 0,1:00:48.09,1:00:49.63,Default,,0,0,0,,我不会这样来实现
Dialogue: 0,1:00:51.68,1:00:53.40,Default,,0,0,0,,但是从原理上来说
Dialogue: 0,1:00:54.28,1:00:56.43,Default,,0,0,0,,一旦引入了赋值运算
Dialogue: 0,1:00:56.96,1:00:58.76,Default,,0,0,0,,我就可以进行各种各样的赋值运算了
Dialogue: 0,1:01:05.42,1:01:06.67,Default,,0,0,0,,有什么问题吗？
Dialogue: 0,1:01:09.20,1:01:10.89,Default,,0,0,0,,请讲
Dialogue: 0,1:01:12.04,1:01:15.64,Default,,0,0,0,,我可以跟的上你的思路 直到 --
Dialogue: 0,1:01:15.64,1:01:17.61,Default,,0,0,0,,在许可那里
Dialogue: 0,1:01:18.14,1:01:21.64,Default,,0,0,0,,我们把CONS定义为一个参数为N的过程
Dialogue: 0,1:01:21.80,1:01:24.21,Default,,0,0,0,,我不知道这个参数是什么时候传进来的
Dialogue: 0,1:01:24.21,1:01:25.69,Default,,0,0,0,,教授：哦 抱歉 我给你演示一下
Dialogue: 0,1:01:26.34,1:01:27.05,Default,,0,0,0,,我们来推演一下
Dialogue: 0,1:01:27.36,1:01:29.07,Default,,0,0,0,,虽然在黑板上推演更清晰
Dialogue: 0,1:01:29.18,1:01:30.17,Default,,0,0,0,,但这并不难懂
Dialogue: 0,1:01:30.17,1:01:31.47,Default,,0,0,0,,我就将就用投影仪了
Dialogue: 0,1:01:32.45,1:01:35.79,Default,,0,0,0,,调用(SET-CDR! X Y)会发生什么呢？
Dialogue: 0,1:01:37.79,1:01:39.66,Default,,0,0,0,,就在这里(SET-CDR! X Y)
Dialogue: 0,1:01:40.36,1:01:41.92,Default,,0,0,0,,X可能是一个序对
Dialogue: 0,1:01:43.31,1:01:45.24,Default,,0,0,0,,或者说对一个CONS表达式求值得到的结果
Dialogue: 0,1:01:45.88,1:01:46.35,Default,,0,0,0,,能跟上吧？
Dialogue: 0,1:01:46.89,1:01:49.96,Default,,0,0,0,,也就是说 X是由这里的代码构造出来的
Dialogue: 0,1:01:52.57,1:01:56.49,Default,,0,0,0,,这里的X是求值这个LAMBDA表达式得到的
Dialogue: 0,1:01:58.11,1:01:58.49,Default,,0,0,0,,对吧
Dialogue: 0,1:01:59.38,1:02:01.63,Default,,0,0,0,,因此当我对这个LAMBDA表达式求值时
Dialogue: 0,1:02:04.01,1:02:08.76,Default,,0,0,0,,我是在定义CONS时的一个环境里求值的
Dialogue: 0,1:02:11.75,1:02:15.18,Default,,0,0,0,,这也就是说 作为LAMBDA表达式中的自由变量
Dialogue: 0,1:02:16.25,1:02:18.68,Default,,0,0,0,,X和Y都存储一个框架中
Dialogue: 0,1:02:18.72,1:02:22.44,Default,,0,0,0,,也就是这整个LAMBDA表达式的父框架
Dialogue: 0,1:02:23.23,1:02:25.82,Default,,0,0,0,,因此在这个LAMBDA语句中
Dialogue: 0,1:02:26.65,1:02:28.51,Default,,0,0,0,,X和Y都有存储空间
Dialogue: 0,1:02:29.25,1:02:30.83,Default,,0,0,0,,也可以对它们赋值
Dialogue: 0,1:02:31.91,1:02:36.08,Default,,0,0,0,,这里赋值为N是通过参数来传递的
Dialogue: 0,1:02:37.26,1:02:39.31,Default,,0,0,0,,“许可”就是一个过程
Dialogue: 0,1:02:41.40,1:02:43.18,Default,,0,0,0,,它将作为M的一个参数
Dialogue: 0,1:02:43.29,1:02:46.51,Default,,0,0,0,,它实际上是CONS生成的对象的一部分
Dialogue: 0,1:02:47.94,1:02:50.91,Default,,0,0,0,,我们再来看看SET-CDR!
Dialogue: 0,1:02:52.11,1:02:55.42,Default,,0,0,0,,SET-CDR!的第一个参数X是一个序对
Dialogue: 0,1:02:56.12,1:02:57.48,Default,,0,0,0,,被传递了一个参数
Dialogue: 0,1:02:59.77,1:03:02.22,Default,,0,0,0,,这个是一个四元过程
Dialogue: 0,1:03:02.32,1:03:04.65,Default,,0,0,0,,这是因为 它要作为这里的M
Dialogue: 0,1:03:04.99,1:03:06.56,Default,,0,0,0,,要应用在四个对象上
Dialogue: 0,1:03:07.92,1:03:13.34,Default,,0,0,0,,这边的这个SD 就对应于这个过程
Dialogue: 0,1:03:15.47,1:03:19.93,Default,,0,0,0,,当我执行SD 把它应用于Y
Dialogue: 0,1:03:22.91,1:03:24.04,Default,,0,0,0,,这个Y是这里传过来的
Dialogue: 0,1:03:25.37,1:03:26.92,Default,,0,0,0,,学生：那--
Dialogue: 0,1:03:27.00,1:03:32.19,Default,,0,0,0,,教授：所以说 这里的N就对应于这里的Y
Dialogue: 0,1:03:34.04,1:03:34.52,Default,,0,0,0,,明白了吧
Dialogue: 0,1:03:34.81,1:03:35.75,Default,,0,0,0,,了解了
Dialogue: 0,1:03:35.75,1:03:37.29,Default,,0,0,0,,当你执行SET-CDR!的时候
Dialogue: 0,1:03:39.07,1:03:41.97,Default,,0,0,0,,X是CDR部分要赋值的新值
Dialogue: 0,1:03:41.97,1:03:44.03,Default,,0,0,0,,教授：这里的X
Dialogue: 0,1:03:44.96,1:03:46.20,Default,,0,0,0,,哦 指错了
Dialogue: 0,1:03:46.20,1:03:48.33,Default,,0,0,0,,这里的X是指 -- SET-CDR!有两个参数
Dialogue: 0,1:03:48.91,1:03:50.36,Default,,0,0,0,,一个是被修改的序对
Dialogue: 0,1:03:51.34,1:03:53.93,Default,,0,0,0,,还有就是新值
Dialogue: 0,1:03:56.15,1:03:58.32,Default,,0,0,0,,你可以代换回去看看 就很清楚了
Dialogue: 0,1:04:02.17,1:04:03.16,Default,,0,0,0,,还有什么问题吗？
Dialogue: 0,1:04:07.88,1:04:08.64,Default,,0,0,0,,好的
Dialogue: 0,1:04:08.64,1:04:09.52,Default,,0,0,0,,这节课就到这里
Dialogue: 0,1:04:10.44,1:04:28.73,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:04:10.44,1:04:28.73,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
