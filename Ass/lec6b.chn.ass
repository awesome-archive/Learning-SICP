[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:03.10,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:04.09,0:00:12.08,title,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:04.09,0:00:12.08,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N张大伟\N（DreamAndDead）
Dialogue: 0,0:00:04.09,0:00:12.08,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:04.09,0:00:12.08,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:04.09,0:00:12.08,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:12.54,0:00:17.00,Declare,,0,0,0,,{\an2\fad(500,500)}流 II
Dialogue: 0,0:00:20.97,0:00:24.08,Default,,0,0,0,,教授：上节课 我们介绍了流
Dialogue: 0,0:00:24.08,0:00:27.82,Default,,0,0,0,,按照信号处理的方式来组织系统
Dialogue: 0,0:00:28.87,0:00:31.42,Default,,0,0,0,,要记住的是 关键点在于
Dialogue: 0,0:00:31.90,0:00:32.96,Default,,0,0,0,,我们分离开
Dialogue: 0,0:00:34.20,0:00:37.31,Default,,0,0,0,,程序中 事件表面上的顺序
Dialogue: 0,0:00:37.58,0:00:40.17,Default,,0,0,0,,与机器中的实际计算顺序
Dialogue: 0,0:00:41.07,0:00:42.28,Default,,0,0,0,,那就意味着 我们可以
Dialogue: 0,0:00:42.57,0:00:44.14,Default,,0,0,0,,着手处理非常长的流
Dialogue: 0,0:00:44.89,0:00:47.39,Default,,0,0,0,,并且只有在需要的时候才生成其中的元素
Dialogue: 0,0:00:47.53,0:00:49.39,Default,,0,0,0,,这种按需计算的方式
Dialogue: 0,0:00:49.52,0:00:51.40,Default,,0,0,0,,是内建在流的数据结构中的
Dialogue: 0,0:00:54.11,0:00:55.64,Default,,0,0,0,,即使这个流非常之长
Dialogue: 0,0:00:55.66,0:00:57.08,Default,,0,0,0,,我们只计算所需要的
Dialogue: 0,0:00:58.04,0:01:00.75,Default,,0,0,0,,只有当我们要求的时候 新的数据才会生成
Dialogue: 0,0:01:00.75,0:01:01.74,Default,,0,0,0,,要举个什么样的例子呢？
Dialogue: 0,0:01:02.11,0:01:03.60,Default,,0,0,0,,这个“按需”是什么个情况呢？
Dialogue: 0,0:01:05.02,0:01:06.01,Default,,0,0,0,,举个例子
Dialogue: 0,0:01:09.21,0:01:11.37,Default,,0,0,0,,我们可能会想要一个流中的第N个元素
Dialogue: 0,0:01:15.36,0:01:18.92,Default,,0,0,0,,这个过程可以用于计算流的第N个元素
Dialogue: 0,0:01:20.09,0:01:21.23,Default,,0,0,0,,一个参数为索引N
Dialogue: 0,0:01:21.24,0:01:22.84,Default,,0,0,0,,另一个参数是流S
Dialogue: 0,0:01:23.40,0:01:25.42,Default,,0,0,0,,递归遍历这个流即可求解
Dialogue: 0,0:01:25.57,0:01:27.39,Default,,0,0,0,,如果N为0 我们就计算头部分
Dialogue: 0,0:01:27.96,0:01:30.99,Default,,0,0,0,,否则 就在流的尾部分
Dialogue: 0,0:01:31.74,0:01:32.80,Default,,0,0,0,,查找第N-1个元素
Dialogue: 0,0:01:34.31,0:01:36.43,Default,,0,0,0,,看起来是Lisp中很普通的编程方式 但是不同的是
Dialogue: 0,0:01:36.62,0:01:38.76,Default,,0,0,0,,直到我们不断遍历 取得相继的N个元素
Dialogue: 0,0:01:38.86,0:01:40.99,Default,,0,0,0,,这些元素才被计算出来
Dialogue: 0,0:01:41.52,0:01:44.78,Default,,0,0,0,,这是这些流元素可能被FORCE的一种方式
Dialogue: 0,0:01:45.77,0:01:46.64,Default,,0,0,0,,另外一种方式则是
Dialogue: 0,0:01:47.18,0:01:48.92,Default,,0,0,0,,这里有个简单的过程 用来打印一个流
Dialogue: 0,0:01:49.30,0:01:50.38,Default,,0,0,0,,它的定义是
Dialogue: 0,0:01:51.90,0:01:53.28,Default,,0,0,0,,过程PRINT-STREAM的定义是
Dialogue: 0,0:01:54.15,0:01:55.12,Default,,0,0,0,,我们要怎么做呢？
Dialogue: 0,0:01:55.74,0:01:56.86,Default,,0,0,0,,先打印流的头部分
Dialogue: 0,0:01:57.74,0:01:59.32,Default,,0,0,0,,流的头部分在这时就被计算出来
Dialogue: 0,0:01:59.72,0:02:02.84,Default,,0,0,0,,然后我们再递归地打印流的尾部分
Dialogue: 0,0:02:04.99,0:02:06.03,Default,,0,0,0,,完成以后
Dialogue: 0,0:02:06.04,0:02:08.57,Default,,0,0,0,,就返回一个的表示完成的消息 “DONE”
Dialogue: 0,0:02:09.66,0:02:11.39,Default,,0,0,0,,如果你构造了一个流
Dialogue: 0,0:02:11.64,0:02:13.64,Default,,0,0,0,,这个流非常的长
Dialogue: 0,0:02:14.31,0:02:16.33,Default,,0,0,0,,当你调用这个过程
Dialogue: 0,0:02:16.41,0:02:19.77,Default,,0,0,0,,流中的元素会随着PRINT-STREAM的调用
Dialogue: 0,0:02:19.87,0:02:21.12,Default,,0,0,0,,而被依次计算出来
Dialogue: 0,0:02:21.32,0:02:22.81,Default,,0,0,0,,不会在一开始就全部计算出来
Dialogue: 0,0:02:24.30,0:02:25.66,Default,,0,0,0,,正因为如此 我们能够
Dialogue: 0,0:02:27.50,0:02:29.61,Default,,0,0,0,,我们能够处理非常长的流
Dialogue: 0,0:02:30.19,0:02:31.92,Default,,0,0,0,,多长呢？
Dialogue: 0,0:02:33.74,0:02:35.12,Default,,0,0,0,,可以是无限长
Dialogue: 0,0:02:35.90,0:02:38.04,Default,,0,0,0,,我们在计算机上实践一下
Dialogue: 0,0:02:38.92,0:02:41.96,Default,,0,0,0,,我可以在计算机前输入
Dialogue: 0,0:02:43.48,0:02:53.31,Default,,0,0,0,,我先定义一个函数 (INTEGERS-FROM N)
Dialogue: 0,0:02:54.24,0:02:57.13,Default,,0,0,0,,用于生成一个从N开始的正整数流
Dialogue: 0,0:03:00.36,0:03:19.16,Default,,0,0,0,,也就是 (CONS-STREAM N (INTEGERS-FROM (+ N 1))))
Dialogue: 0,0:03:24.41,0:03:25.61,Default,,0,0,0,,这样就我们要的全部整数
Dialogue: 0,0:03:28.99,0:03:31.50,Default,,0,0,0,,现在我来尝试得到所有的整数
Dialogue: 0,0:03:34.57,0:03:44.33,Default,,0,0,0,,(DEFINE INTEGERS (INTEGERS-FROM 1))
Dialogue: 0,0:03:48.84,0:03:50.94,Default,,0,0,0,,如果现在我执行 (NTH-STREAM 20 INTEGERS)
Dialogue: 0,0:03:54.41,0:03:55.80,Default,,0,0,0,,来查看第20个元素
Dialogue: 0,0:04:03.42,0:04:05.53,Default,,0,0,0,,得到21 因为索引是从0开始的
Dialogue: 0,0:04:06.84,0:04:08.88,Default,,0,0,0,,或者我们来点更复杂的
Dialogue: 0,0:04:09.45,0:04:10.84,Default,,0,0,0,,我再来定义一个谓词
Dialogue: 0,0:04:11.77,0:04:18.51,Default,,0,0,0,,谓词NO-SEVEN用来检测是否为7的倍数
Dialogue: 0,0:04:19.58,0:04:20.75,Default,,0,0,0,,它的判定方法是这样的：
Dialogue: 0,0:04:21.79,0:04:23.16,Default,,0,0,0,,如果整数X不是7的倍数
Dialogue: 0,0:04:28.82,0:04:33.96,Default,,0,0,0,,我取X除7的余数
Dialogue: 0,0:04:36.62,0:04:38.35,Default,,0,0,0,,余数不应该为0
Dialogue: 0,0:04:43.80,0:04:49.77,Default,,0,0,0,,这时用NO-SEVEN这个谓词
Dialogue: 0,0:04:50.22,0:04:59.12,Default,,0,0,0,,过滤全部的整数
Dialogue: 0,0:05:11.57,0:05:13.34,Default,,0,0,0,,这样我就得到了所有的
Dialogue: 0,0:05:13.63,0:05:15.05,Default,,0,0,0,,不是7的倍数的整数构成的流
Dialogue: 0,0:05:16.49,0:05:23.44,Default,,0,0,0,,如果我问 这些不是7的倍数的整数中
Dialogue: 0,0:05:24.70,0:05:26.48,Default,,0,0,0,,的第100个数是多少？
Dialogue: 0,0:05:26.86,0:05:28.11,Default,,0,0,0,,结果是117
Dialogue: 0,0:05:28.32,0:05:30.67,Default,,0,0,0,,或者我也可以问
Dialogue: 0,0:05:32.30,0:05:34.38,Default,,0,0,0,,这个流的所有元素都是些什么？
Dialogue: 0,0:05:35.27,0:05:40.35,Default,,0,0,0,,我可以用(PRINT-STREAM NS)来尝试打印这个流
Dialogue: 0,0:05:40.83,0:05:41.79,Default,,0,0,0,,它就会输出个不停
Dialogue: 0,0:05:45.10,0:05:47.07,Default,,0,0,0,,你可能需要等上很久才能得到全部结果
Dialogue: 0,0:05:52.67,0:05:53.84,Default,,0,0,0,,你可能会问了
Dialogue: 0,0:05:54.81,0:05:57.00,Default,,0,0,0,,这个数据结构
Dialogue: 0,0:05:58.28,0:06:00.65,Default,,0,0,0,,真的全部是由整数构成的吗？
Dialogue: 0,0:06:01.10,0:06:04.05,Default,,0,0,0,,现在我画一个图来演示下刚写的那个程序
Dialogue: 0,0:06:04.96,0:06:10.57,Default,,0,0,0,,这是我刚才键入的整数定义
Dialogue: 0,0:06:12.33,0:06:15.98,Default,,0,0,0,,它是一个由第一个整数和由下一个整数生成的流 所构成的序对
Dialogue: 0,0:06:17.61,0:06:19.77,Default,,0,0,0,,现在我们画个图来看看它到底是什么样
Dialogue: 0,0:06:22.72,0:06:24.32,Default,,0,0,0,,从概念上来说 这应该是一个盒子
Dialogue: 0,0:06:25.53,0:06:27.18,Default,,0,0,0,,这个盒子是(INTEGER-FROM N)
Dialogue: 0,0:06:27.42,0:06:29.08,Default,,0,0,0,,它接受一个参数N
Dialogue: 0,0:06:31.42,0:06:32.97,Default,,0,0,0,,然后返回一个流
Dialogue: 0,0:06:35.02,0:06:37.36,Default,,0,0,0,,这个无穷流表示从N开始的所有整数
Dialogue: 0,0:06:38.08,0:06:38.73,Default,,0,0,0,,我要做什么呢？
Dialogue: 0,0:06:38.75,0:06:42.38,Default,,0,0,0,,呃 这个是INT-FROM盒子
Dialogue: 0,0:06:45.07,0:06:45.80,Default,,0,0,0,,里面是什么样子呢？
Dialogue: 0,0:06:45.80,0:06:48.60,Default,,0,0,0,,取得参数N之后
Dialogue: 0,0:06:52.27,0:06:53.92,Default,,0,0,0,,将其 +1
Dialogue: 0,0:06:57.95,0:07:03.15,Default,,0,0,0,,然后把结果递归地传递给另一个INT-FROM盒子
Dialogue: 0,0:07:06.87,0:07:09.60,Default,,0,0,0,,把这个盒子的结果和最初的N
Dialogue: 0,0:07:10.24,0:07:12.78,Default,,0,0,0,,用CONS组合起来
Dialogue: 0,0:07:13.39,0:07:14.36,Default,,0,0,0,,就形成了一个流
Dialogue: 0,0:07:14.57,0:07:17.26,Default,,0,0,0,,我刚才写的那个过程 画出来就是这样子
Dialogue: 0,0:07:18.52,0:07:20.32,Default,,0,0,0,,我们看到的这类图像
Dialogue: 0,0:07:20.78,0:07:21.74,Default,,0,0,0,,首先是由Peter Henderson提出的
Dialogue: 0,0:07:21.76,0:07:23.32,Default,,0,0,0,,也就是前面课程中绘图语言的发明者
Dialogue: 0,0:07:23.32,0:07:24.75,Default,,0,0,0,,我们把这种图叫做Henderson图
Dialogue: 0,0:07:25.37,0:07:27.90,Default,,0,0,0,,画这种图需要遵守一定的约定
Dialogue: 0,0:07:28.53,0:07:32.51,Default,,0,0,0,,这些实线代表输出的流
Dialogue: 0,0:07:33.02,0:07:36.20,Default,,0,0,0,,这些虚线则是初始的输入值
Dialogue: 0,0:07:37.27,0:07:39.02,Default,,0,0,0,,而这个图描述的形状是——
Dialogue: 0,0:07:39.40,0:07:41.60,Default,,0,0,0,,它会取一个整数作为初始值
Dialogue: 0,0:07:41.80,0:07:42.91,Default,,0,0,0,,然后输出一个流
Dialogue: 0,0:07:46.35,0:07:48.22,Default,,0,0,0,,现在 你可能又要问了
Dialogue: 0,0:07:48.38,0:07:50.88,Default,,0,0,0,,那个INTEGERS的数据结构真的全部都是整数吗？
Dialogue: 0,0:07:52.09,0:07:54.91,Default,,0,0,0,,或者它只是经过了精心组织
Dialogue: 0,0:07:54.94,0:07:56.43,Default,,0,0,0,,以至于总可以在其中找到
Dialogue: 0,0:07:56.44,0:07:57.24,Default,,0,0,0,,我们需要的那个整数？
Dialogue: 0,0:07:57.95,0:07:59.74,Default,,0,0,0,,这有点像个哲学问题 不是么？
Dialogue: 0,0:07:59.78,0:08:01.69,Default,,0,0,0,,如果有一个东西
Dialogue: 0,0:08:02.14,0:08:03.96,Default,,0,0,0,,你不去观测它 能否知道它“存在”呢？
Dialogue: 0,0:08:04.45,0:08:07.34,Default,,0,0,0,,这就有点像
Dialogue: 0,0:08:07.36,0:08:09.42,Default,,0,0,0,,你在银行中的存款那样
Dialogue: 0,0:08:12.38,0:08:12.64,Default,,0,0,0,,好吧
Dialogue: 0,0:08:16.35,0:08:17.48,Default,,0,0,0,,我们再来看一个例子
Dialogue: 0,0:08:18.68,0:08:20.70,Default,,0,0,0,,这门课的第一节课
Dialogue: 0,0:08:20.72,0:08:22.72,Default,,0,0,0,,我们就讲了一个来自于亚历山大的算法
Dialogue: 0,0:08:23.29,0:08:25.80,Default,,0,0,0,,来自亚历山大的Heron提出的
Dialogue: 0,0:08:25.82,0:08:26.94,Default,,0,0,0,,一个用于计算平方根的算法
Dialogue: 0,0:08:28.47,0:08:32.03,Default,,0,0,0,,现在再来看一个 同样来自于亚力山大的算法
Dialogue: 0,0:08:32.03,0:08:35.08,Default,,0,0,0,,这个被称为Eratosthenes算法的方法
Dialogue: 0,0:08:36.19,0:08:38.44,Default,,0,0,0,,用于计算所有的质数
Dialogue: 0,0:08:41.16,0:08:42.83,Default,,0,0,0,,它被称为Eratosthenes筛法
Dialogue: 0,0:08:42.83,0:08:49.72,Default,,0,0,0,,它是这样的 一开始
Dialogue: 0,0:08:50.99,0:08:52.28,Default,,0,0,0,,先列举所有的整数
Dialogue: 0,0:08:52.60,0:08:53.53,Default,,0,0,0,,从2开始
Dialogue: 0,0:08:53.88,0:08:55.04,Default,,0,0,0,,然后取第一个整数
Dialogue: 0,0:08:55.08,0:08:56.67,Default,,0,0,0,,然后你发现 哦 2是一个质数
Dialogue: 0,0:08:57.31,0:08:58.35,Default,,0,0,0,,然后你考察剩余的整数
Dialogue: 0,0:08:58.68,0:09:00.88,Default,,0,0,0,,划掉其中可以被2整除的数
Dialogue: 0,0:09:01.52,0:09:04.73,Default,,0,0,0,,我把这个划掉 还有这个 这个
Dialogue: 0,0:09:05.25,0:09:06.35,Default,,0,0,0,,有点费时
Dialogue: 0,0:09:06.36,0:09:08.91,Default,,0,0,0,,我要对所有的整数进行这样的操作
Dialogue: 0,0:09:11.16,0:09:15.39,Default,,0,0,0,,我遍历整个整数表
Dialogue: 0,0:09:18.27,0:09:20.94,Default,,0,0,0,,划掉所有被2整除的数
Dialogue: 0,0:09:22.11,0:09:24.38,Default,,0,0,0,,所有的整数都操作完后
Dialogue: 0,0:09:24.78,0:09:26.72,Default,,0,0,0,,回过头再来看还剩些什么
Dialogue: 0,0:09:27.04,0:09:28.80,Default,,0,0,0,,好的 下一个数就是3了
Dialogue: 0,0:09:29.33,0:09:30.33,Default,,0,0,0,,3也是一个质数
Dialogue: 0,0:09:30.77,0:09:33.05,Default,,0,0,0,,现在 我会继续在剩下的数中
Dialogue: 0,0:09:33.36,0:09:35.07,Default,,0,0,0,,划掉所有被3整除的数
Dialogue: 0,0:09:35.08,0:09:43.80,Default,,0,0,0,,划掉 9、15、21、27、33 等等
Dialogue: 0,0:09:44.33,0:09:45.12,Default,,0,0,0,,我就不往下划了
Dialogue: 0,0:09:45.35,0:09:46.52,Default,,0,0,0,,然后看看我们还剩下什么
Dialogue: 0,0:09:47.25,0:09:49.84,Default,,0,0,0,,而下一个就是5了
Dialogue: 0,0:09:50.49,0:09:52.04,Default,,0,0,0,,我又遍历剩下的数
Dialogue: 0,0:09:52.43,0:09:54.51,Default,,0,0,0,,找到第一个能被5整除的数
Dialogue: 0,0:09:54.54,0:09:57.61,Default,,0,0,0,,把剩下的能被5整除的数都划掉
Dialogue: 0,0:09:58.35,0:09:59.24,Default,,0,0,0,,做完这个之后
Dialogue: 0,0:09:59.82,0:10:01.89,Default,,0,0,0,,下一个数就是7
Dialogue: 0,0:10:01.89,0:10:02.72,Default,,0,0,0,,再遍历剩下的数
Dialogue: 0,0:10:02.76,0:10:03.95,Default,,0,0,0,,划掉所有被7整除的数
Dialogue: 0,0:10:03.98,0:10:05.47,Default,,0,0,0,,然后一直这样下去
Dialogue: 0,0:10:06.81,0:10:07.40,Default,,0,0,0,,全部结束的时候
Dialogue: 0,0:10:07.40,0:10:09.10,Default,,0,0,0,,我也就得到了所有的质数
Dialogue: 0,0:10:09.90,0:10:13.31,Default,,0,0,0,,这就是Eratosthenes筛法
Dialogue: 0,0:10:15.43,0:10:17.69,Default,,0,0,0,,我们来看下实际代码
Dialogue: 0,0:10:17.93,0:10:19.85,Default,,0,0,0,,这个过程命名为SIEVE
Dialogue: 0,0:10:27.91,0:10:29.40,Default,,0,0,0,,这是对应的代码
Dialogue: 0,0:10:30.33,0:10:34.48,Default,,0,0,0,,SIEVE过程 以一个流S为参数
Dialogue: 0,0:10:38.77,0:10:39.93,Default,,0,0,0,,返回一个新的流
Dialogue: 0,0:10:40.27,0:10:41.84,Default,,0,0,0,,新的流的头部分 就是流S的头部分
Dialogue: 0,0:10:41.87,0:10:44.43,Default,,0,0,0,,回忆一下 我总是取剩下的数中的第一个
Dialogue: 0,0:10:44.91,0:10:48.75,Default,,0,0,0,,而尾部分则是把流S的尾部分
Dialogue: 0,0:10:51.08,0:10:53.72,Default,,0,0,0,,过滤掉所有
Dialogue: 0,0:10:53.74,0:10:55.32,Default,,0,0,0,,能被S头部分整除的数
Dialogue: 0,0:10:56.41,0:10:57.56,Default,,0,0,0,,然后再对结果筛选
Dialogue: 0,0:10:59.02,0:11:00.09,Default,,0,0,0,,这个代码就是这样
Dialogue: 0,0:11:01.98,0:11:04.68,Default,,0,0,0,,现在 为了得到由质数构成的无穷流
Dialogue: 0,0:11:05.02,0:11:06.90,Default,,0,0,0,,我们对从2开始的整数流进行SIEVE
Dialogue: 0,0:11:14.92,0:11:15.56,Default,,0,0,0,,我们来实践一下
Dialogue: 0,0:11:16.30,0:11:18.30,Default,,0,0,0,,实际上 我们可以在计算机中运行
Dialogue: 0,0:11:19.76,0:11:22.12,Default,,0,0,0,,我希望我已经预先输入过SIEVE的定义了
Dialogue: 0,0:11:22.86,0:11:24.06,Default,,0,0,0,,所以我可以定义
Dialogue: 0,0:11:24.92,0:11:33.45,Default,,0,0,0,,我可以把PRIMES定义为
Dialogue: 0,0:11:34.64,0:11:41.45,Default,,0,0,0,,(SIEVE (INTEGERS-FROM 2))
Dialogue: 0,0:11:46.76,0:11:48.10,Default,,0,0,0,,现在我就得到了质数构成的表
Dialogue: 0,0:11:48.10,0:11:50.99,Default,,0,0,0,,这样就得到了所有的质数 对吧？
Dialogue: 0,0:11:50.99,0:11:53.52,Default,,0,0,0,,比如我可以问 第20个质数是什么？
Dialogue: 0,0:12:00.73,0:12:01.68,Default,,0,0,0,,结果是73
Dialogue: 0,0:12:02.54,0:12:03.34,Default,,0,0,0,,那个短促的停顿
Dialogue: 0,0:12:03.36,0:12:04.92,Default,,0,0,0,,这是因为
Dialogue: 0,0:12:04.94,0:12:06.43,Default,,0,0,0,,在我询问第20个元素时
Dialogue: 0,0:12:06.46,0:12:07.68,Default,,0,0,0,,它才进行实际的计算
Dialogue: 0,0:12:10.37,0:12:11.29,Default,,0,0,0,,在这里 我也可以要求
Dialogue: 0,0:12:13.80,0:12:14.88,Default,,0,0,0,,打印所有的质数
Dialogue: 0,0:12:22.64,0:12:24.40,Default,,0,0,0,,解释器就开始计算并打印所有的质数
Dialogue: 0,0:12:25.35,0:12:26.28,Default,,0,0,0,,得花上好一会儿
Dialogue: 0,0:12:26.28,0:12:27.61,Default,,0,0,0,,才能打赢完整
Dialogue: 0,0:12:27.79,0:12:28.57,Default,,0,0,0,,所以先把它停掉
Dialogue: 0,0:12:32.03,0:12:33.13,Default,,0,0,0,,让我来画图演示一下
Dialogue: 0,0:12:33.13,0:12:34.17,Default,,0,0,0,,我已经画好了
Dialogue: 0,0:12:34.89,0:12:36.19,Default,,0,0,0,,这个过程的图形应该是什么样子呢？
Dialogue: 0,0:12:37.90,0:12:39.77,Default,,0,0,0,,用这类图形的约定来说
Dialogue: 0,0:12:39.82,0:12:40.54,Default,,0,0,0,,我有一个叫SIEVE的盒子
Dialogue: 0,0:12:42.61,0:12:43.56,Default,,0,0,0,,它是如何运作的呢？
Dialogue: 0,0:12:43.56,0:12:44.81,Default,,0,0,0,,它以一个流作为输入
Dialogue: 0,0:12:48.85,0:12:50.59,Default,,0,0,0,,分离流的头、尾部分
Dialogue: 0,0:12:50.87,0:12:53.26,Default,,0,0,0,,从SIEVE盒子出来的第一个东西
Dialogue: 0,0:12:53.48,0:12:54.97,Default,,0,0,0,,就是原来流的头部分
Dialogue: 0,0:12:58.20,0:13:00.92,Default,,0,0,0,,头部分同样也用于这个盒子
Dialogue: 0,0:13:02.55,0:13:05.10,Default,,0,0,0,,这个盒子会过滤流的尾部分
Dialogue: 0,0:13:05.55,0:13:08.33,Default,,0,0,0,,过滤的依据是 能否被头部分整除
Dialogue: 0,0:13:09.53,0:13:11.18,Default,,0,0,0,,过滤得到的不可整除的那些数
Dialogue: 0,0:13:11.24,0:13:13.12,Default,,0,0,0,,再放入另一个SIEVE盒子
Dialogue: 0,0:13:13.90,0:13:15.13,Default,,0,0,0,,然后把它们组合输出
Dialogue: 0,0:13:15.13,0:13:16.89,Default,,0,0,0,,你可以把SIEVE想象为一个过滤器
Dialogue: 0,0:13:17.20,0:13:19.23,Default,,0,0,0,,只不过它是一个无穷递归的过滤器
Dialogue: 0,0:13:19.65,0:13:20.88,Default,,0,0,0,,这是因为在SIEVE盒子中
Dialogue: 0,0:13:21.52,0:13:22.60,Default,,0,0,0,,还有另外一个SIEVE盒子
Dialogue: 0,0:13:23.37,0:13:25.85,Default,,0,0,0,,内部的盒子里面还有另外一个SIEVE盒子
Dialogue: 0,0:13:27.13,0:13:28.96,Default,,0,0,0,,我们现在逐渐有了非常厉害的能力
Dialogue: 0,0:13:28.96,0:13:32.84,Default,,0,0,0,,我们开始把 信号处理的方法
Dialogue: 0,0:13:33.90,0:13:36.41,Default,,0,0,0,,和计算中的递归结合在一起 来建模世界
Dialogue: 0,0:13:37.42,0:13:39.82,Default,,0,0,0,,还有很多像是这样的事
Dialogue: 0,0:13:40.97,0:13:42.09,Default,,0,0,0,,好的 有什么问题吗？
Dialogue: 0,0:13:48.19,0:13:49.16,Default,,0,0,0,,好吧 那我们休息一下
Dialogue: 0,0:13:49.64,0:14:04.12,Default,,0,0,0,,[音乐]
Dialogue: 0,0:14:04.46,0:14:08.12,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:14:12.08,0:14:16.38,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:14:16.44,0:14:20.22,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:14:20.35,0:14:25.05,Declare,,0,0,0,,{\an2\fad(500,500)}流 II
Dialogue: 0,0:14:28.65,0:14:30.36,Default,,0,0,0,,我们已经看了
Dialogue: 0,0:14:30.36,0:14:32.09,Default,,0,0,0,,好几个流式程序设计的例子
Dialogue: 0,0:14:34.79,0:14:39.21,Default,,0,0,0,,我们目前接触到的流过程
Dialogue: 0,0:14:39.72,0:14:41.32,Default,,0,0,0,,都有一个共同的特征
Dialogue: 0,0:14:41.49,0:14:43.63,Default,,0,0,0,,这些过程总是递归地
Dialogue: 0,0:14:44.16,0:14:46.49,Default,,0,0,0,,一次生成一个元素
Dialogue: 0,0:14:46.51,0:14:48.72,Default,,0,0,0,,再用CONS-STREAM连接起来
Dialogue: 0,0:14:49.15,0:14:50.86,Default,,0,0,0,,因此 我们一直把它当作是生成器
Dialogue: 0,0:14:50.92,0:14:53.63,Default,,0,0,0,,还有一种思考流式程序设计的方式
Dialogue: 0,0:14:53.79,0:14:56.96,Default,,0,0,0,,我们不认为程序是
Dialogue: 0,0:14:57.36,0:14:59.93,Default,,0,0,0,,沿着流逐一处理元素
Dialogue: 0,0:15:00.25,0:15:05.68,Default,,0,0,0,,而是一下子处理了整个流
Dialogue: 0,0:15:07.18,0:15:09.16,Default,,0,0,0,,我先来定义两个非常有用的过程
Dialogue: 0,0:15:09.23,0:15:11.50,Default,,0,0,0,,来帮助我说明
Dialogue: 0,0:15:12.41,0:15:13.60,Default,,0,0,0,,第一个过程是ADD-STREAMS
Dialogue: 0,0:15:15.36,0:15:18.25,Default,,0,0,0,,它接受两个流作为参数
Dialogue: 0,0:15:18.81,0:15:20.88,Default,,0,0,0,,S1和S2
Dialogue: 0,0:15:22.30,0:15:24.67,Default,,0,0,0,,它生成一个新的流
Dialogue: 0,0:15:24.99,0:15:28.17,Default,,0,0,0,,其元素是两个流相应位置元素的和
Dialogue: 0,0:15:30.22,0:15:31.88,Default,,0,0,0,,相当于是“按元素”的加
Dialogue: 0,0:15:32.97,0:15:33.95,Default,,0,0,0,,如果其中一个流是空的
Dialogue: 0,0:15:33.96,0:15:35.39,Default,,0,0,0,,我们就返回另一个
Dialogue: 0,0:15:36.81,0:15:38.96,Default,,0,0,0,,否则 我们就构建一个新的流
Dialogue: 0,0:15:39.90,0:15:42.96,Default,,0,0,0,,新流的头部分是两个流头部分之和
Dialogue: 0,0:15:44.00,0:15:44.88,Default,,0,0,0,,而新流的尾部分
Dialogue: 0,0:15:46.00,0:15:48.62,Default,,0,0,0,,则是递归地加和尾部分
Dialogue: 0,0:15:50.09,0:15:52.73,Default,,0,0,0,,这就会产生“按元素”地加的效果
Dialogue: 0,0:15:53.15,0:15:57.04,Default,,0,0,0,,另一个过程是SCALE-STREAM
Dialogue: 0,0:15:57.50,0:16:01.66,Default,,0,0,0,,SCALE-STREAM有两个参数 常数C和流S
Dialogue: 0,0:16:04.11,0:16:06.62,Default,,0,0,0,,结果生成的流
Dialogue: 0,0:16:07.18,0:16:09.50,Default,,0,0,0,,就是将流S的所有元素乘上了C
Dialogue: 0,0:16:09.71,0:16:11.21,Default,,0,0,0,,这很简单 就是一个MAP
Dialogue: 0,0:16:12.20,0:16:16.22,Default,,0,0,0,,用到的函数是 X*C
Dialogue: 0,0:16:16.35,0:16:17.80,Default,,0,0,0,,把这个函数MAP于整个流
Dialogue: 0,0:16:20.06,0:16:21.47,Default,,0,0,0,,有了这两个过程
Dialogue: 0,0:16:22.64,0:16:24.36,Default,,0,0,0,,我来给你们解释 什么叫做
Dialogue: 0,0:16:24.70,0:16:27.00,Default,,0,0,0,,“一下子处理整个流”
Dialogue: 0,0:16:28.12,0:16:28.73,Default,,0,0,0,,我们来看这个
Dialogue: 0,0:16:30.20,0:16:30.92,Default,,0,0,0,,假设这样
Dialogue: 0,0:16:31.68,0:16:52.35,Default,,0,0,0,,(DEFINE ONES (CONS-STREAM 1 ONES))
Dialogue: 0,0:16:54.86,0:16:55.52,Default,,0,0,0,,这是什么？
Dialogue: 0,0:16:56.95,0:16:58.94,Default,,0,0,0,,这是一个表示无穷个1的流
Dialogue: 0,0:16:59.96,0:17:01.44,Default,,0,0,0,,因为第一个元素是1
Dialogue: 0,0:17:03.33,0:17:05.15,Default,,0,0,0,,尾部分则是这样的
Dialogue: 0,0:17:05.55,0:17:06.83,Default,,0,0,0,,它的头部分是1
Dialogue: 0,0:17:07.63,0:17:09.02,Default,,0,0,0,,它的尾部分
Dialogue: 0,0:17:09.12,0:17:10.24,Default,,0,0,0,,的头部分又为1
Dialogue: 0,0:17:10.52,0:17:11.78,Default,,0,0,0,,以此类推
Dialogue: 0,0:17:11.78,0:17:13.32,Default,,0,0,0,,这就是无穷个1的流
Dialogue: 0,0:17:15.13,0:17:15.93,Default,,0,0,0,,现在根据ONES
Dialogue: 0,0:17:16.12,0:17:18.03,Default,,0,0,0,,我再给出另一种定义整数的方式
Dialogue: 0,0:17:19.47,0:17:27.36,Default,,0,0,0,,(DEFINE INTEGERS
Dialogue: 0,0:17:28.24,0:17:30.76,Default,,0,0,0,,当然 第一个数是1
Dialogue: 0,0:17:32.75,0:17:38.57,Default,,0,0,0,,(CONS-STREAM 1 (ADD-STREAM
Dialogue: 0,0:17:40.22,0:17:48.27,Default,,0,0,0,,INTEGERS ONES)))
Dialogue: 0,0:17:55.10,0:17:56.35,Default,,0,0,0,,整数流是这样的：
Dialogue: 0,0:17:57.24,0:17:59.98,Default,,0,0,0,,它的第一个元素是1
Dialogue: 0,0:18:00.88,0:18:02.32,Default,,0,0,0,,而其余部分则是
Dialogue: 0,0:18:03.12,0:18:06.14,Default,,0,0,0,,依次把每个整数加1
Dialogue: 0,0:18:06.64,0:18:08.19,Default,,0,0,0,,因此 整数流的第二个元素则是
Dialogue: 0,0:18:08.51,0:18:11.96,Default,,0,0,0,,整数流的第一个元素加1
Dialogue: 0,0:18:13.92,0:18:15.18,Default,,0,0,0,,下一个数又要加1
Dialogue: 0,0:18:15.20,0:18:16.48,Default,,0,0,0,,第三个元素则是
Dialogue: 0,0:18:16.62,0:18:20.41,Default,,0,0,0,,INTEGER流尾部分的第一个元素
Dialogue: 0,0:18:20.84,0:18:21.96,Default,,0,0,0,,加1
Dialogue: 0,0:18:22.51,0:18:23.76,Default,,0,0,0,,这也就相当于
Dialogue: 0,0:18:25.08,0:18:28.65,Default,,0,0,0,,最初整数流的第一个元素加1
Dialogue: 0,0:18:28.86,0:18:31.25,Default,,0,0,0,,然后再加1 以此类推
Dialogue: 0,0:18:35.24,0:18:36.31,Default,,0,0,0,,这看起来有点匪夷所思
Dialogue: 0,0:18:36.31,0:18:37.47,Default,,0,0,0,,这样的过程可以正常运行
Dialogue: 0,0:18:38.12,0:18:38.99,Default,,0,0,0,,关键在于延时求值
Dialogue: 0,0:18:40.15,0:18:43.32,Default,,0,0,0,,我们来看这个ONES
Dialogue: 0,0:18:43.87,0:18:45.92,Default,,0,0,0,,这看起来根本不可能
Dialogue: 0,0:18:46.25,0:18:47.63,Default,,0,0,0,,因为它突然说
Dialogue: 0,0:18:47.79,0:18:48.96,Default,,0,0,0,,在定义ONES的时候
Dialogue: 0,0:18:49.00,0:18:50.91,Default,,0,0,0,,发现它依赖于它本身
Dialogue: 0,0:18:51.13,0:18:52.08,Default,,0,0,0,,它之所以可以运行是因为
Dialogue: 0,0:18:52.09,0:18:54.04,Default,,0,0,0,,这里暗中隐藏着延时求值
Dialogue: 0,0:18:55.25,0:18:56.56,Default,,0,0,0,,这个代码实际上是
Dialogue: 0,0:18:57.79,0:18:59.69,Default,,0,0,0,,回忆下 CONS-STREAM是只是一个缩写
Dialogue: 0,0:19:00.29,0:19:01.15,Default,,0,0,0,,实际上则是
Dialogue: 0,0:19:01.85,0:19:08.99,Default,,0,0,0,,(CONS 1 (DELAY ONES))
Dialogue: 0,0:19:12.14,0:19:13.21,Default,,0,0,0,,它又是怎么运作的呢？
Dialogue: 0,0:19:15.50,0:19:16.88,Default,,0,0,0,,你想要定义ONES
Dialogue: 0,0:19:18.02,0:19:20.24,Default,,0,0,0,,我来看看ONES要被定义成什么样
Dialogue: 0,0:19:20.70,0:19:23.40,Default,,0,0,0,,ONES被定义为一个序对
Dialogue: 0,0:19:24.89,0:19:28.11,Default,,0,0,0,,其CAR部分为1
Dialogue: 0,0:19:28.32,0:19:29.45,Default,,0,0,0,,而CDR部分则是
Dialogue: 0,0:19:29.45,0:19:30.73,Default,,0,0,0,,是一个计算某物的PROMISE
Dialogue: 0,0:19:30.75,0:19:31.69,Default,,0,0,0,,我现在还不用关心
Dialogue: 0,0:19:32.71,0:19:34.25,Default,,0,0,0,,所以虽然这时ONES还没有定义
Dialogue: 0,0:19:34.28,0:19:36.30,Default,,0,0,0,,但对我并不造成什么影响
Dialogue: 0,0:19:37.27,0:19:39.45,Default,,0,0,0,,一旦运行了整个定义 ONES就被定义了
Dialogue: 0,0:19:40.67,0:19:42.83,Default,,0,0,0,,所以 访问它尾部的时候 它就有定义了
Dialogue: 0,0:19:44.92,0:19:46.06,Default,,0,0,0,,这一点非常隐讳
Dialogue: 0,0:19:46.59,0:19:47.90,Default,,0,0,0,,整数流的定义也是如此
Dialogue: 0,0:19:48.47,0:19:50.46,Default,,0,0,0,,我可以在这里引用INTEGERS是因为
Dialogue: 0,0:19:51.13,0:19:53.21,Default,,0,0,0,,是因为这个CONS-STREAM的缘故
Dialogue: 0,0:19:53.85,0:19:55.24,Default,,0,0,0,,用CONS-STREAM把1
Dialogue: 0,0:19:55.37,0:19:57.05,Default,,0,0,0,,和一个不立即需要的东西组合起来
Dialogue: 0,0:19:57.05,0:19:59.60,Default,,0,0,0,,所以我在运行INTEGERS的定义的时候
Dialogue: 0,0:20:00.22,0:20:01.90,Default,,0,0,0,,并不会发现INTEGER没有定义过
Dialogue: 0,0:20:06.32,0:20:08.27,Default,,0,0,0,,听上去非常玄乎
Dialogue: 0,0:20:08.44,0:20:11.50,Default,,0,0,0,,让我用图像来演示一下INTEGERS的原理
Dialogue: 0,0:20:12.43,0:20:14.72,Default,,0,0,0,,怎么画呢？
Dialogue: 0,0:20:15.02,0:20:16.30,Default,,0,0,0,,首先是ONES这个流
Dialogue: 0,0:20:20.51,0:20:21.88,Default,,0,0,0,,它作为参数输入
Dialogue: 0,0:20:23.26,0:20:24.92,Default,,0,0,0,,进入一个加法器
Dialogue: 0,0:20:24.96,0:20:26.59,Default,,0,0,0,,进行流的加法运算
Dialogue: 0,0:20:29.31,0:20:35.87,Default,,0,0,0,,输出则是整数流INTEGERS
Dialogue: 0,0:20:40.76,0:20:42.70,Default,,0,0,0,,这里 这个整数流又重新进入加法器
Dialogue: 0,0:20:44.94,0:20:46.97,Default,,0,0,0,,形成了一个小型的反馈回路
Dialogue: 0,0:20:48.06,0:20:49.42,Default,,0,0,0,,我需要在某处接入最初的ONES
Dialogue: 0,0:20:50.09,0:20:52.88,Default,,0,0,0,,才能让它生效
Dialogue: 0,0:20:57.10,0:20:58.64,Default,,0,0,0,,在真实的信号处理中
Dialogue: 0,0:20:58.72,0:21:02.48,Default,,0,0,0,,这里是一个被初始化为1的延时元件
Dialogue: 0,0:21:02.91,0:21:05.90,Default,,0,0,0,,这就是ONES程序的图示
Dialogue: 0,0:21:07.86,0:21:09.63,Default,,0,0,0,,事实上 这个非常像
Dialogue: 0,0:21:09.80,0:21:13.77,Default,,0,0,0,,如果你见过真正的信号方块图的话
Dialogue: 0,0:21:13.77,0:21:16.30,Default,,0,0,0,,这个图形非常像累加器
Dialogue: 0,0:21:16.35,0:21:17.48,Default,,0,0,0,,有穷状态累加器
Dialogue: 0,0:21:17.98,0:21:20.06,Default,,0,0,0,,事实上 我们可以稍加修改
Dialogue: 0,0:21:21.18,0:21:23.96,Default,,0,0,0,,就可以让它对一个流做积分
Dialogue: 0,0:21:25.37,0:21:26.97,Default,,0,0,0,,或者说是有穷状态累加器
Dialogue: 0,0:21:27.00,0:21:28.04,Default,,0,0,0,,你怎么认为都可以
Dialogue: 0,0:21:28.44,0:21:30.86,Default,,0,0,0,,现在 不再是输入ONES 输出INTEGERS
Dialogue: 0,0:21:31.68,0:21:32.38,Default,,0,0,0,,我们要做的是
Dialogue: 0,0:21:32.91,0:21:34.83,Default,,0,0,0,,这里有一个流S为输入
Dialogue: 0,0:21:35.76,0:21:40.56,Default,,0,0,0,,我们要计算这个流的积分
Dialogue: 0,0:21:42.60,0:21:44.09,Default,,0,0,0,,也就是累加这个流的值
Dialogue: 0,0:21:44.44,0:21:45.63,Default,,0,0,0,,这看起来几乎就是一样的
Dialogue: 0,0:21:45.66,0:21:46.84,Default,,0,0,0,,我们要做的就是
Dialogue: 0,0:21:47.02,0:21:48.08,Default,,0,0,0,,当S从这里输入时
Dialogue: 0,0:21:49.21,0:21:50.64,Default,,0,0,0,,在把它求和之前
Dialogue: 0,0:21:50.91,0:21:54.26,Default,,0,0,0,,先将其乘以dt
Dialogue: 0,0:21:57.68,0:22:00.00,Default,,0,0,0,,剩下的就不用改了
Dialogue: 0,0:22:00.00,0:22:00.91,Default,,0,0,0,,我们就得到了一个盒子
Dialogue: 0,0:22:03.36,0:22:04.56,Default,,0,0,0,,一个积分器
Dialogue: 0,0:22:09.79,0:22:11.26,Default,,0,0,0,,对一个流S进行积分
Dialogue: 0,0:22:11.90,0:22:14.51,Default,,0,0,0,,把这里的1替换为
Dialogue: 0,0:22:14.94,0:22:18.35,Default,,0,0,0,,该积分的初始值
Dialogue: 0,0:22:19.98,0:22:21.60,Default,,0,0,0,,这个看起来就非常像
Dialogue: 0,0:22:22.35,0:22:24.86,Default,,0,0,0,,信号处理中的方框图了
Dialogue: 0,0:22:25.27,0:22:28.11,Default,,0,0,0,,事实上 这个图示对应的是这样一个过程
Dialogue: 0,0:22:31.49,0:22:33.61,Default,,0,0,0,,对一个流进行积分
Dialogue: 0,0:22:34.01,0:22:35.48,Default,,0,0,0,,INTEGRAL函数接收一个流
Dialogue: 0,0:22:35.68,0:22:36.86,Default,,0,0,0,,返回一个新的流
Dialogue: 0,0:22:37.53,0:22:40.67,Default,,0,0,0,,它还接收一个初始值和某个时间常量
Dialogue: 0,0:22:42.23,0:22:42.97,Default,,0,0,0,,然后呢？
Dialogue: 0,0:22:43.04,0:22:45.05,Default,,0,0,0,,首先在内部定义一个流INT
Dialogue: 0,0:22:45.20,0:22:46.32,Default,,0,0,0,,之所以要给它一个内部名字
Dialogue: 0,0:22:46.33,0:22:48.86,Default,,0,0,0,,原因在于可以使它反馈 以形成循环
Dialogue: 0,0:22:49.40,0:22:50.80,Default,,0,0,0,,INT的定义是
Dialogue: 0,0:22:51.10,0:22:53.32,Default,,0,0,0,,一个以INITIA-VALUE开始的流
Dialogue: 0,0:22:54.97,0:23:00.14,Default,,0,0,0,,而其余的元素则是把它们加起来
Dialogue: 0,0:23:01.28,0:23:03.61,Default,,0,0,0,,我们把输入流乘以dt
Dialogue: 0,0:23:03.87,0:23:04.92,Default,,0,0,0,,然后和INT相加
Dialogue: 0,0:23:06.88,0:23:09.66,Default,,0,0,0,,整个INTEGRAL函数的结果就是这个INT
Dialogue: 0,0:23:10.69,0:23:12.94,Default,,0,0,0,,我们使用这种内部定义的语法
Dialogue: 0,0:23:13.34,0:23:15.66,Default,,0,0,0,,是为了可以在内部引用它自己
Dialogue: 0,0:23:21.88,0:23:23.71,Default,,0,0,0,,我们还可以做更多的事情
Dialogue: 0,0:23:23.71,0:23:24.51,Default,,0,0,0,,来看这个
Dialogue: 0,0:23:25.63,0:23:26.89,Default,,0,0,0,,斐波那契数
Dialogue: 0,0:23:26.89,0:23:32.62,Default,,0,0,0,,(DEFINE FIBS
Dialogue: 0,0:23:36.35,0:23:37.63,Default,,0,0,0,,斐波那契数是什么呢？
Dialogue: 0,0:23:37.98,0:23:46.54,Default,,0,0,0,,它从0开始
Dialogue: 0,0:23:48.65,0:23:50.09,Default,,0,0,0,,下一个是1
Dialogue: 0,0:23:56.26,0:23:59.16,Default,,0,0,0,,的其余的斐波那契数是通过
Dialogue: 0,0:23:59.87,0:24:11.00,Default,,0,0,0,,把它们的尾部分求和而得来
Dialogue: 0,0:24:17.57,0:24:19.28,Default,,0,0,0,,这样来定义斐波那契数
Dialogue: 0,0:24:20.58,0:24:21.43,Default,,0,0,0,,这是如何运作的呢？
Dialogue: 0,0:24:21.43,0:24:24.19,Default,,0,0,0,,我们来试试
Dialogue: 0,0:24:24.20,0:24:26.49,Default,,0,0,0,,假如开始计算斐波那契数
Dialogue: 0,0:24:29.64,0:24:31.92,Default,,0,0,0,,首先告诉你 它以0和1开始
Dialogue: 0,0:24:35.79,0:24:38.22,Default,,0,0,0,,而0和1之后的数则是
Dialogue: 0,0:24:39.18,0:24:40.86,Default,,0,0,0,,通过加和两个流而得
Dialogue: 0,0:24:41.12,0:24:42.59,Default,,0,0,0,,一个流是FIBS本身
Dialogue: 0,0:24:44.06,0:24:45.69,Default,,0,0,0,,另一个是FIBS的尾部分
Dialogue: 0,0:24:49.12,0:24:51.16,Default,,0,0,0,,如果我知道这是以0和1起始的
Dialogue: 0,0:24:51.79,0:24:55.42,Default,,0,0,0,,我就能知道 FIBS是以0和1起始的
Dialogue: 0,0:24:55.74,0:24:57.40,Default,,0,0,0,,那么 FIBS的尾部分则应该以1开始
Dialogue: 0,0:24:58.36,0:24:59.45,Default,,0,0,0,,一旦我知道了这点
Dialogue: 0,0:24:59.66,0:25:02.11,Default,,0,0,0,,我就知道 FIBS的下一个数就是0+1=1
Dialogue: 0,0:25:02.96,0:25:04.60,Default,,0,0,0,,它也同样告诉我这里是1
Dialogue: 0,0:25:04.62,0:25:05.72,Default,,0,0,0,,这里也是1
Dialogue: 0,0:25:06.30,0:25:07.28,Default,,0,0,0,,知道了这些之后
Dialogue: 0,0:25:07.29,0:25:08.76,Default,,0,0,0,,我就知道下一个是2
Dialogue: 0,0:25:09.39,0:25:11.70,Default,,0,0,0,,这里是2 这里也是2
Dialogue: 0,0:25:11.70,0:25:12.56,Default,,0,0,0,,下一个是3
Dialogue: 0,0:25:14.72,0:25:15.79,Default,,0,0,0,,这里是3
Dialogue: 0,0:25:16.19,0:25:17.13,Default,,0,0,0,,这里是5
Dialogue: 0,0:25:18.67,0:25:19.96,Default,,0,0,0,,这个定义完全说得通
Dialogue: 0,0:25:21.50,0:25:22.78,Default,,0,0,0,,这个定义只有一行
Dialogue: 0,0:25:22.83,0:25:25.00,Default,,0,0,0,,当然 我也可以在计算机中
Dialogue: 0,0:25:25.00,0:25:26.62,Default,,0,0,0,,原原本本地键入计算机中
Dialogue: 0,0:25:27.04,0:25:28.94,Default,,0,0,0,,然后要求输出斐波那契数
Dialogue: 0,0:25:28.94,0:25:30.15,Default,,0,0,0,,然后它就会不断输出
Dialogue: 0,0:25:32.79,0:25:35.20,Default,,0,0,0,,这又像是在学习递归
Dialogue: 0,0:25:36.81,0:25:39.79,Default,,0,0,0,,过程可以被递归定义
Dialogue: 0,0:25:40.99,0:25:43.50,Default,,0,0,0,,我们也可以递归地定义数据对象
Dialogue: 0,0:25:45.16,0:25:46.92,Default,,0,0,0,,但你们一点儿不应该感到吃惊
Dialogue: 0,0:25:47.12,0:25:49.50,Default,,0,0,0,,因为现在 你们应该真正相信
Dialogue: 0,0:25:49.52,0:25:53.05,Default,,0,0,0,,过程与数据之间没有区别
Dialogue: 0,0:25:53.09,0:25:53.92,Default,,0,0,0,,事实上 就某种意义上来说
Dialogue: 0,0:25:53.93,0:25:56.41,Default,,0,0,0,,流也是由过程来实现的
Dialogue: 0,0:25:56.43,0:25:57.79,Default,,0,0,0,,只不过我们不把它看做过程而已
Dialogue: 0,0:25:58.21,0:26:00.38,Default,,0,0,0,,因此既然我们有递归过程
Dialogue: 0,0:26:00.70,0:26:03.63,Default,,0,0,0,,那么 有递归数据也就不足为奇了
Dialogue: 0,0:26:07.72,0:26:09.69,Default,,0,0,0,,虽然流非常简洁
Dialogue: 0,0:26:09.72,0:26:13.92,Default,,0,0,0,,但不幸的是 有些问题流无法解决
Dialogue: 0,0:26:14.99,0:26:16.48,Default,,0,0,0,,我来举个例子
Dialogue: 0,0:26:17.58,0:26:20.35,Default,,0,0,0,,同样地 我们来想象一下
Dialogue: 0,0:26:20.76,0:26:23.61,Default,,0,0,0,,我们正在构建求解微分方程的模拟计算机
Dialogue: 0,0:26:25.20,0:26:34.30,Default,,0,0,0,,比如求解方程 y' = y^2
Dialogue: 0,0:26:34.76,0:26:36.16,Default,,0,0,0,,我会给你一个初值
Dialogue: 0,0:26:36.39,0:26:38.03,Default,,0,0,0,,y(0) = 1
Dialogue: 0,0:26:41.48,0:26:44.06,Default,,0,0,0,,dt = .0001
Dialogue: 0,0:26:46.77,0:26:47.53,Default,,0,0,0,,很久之前
Dialogue: 0,0:26:48.00,0:26:50.65,Default,,0,0,0,,就有人构建模拟计算机 来解决这类问题
Dialogue: 0,0:26:51.36,0:26:53.02,Default,,0,0,0,,原理非常简单
Dialogue: 0,0:26:53.02,0:26:54.41,Default,,0,0,0,,你首先需要一个积分器
Dialogue: 0,0:27:00.04,0:27:01.69,Default,,0,0,0,,比如这个INT盒子
Dialogue: 0,0:27:03.05,0:27:06.48,Default,,0,0,0,,我们设定初始值 y(0) = 1
Dialogue: 0,0:27:08.53,0:27:10.92,Default,,0,0,0,,现在如果我们送入一个输入 就会得到输出
Dialogue: 0,0:27:10.96,0:27:13.16,Default,,0,0,0,,输出的结果就是y
Dialogue: 0,0:27:14.25,0:27:16.96,Default,,0,0,0,,输入的是y的导数
Dialogue: 0,0:27:17.52,0:27:20.52,Default,,0,0,0,,在这里 导数 y' = y^2
Dialogue: 0,0:27:21.49,0:27:27.07,Default,,0,0,0,,如果我们用MAP把SQUARE映射在这些值上
Dialogue: 0,0:27:30.73,0:27:32.09,Default,,0,0,0,,然后把这个引过来
Dialogue: 0,0:27:36.28,0:27:38.48,Default,,0,0,0,,这个方块图
Dialogue: 0,0:27:38.57,0:27:41.08,Default,,0,0,0,,就是用于求解这个微分方程的模拟计算机
Dialogue: 0,0:27:42.91,0:27:44.80,Default,,0,0,0,,现在我们用代码
Dialogue: 0,0:27:44.80,0:27:46.78,Default,,0,0,0,,来表示下这个过程
Dialogue: 0,0:27:47.23,0:27:48.72,Default,,0,0,0,,这个图究竟表示的是什么呢？
Dialogue: 0,0:27:49.39,0:27:58.30,Default,,0,0,0,,(DEFINE Y
Dialogue: 0,0:28:04.28,0:28:11.68,Default,,0,0,0,,(INTEGRAL DY 1 .001))
Dialogue: 0,0:28:13.79,0:28:15.45,Default,,0,0,0,,接下来
Dialogue: 0,0:28:16.80,0:28:20.85,Default,,0,0,0,,通过MAP SQUARE 来表示dy
Dialogue: 0,0:28:20.85,0:28:32.81,Default,,0,0,0,,(DEFINE DY (MAP SQUARE Y))
Dialogue: 0,0:28:33.51,0:28:36.80,Default,,0,0,0,,这就是这个模拟计算机的流式描述
Dialogue: 0,0:28:38.62,0:28:40.32,Default,,0,0,0,,不幸的是 它并不起效
Dialogue: 0,0:28:41.41,0:28:42.67,Default,,0,0,0,,你也可以发现这是为什么
Dialogue: 0,0:28:42.97,0:28:44.99,Default,,0,0,0,,因为我把Y定义为
Dialogue: 0,0:28:46.43,0:28:47.85,Default,,0,0,0,,DY 的积分
Dialogue: 0,0:28:49.04,0:28:50.65,Default,,0,0,0,,它会问 对什么的积分？
Dialogue: 0,0:28:51.19,0:28:52.12,Default,,0,0,0,,没定义啊
Dialogue: 0,0:28:53.71,0:28:57.63,Default,,0,0,0,,所以这个定义必须写在这个定义的后面
Dialogue: 0,0:28:58.77,0:29:00.51,Default,,0,0,0,,另一方面 如果先定义了dy
Dialogue: 0,0:29:00.51,0:29:03.02,Default,,0,0,0,,定义为 (MAP SQUARE 某个东西)
Dialogue: 0,0:29:03.58,0:29:04.64,Default,,0,0,0,,这个也还没有定义
Dialogue: 0,0:29:05.77,0:29:08.17,Default,,0,0,0,,我既不能先写这个 又不能先写那个
Dialogue: 0,0:29:09.08,0:29:11.58,Default,,0,0,0,,这个游戏就没法玩了
Dialogue: 0,0:29:17.56,0:29:18.51,Default,,0,0,0,,怎样来解决呢？
Dialogue: 0,0:29:20.60,0:29:21.84,Default,,0,0,0,,我们可以用ONES来解决
Dialogue: 0,0:29:22.20,0:29:25.82,Default,,0,0,0,,所以 我们在这里定义的ONES
Dialogue: 0,0:29:27.24,0:29:29.90,Default,,0,0,0,,我们之所以可以使用ONES来定义ONES
Dialogue: 0,0:29:30.40,0:29:32.03,Default,,0,0,0,,这是因为其中的延时求值
Dialogue: 0,0:29:32.43,0:29:34.12,Default,,0,0,0,,CONS-STREAM是延时求值的
Dialogue: 0,0:29:34.77,0:29:35.79,Default,,0,0,0,,那么 这又为什么说得通呢？
Dialogue: 0,0:29:35.92,0:29:38.51,Default,,0,0,0,,为什么CONS-STREAM是延时求值的是合理的呢？
Dialogue: 0,0:29:40.73,0:29:43.13,Default,,0,0,0,,原因在于 CONS-STREAM不需要其尾部分
Dialogue: 0,0:29:43.48,0:29:44.88,Default,,0,0,0,,就可以完成有意义的事
Dialogue: 0,0:29:45.95,0:29:46.84,Default,,0,0,0,,比如我说
Dialogue: 0,0:29:47.48,0:29:49.64,Default,,0,0,0,,这个是1和某个东西组成的流
Dialogue: 0,0:29:49.92,0:29:51.69,Default,,0,0,0,,虽然我对它一无所知
Dialogue: 0,0:29:52.16,0:29:54.03,Default,,0,0,0,,但我却知道整个流是以1开始的
Dialogue: 0,0:29:54.87,0:29:57.29,Default,,0,0,0,,所以用CONS-STREAM来构造是有意义的
Dialogue: 0,0:29:59.96,0:30:01.24,Default,,0,0,0,,我们在这里放了一个DELAY
Dialogue: 0,0:30:01.42,0:30:04.65,Default,,0,0,0,,这就使得我们能够进行某种自引用的定义
Dialogue: 0,0:30:06.32,0:30:07.95,Default,,0,0,0,,INTEGRAL也可以用这种方式来解决
Dialogue: 0,0:30:08.19,0:30:12.52,Default,,0,0,0,,注意 对于INTEGRAL来说 我可以
Dialogue: 0,0:30:14.60,0:30:16.08,Default,,0,0,0,,让我们回过头来再看看INTEGRAL的定义
Dialogue: 0,0:30:17.58,0:30:18.56,Default,,0,0,0,,求积分的时候
Dialogue: 0,0:30:21.39,0:30:25.00,Default,,0,0,0,,知道INTEGRAL的第一个元素是合理的
Dialogue: 0,0:30:26.04,0:30:27.87,Default,,0,0,0,,尽管还不知道整个流是什么样的
Dialogue: 0,0:30:28.97,0:30:30.17,Default,,0,0,0,,这是因为INTEGRAL中第一个元素
Dialogue: 0,0:30:30.20,0:30:32.16,Default,,0,0,0,,总会是你传递过来的INITIAL-VALUE
Dialogue: 0,0:30:33.14,0:30:36.11,Default,,0,0,0,,所以INTEGRAL可以用CONS-STREAM来实现
Dialogue: 0,0:30:37.09,0:30:37.98,Default,,0,0,0,,我们可以定义它
Dialogue: 0,0:30:38.25,0:30:40.88,Default,,0,0,0,,甚至不用知道要积分的流是什么
Dialogue: 0,0:30:42.84,0:30:45.18,Default,,0,0,0,,只需要知道初始值是什么就行了
Dialogue: 0,0:30:46.71,0:30:48.17,Default,,0,0,0,,INTEGRAL还可以修改得更为智能
Dialogue: 0,0:30:48.41,0:30:50.68,Default,,0,0,0,,我们给它一个待积分的流
Dialogue: 0,0:30:50.83,0:30:51.92,Default,,0,0,0,,以及一个初值
Dialogue: 0,0:30:52.11,0:30:54.99,Default,,0,0,0,,直到你要求沿着这个流求解积分时
Dialogue: 0,0:30:55.21,0:30:56.97,Default,,0,0,0,,我才关心这个流是什么
Dialogue: 0,0:30:58.43,0:31:00.51,Default,,0,0,0,,换句话说INTEGRAL可以像CONS-STREAM一样
Dialogue: 0,0:31:00.57,0:31:03.74,Default,,0,0,0,,你可以认为INTEGRAL被放在DELAY之中
Dialogue: 0,0:31:03.76,0:31:04.86,Default,,0,0,0,,我们这样修改
Dialogue: 0,0:31:05.61,0:31:07.02,Default,,0,0,0,,这个过程是像这样的
Dialogue: 0,0:31:07.65,0:31:08.75,Default,,0,0,0,,这是另一个版本的INTEGRAL
Dialogue: 0,0:31:08.89,0:31:10.54,Default,,0,0,0,,这个跟之前的版本非常相似
Dialogue: 0,0:31:11.10,0:31:13.34,Default,,0,0,0,,只不过作为参数的流
Dialogue: 0,0:31:13.77,0:31:15.69,Default,,0,0,0,,必须要是一个延时对象
Dialogue: 0,0:31:17.11,0:31:18.43,Default,,0,0,0,,这个INTEGRAL又是如何运作的呢？
Dialogue: 0,0:31:18.85,0:31:21.79,Default,,0,0,0,,我们在内部定义的INT则是
Dialogue: 0,0:31:22.14,0:31:24.19,Default,,0,0,0,,用CONS-STREAM构造一个流
Dialogue: 0,0:31:24.73,0:31:26.44,Default,,0,0,0,,初值还是INITIAL-VALUE
Dialogue: 0,0:31:27.16,0:31:29.68,Default,,0,0,0,,但是在CONS-STREAM中
Dialogue: 0,0:31:29.74,0:31:32.30,Default,,0,0,0,,要注意 这里面有个隐藏的DELAY
Dialogue: 0,0:31:34.95,0:31:39.07,Default,,0,0,0,,只有在这个CONS-STREAM的内部
Dialogue: 0,0:31:39.82,0:31:42.11,Default,,0,0,0,,我才会查看延时对象的实际内容
Dialogue: 0,0:31:43.18,0:31:45.79,Default,,0,0,0,,所以 答案的第一个元素将会是初值
Dialogue: 0,0:31:45.97,0:31:47.90,Default,,0,0,0,,如果有人想访问我的尾部分
Dialogue: 0,0:31:48.40,0:31:49.42,Default,,0,0,0,,此时
Dialogue: 0,0:31:50.00,0:31:51.72,Default,,0,0,0,,我会FORCE该延迟对象
Dialogue: 0,0:31:52.62,0:31:53.60,Default,,0,0,0,,把结果记作S
Dialogue: 0,0:31:54.44,0:31:55.60,Default,,0,0,0,,然后再进行ADD-STREAMS
Dialogue: 0,0:31:56.36,0:31:59.26,Default,,0,0,0,,这个INTEGRAL就有点像CONS-STREAM
Dialogue: 0,0:31:59.26,0:32:02.59,Default,,0,0,0,,直到你确实需要知道第一个元素的时候
Dialogue: 0,0:32:03.88,0:32:07.13,Default,,0,0,0,,它才会去查看DELAYED-S是什么
Dialogue: 0,0:32:10.12,0:32:11.02,Default,,0,0,0,,如果这样的话
Dialogue: 0,0:32:11.52,0:32:12.83,Default,,0,0,0,,也就能求解 y' = y^2 了
Dialogue: 0,0:32:13.36,0:32:15.20,Default,,0,0,0,,这里我们只需要
Dialogue: 0,0:32:16.00,0:32:25.31,Default,,0,0,0,,把Y定义为对延时对象DY的积分
Dialogue: 0,0:32:27.09,0:32:28.22,Default,,0,0,0,,所以Y的定义就变成了
Dialogue: 0,0:32:28.40,0:32:34.36,Default,,0,0,0,,(INTEGRAL (DELAY DY) 1 .001)
Dialogue: 0,0:32:34.38,0:32:35.13,Default,,0,0,0,,这样一来就可以了
Dialogue: 0,0:32:35.28,0:32:37.44,Default,,0,0,0,,因为我输入Y的定义
Dialogue: 0,0:32:38.00,0:32:39.68,Default,,0,0,0,,它是某个东西的积分
Dialogue: 0,0:32:40.20,0:32:42.68,Default,,0,0,0,,但这是个延迟对象 我现在还不用关心
Dialogue: 0,0:32:44.60,0:32:46.32,Default,,0,0,0,,这之后 再定义DY
Dialogue: 0,0:32:46.32,0:32:47.37,Default,,0,0,0,,现在Y就有定义了
Dialogue: 0,0:32:47.55,0:32:48.89,Default,,0,0,0,,所以我在定义DY时
Dialogue: 0,0:32:49.13,0:32:50.67,Default,,0,0,0,,它可以知道Y的定义
Dialogue: 0,0:32:51.70,0:32:52.84,Default,,0,0,0,,一切都正常了
Dialogue: 0,0:32:52.84,0:32:54.33,Default,,0,0,0,,两个流都有第一个元素
Dialogue: 0,0:32:54.92,0:32:56.25,Default,,0,0,0,,当我不断取得下一个元素
Dialogue: 0,0:32:56.27,0:32:57.31,Default,,0,0,0,,沿着流做MAP运算时
Dialogue: 0,0:32:57.37,0:32:58.88,Default,,0,0,0,,Y和DY都被定义过了
Dialogue: 0,0:33:00.59,0:33:04.24,Default,,0,0,0,,所以为了继续这个游戏 我们不能仅仅
Dialogue: 0,0:33:04.67,0:33:07.13,Default,,0,0,0,,只使用隐藏在流中的DELAY
Dialogue: 0,0:33:08.36,0:33:08.97,Default,,0,0,0,,有问题么？
Dialogue: 0,0:33:13.52,0:33:14.27,Default,,0,0,0,,休息一下吧
Dialogue: 0,0:33:14.72,0:33:26.86,Default,,0,0,0,,[音乐]
Dialogue: 0,0:33:27.37,0:33:30.94,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:33:52.16,0:33:55.26,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:33:55.42,0:33:59.26,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:34:00.38,0:34:03.93,Declare,,0,0,0,,{\an2\fad(500,500)}流 II
Dialogue: 0,0:34:07.30,0:34:10.04,Default,,0,0,0,,上节课的最后
Dialogue: 0,0:34:10.89,0:34:11.80,Default,,0,0,0,,不知道你们注意到没有
Dialogue: 0,0:34:11.82,0:34:13.55,Default,,0,0,0,,事情正变得糟糕起来
Dialogue: 0,0:34:14.83,0:34:18.40,Default,,0,0,0,,我们讲了很多关于 流
Dialogue: 0,0:34:19.16,0:34:22.68,Default,,0,0,0,,以及分离程序中的时间和计算机中的时间
Dialogue: 0,0:34:22.86,0:34:26.28,Default,,0,0,0,,这些分离都被隐藏在流中了
Dialogue: 0,0:34:27.28,0:34:29.50,Default,,0,0,0,,上节课快结束时我们发现
Dialogue: 0,0:34:29.71,0:34:32.19,Default,,0,0,0,,为了真正发挥这种方法的优势
Dialogue: 0,0:34:32.22,0:34:34.38,Default,,0,0,0,,我们需要另外的DELAY
Dialogue: 0,0:34:34.38,0:34:35.85,Default,,0,0,0,,不只需要隐藏在CONS-STREAM中的DELAY
Dialogue: 0,0:34:36.09,0:34:37.95,Default,,0,0,0,,还需要显式地使用DELAY
Dialogue: 0,0:34:39.03,0:34:41.88,Default,,0,0,0,,我只是用微分方程举了一个很简单的例子
Dialogue: 0,0:34:42.35,0:34:44.08,Default,,0,0,0,,但是如果你有一个非常复杂的系统
Dialogue: 0,0:34:44.12,0:34:45.40,Default,,0,0,0,,里面充斥着各种各样的自循环
Dialogue: 0,0:34:45.95,0:34:47.84,Default,,0,0,0,,那就很难再发现
Dialogue: 0,0:34:47.90,0:34:49.31,Default,,0,0,0,,在什么地方需要额外的DELAY了
Dialogue: 0,0:34:49.92,0:34:51.18,Default,,0,0,0,,假如你一不小心漏了一个
Dialogue: 0,0:34:51.45,0:34:54.36,Default,,0,0,0,,就很难发现程序为什么不起效
Dialogue: 0,0:34:55.55,0:34:57.15,Default,,0,0,0,,这是一种混乱
Dialogue: 0,0:34:57.79,0:35:01.71,Default,,0,0,0,,让我们能够使用DELAY
Dialogue: 0,0:35:02.08,0:35:04.70,Default,,0,0,0,,有时却会让程序设计变得非常复杂
Dialogue: 0,0:35:04.72,0:35:06.80,Default,,0,0,0,,因为它们不能完全隐藏在流中
Dialogue: 0,0:35:08.51,0:35:09.79,Default,,0,0,0,,那么 有没有什么解决方案呢？
Dialogue: 0,0:35:11.13,0:35:12.67,Default,,0,0,0,,所幸的是 有
Dialogue: 0,0:35:13.48,0:35:16.08,Default,,0,0,0,,我们可以修改整个语言
Dialogue: 0,0:35:16.14,0:35:18.19,Default,,0,0,0,,使得所有的过程都表现得像CONS-STREAM一样
Dialogue: 0,0:35:19.10,0:35:21.48,Default,,0,0,0,,这样所有的过程都会
Dialogue: 0,0:35:22.32,0:35:25.45,Default,,0,0,0,,自动、隐式地为它的参数加上DELAY
Dialogue: 0,0:35:25.45,0:35:26.43,Default,,0,0,0,,这是什么意思呢？
Dialogue: 0,0:35:27.52,0:35:29.53,Default,,0,0,0,,就是说 当你调用一个过程时
Dialogue: 0,0:35:30.16,0:35:31.88,Default,,0,0,0,,参数并不会立即求值
Dialogue: 0,0:35:32.21,0:35:34.70,Default,,0,0,0,,只有在需要被求值的时候 它们才会被求值
Dialogue: 0,0:35:34.89,0:35:36.72,Default,,0,0,0,,它们也可能被传递给其它的过程
Dialogue: 0,0:35:36.76,0:35:38.12,Default,,0,0,0,,而这个过程也不会求值这些参数
Dialogue: 0,0:35:39.26,0:35:41.90,Default,,0,0,0,,因此这些过程间传递的是PROMISE
Dialogue: 0,0:35:42.15,0:35:44.46,Default,,0,0,0,,直到最后
Dialogue: 0,0:35:44.65,0:35:47.34,Default,,0,0,0,,你需要查看某个值的时候
Dialogue: 0,0:35:47.36,0:35:48.99,Default,,0,0,0,,可能是因为一个基本运算所需要
Dialogue: 0,0:35:49.37,0:35:51.48,Default,,0,0,0,,这是你才实际求值这些PROMISE
Dialogue: 0,0:35:52.38,0:35:53.16,Default,,0,0,0,,像这样修改语言之后
Dialogue: 0,0:35:53.36,0:35:55.37,Default,,0,0,0,,由于所有的东西都是统一被延时的
Dialogue: 0,0:35:57.16,0:35:59.00,Default,,0,0,0,,就不需要任何显式的DELAY了
Dialogue: 0,0:35:59.04,0:36:01.55,Default,,0,0,0,,因为它自动地内建在语言之中了
Dialogue: 0,0:36:03.24,0:36:04.38,Default,,0,0,0,,换句话来说
Dialogue: 0,0:36:05.10,0:36:08.14,Default,,0,0,0,,从技术上来说 我所描述的
Dialogue: 0,0:36:09.02,0:36:10.76,Default,,0,0,0,,如果修改后的语言被称作
Dialogue: 0,0:36:12.19,0:36:16.57,Default,,0,0,0,,所谓的“正则序求值”语言
Dialogue: 0,0:36:20.20,0:36:23.47,Default,,0,0,0,,这个跟我们一直使用的语言不同
Dialogue: 0,0:36:23.87,0:36:33.79,Default,,0,0,0,,我们所用的是“应用序求值”语言
Dialogue: 0,0:36:34.56,0:36:36.83,Default,,0,0,0,,还记得应用序求值的代换模型吧
Dialogue: 0,0:36:36.83,0:36:40.49,Default,,0,0,0,,当你求值一个组合式的时候
Dialogue: 0,0:36:40.51,0:36:42.11,Default,,0,0,0,,你需要先计算出每一个元素的值
Dialogue: 0,0:36:43.59,0:36:45.40,Default,,0,0,0,,先求值所有的参数
Dialogue: 0,0:36:45.72,0:36:47.42,Default,,0,0,0,,再把它们代换入过程的体
Dialogue: 0,0:36:47.60,0:36:49.55,Default,,0,0,0,,正则序则不是这样
Dialogue: 0,0:36:49.89,0:36:51.90,Default,,0,0,0,,你所做的则是
Dialogue: 0,0:36:52.76,0:36:54.41,Default,,0,0,0,,直接将参数代换入过程的体
Dialogue: 0,0:36:54.44,0:36:56.19,Default,,0,0,0,,而不先对参数求值
Dialogue: 0,0:36:56.54,0:36:58.08,Default,,0,0,0,,只是代换入了一个计算参数的PROMISE
Dialogue: 0,0:36:58.81,0:36:59.90,Default,,0,0,0,,换句话说就是
Dialogue: 0,0:36:59.92,0:37:02.09,Default,,0,0,0,,把作为参数的整个表达式
Dialogue: 0,0:37:02.28,0:37:04.84,Default,,0,0,0,,直接代入过程的体进行代换
Dialogue: 0,0:37:05.16,0:37:06.88,Default,,0,0,0,,在此之间从不进行任何化简
Dialogue: 0,0:37:07.16,0:37:08.76,Default,,0,0,0,,直到遇到一个基本运算符
Dialogue: 0,0:37:09.47,0:37:10.99,Default,,0,0,0,,这就是所谓的正则序求值语言
Dialogue: 0,0:37:12.17,0:37:13.12,Default,,0,0,0,,我们为什么不这样做呢？
Dialogue: 0,0:37:13.82,0:37:14.60,Default,,0,0,0,,这样做了之后
Dialogue: 0,0:37:15.00,0:37:17.34,Default,,0,0,0,,我们就获得了延时求值的所有优点
Dialogue: 0,0:37:17.90,0:37:18.80,Default,,0,0,0,,而不会一片混乱
Dialogue: 0,0:37:18.94,0:37:20.19,Default,,0,0,0,,事实上 如果我们这样做了之后
Dialogue: 0,0:37:20.43,0:37:22.67,Default,,0,0,0,,CONS也会是延时求值的
Dialogue: 0,0:37:22.68,0:37:24.57,Default,,0,0,0,,就和CONS-STREAM一样
Dialogue: 0,0:37:24.71,0:37:25.82,Default,,0,0,0,,我们就不再需要流了
Dialogue: 0,0:37:26.36,0:37:28.54,Default,,0,0,0,,因为表自动成为了流
Dialogue: 0,0:37:29.55,0:37:30.70,Default,,0,0,0,,表和流有一样的行为
Dialogue: 0,0:37:30.75,0:37:32.35,Default,,0,0,0,,所有的数据结构也会像那样
Dialogue: 0,0:37:32.35,0:37:33.64,Default,,0,0,0,,所有的都是
Dialogue: 0,0:37:35.07,0:37:37.63,Default,,0,0,0,,直到需要答案的时候
Dialogue: 0,0:37:37.66,0:37:39.42,Default,,0,0,0,,才会去实际的求值
Dialogue: 0,0:37:40.80,0:37:43.58,Default,,0,0,0,,不必再担心 什么时候需要显式地标注DELAY
Dialogue: 0,0:37:44.79,0:37:46.16,Default,,0,0,0,,为什么不这样做呢？
Dialogue: 0,0:37:47.16,0:37:48.81,Default,,0,0,0,,首先 已经有人这样做过了
Dialogue: 0,0:37:49.23,0:37:51.85,Default,,0,0,0,,有一些十分优雅的语言
Dialogue: 0,0:37:51.85,0:37:55.21,Default,,0,0,0,,其中最为人称道的是一门名为 Miranda 的语言
Dialogue: 0,0:37:55.77,0:37:56.76,Default,,0,0,0,,它是由
Dialogue: 0,0:37:57.44,0:37:59.80,Default,,0,0,0,,肯特大学的 David Turner 开发的
Dialogue: 0,0:38:00.71,0:38:01.93,Default,,0,0,0,,它就是用这样的原理实现的
Dialogue: 0,0:38:01.93,0:38:03.34,Default,,0,0,0,,Miranda是正则序求值语言
Dialogue: 0,0:38:04.27,0:38:05.55,Default,,0,0,0,,它的数据结构
Dialogue: 0,0:38:06.16,0:38:08.41,Default,,0,0,0,,看起来像表 实际上确实流
Dialogue: 0,0:38:08.96,0:38:10.91,Default,,0,0,0,,你不需要任何特殊的功能
Dialogue: 0,0:38:11.28,0:38:13.28,Default,,0,0,0,,就可以在Miranda中编写普通的过程
Dialogue: 0,0:38:13.32,0:38:14.97,Default,,0,0,0,,来解决质数、八皇后这样的问题
Dialogue: 0,0:38:14.97,0:38:16.35,Default,,0,0,0,,这些都是语言的内建功能
Dialogue: 0,0:38:17.93,0:38:18.91,Default,,0,0,0,,但这样做也要付出代价
Dialogue: 0,0:38:21.19,0:38:22.36,Default,,0,0,0,,还记得我们为什么引入流了吗？
Dialogue: 0,0:38:23.17,0:38:27.48,Default,,0,0,0,,我们分离了程序的时间和它实际执行的时间
Dialogue: 0,0:38:27.96,0:38:28.88,Default,,0,0,0,,如果我们引入了DELAY
Dialogue: 0,0:38:29.04,0:38:30.33,Default,,0,0,0,,这样就在所有的地方完成了解耦
Dialogue: 0,0:38:30.40,0:38:31.42,Default,,0,0,0,,而不单单是在流中
Dialogue: 0,0:38:32.19,0:38:33.14,Default,,0,0,0,,我们的初衷是什么？
Dialogue: 0,0:38:33.14,0:38:38.11,Default,,0,0,0,,我们把程序设计看做是指定计算过程
Dialogue: 0,0:38:39.30,0:38:40.62,Default,,0,0,0,,如果我们放弃了对时间的控制
Dialogue: 0,0:38:40.65,0:38:42.41,Default,,0,0,0,,尽管语言变得优雅起来
Dialogue: 0,0:38:43.74,0:38:45.87,Default,,0,0,0,,但是它的表达力却有所下降
Dialogue: 0,0:38:47.03,0:38:49.84,Default,,0,0,0,,这里面还有一些我们无法消除的区别
Dialogue: 0,0:38:51.48,0:38:53.15,Default,,0,0,0,,其中之一就是迭代
Dialogue: 0,0:38:53.98,0:38:56.44,Default,,0,0,0,,还记得这个程序吗？
Dialogue: 0,0:38:56.96,0:38:58.28,Default,,0,0,0,,迭代式的阶乘
Dialogue: 0,0:38:58.44,0:39:00.48,Default,,0,0,0,,这是我们很早之前就研究过的
Dialogue: 0,0:39:01.23,0:39:02.97,Default,,0,0,0,,过程FACT-ITER
Dialogue: 0,0:39:03.04,0:39:04.91,Default,,0,0,0,,有一个内部过程ITER
Dialogue: 0,0:39:05.18,0:39:07.50,Default,,0,0,0,,它含有两个状态PRODUCT和COUNTER
Dialogue: 0,0:39:08.70,0:39:10.96,Default,,0,0,0,,它们随着循环不断迭代
Dialogue: 0,0:39:12.12,0:39:13.68,Default,,0,0,0,,之所以说这个过程是迭代的
Dialogue: 0,0:39:13.71,0:39:14.83,Default,,0,0,0,,是因为它没有创建新状态
Dialogue: 0,0:39:15.73,0:39:17.45,Default,,0,0,0,,之所以没有创建新状态
Dialogue: 0,0:39:17.47,0:39:20.25,Default,,0,0,0,,是因为在调用ITER时
Dialogue: 0,0:39:20.30,0:39:22.86,Default,,0,0,0,,作为参数传递给它自己的始终是这些东西
Dialogue: 0,0:39:23.90,0:39:25.39,Default,,0,0,0,,在代换模型中
Dialogue: 0,0:39:25.55,0:39:27.79,Default,,0,0,0,,Gerald教授给你们讲解过
Dialogue: 0,0:39:28.72,0:39:30.01,Default,,0,0,0,,在迭代过程中
Dialogue: 0,0:39:30.03,0:39:31.44,Default,,0,0,0,,状态并不需要增长
Dialogue: 0,0:39:31.82,0:39:34.22,Default,,0,0,0,,因此这是一个迭代过程
Dialogue: 0,0:39:34.99,0:39:37.47,Default,,0,0,0,,但是如果用正则序语言
Dialogue: 0,0:39:37.47,0:39:39.10,Default,,0,0,0,,来运行这段程序
Dialogue: 0,0:39:41.15,0:39:42.17,Default,,0,0,0,,这就会导致
Dialogue: 0,0:39:42.88,0:39:44.96,Default,,0,0,0,,这个过程不再是迭代式了
Dialogue: 0,0:39:45.65,0:39:48.67,Default,,0,0,0,,如果你仔细地思考代换模型
Dialogue: 0,0:39:48.67,0:39:49.90,Default,,0,0,0,,在这里我就不细说了
Dialogue: 0,0:39:51.20,0:39:52.35,Default,,0,0,0,,这个表达式会不断增长
Dialogue: 0,0:39:52.36,0:39:53.18,Default,,0,0,0,,为什么会这样？
Dialogue: 0,0:39:53.28,0:39:55.20,Default,,0,0,0,,因为当ITER调用自己时
Dialogue: 0,0:39:55.85,0:39:57.31,Default,,0,0,0,,参数是这个乘法表达式
Dialogue: 0,0:39:58.08,0:39:59.36,Default,,0,0,0,,而在正则序语言中
Dialogue: 0,0:39:59.39,0:40:01.16,Default,,0,0,0,,这个乘法并不会在这里求值
Dialogue: 0,0:40:02.51,0:40:03.82,Default,,0,0,0,,传递给自己并代换的
Dialogue: 0,0:40:03.93,0:40:05.68,Default,,0,0,0,,只是这个乘法计算的PROMISE
Dialogue: 0,0:40:06.67,0:40:08.03,Default,,0,0,0,,然后继续代换下去
Dialogue: 0,0:40:09.76,0:40:11.55,Default,,0,0,0,,我调用自己
Dialogue: 0,0:40:11.84,0:40:14.04,Default,,0,0,0,,用的是计算这个乘法的PROMISE
Dialogue: 0,0:40:14.04,0:40:17.82,Default,,0,0,0,,但其中的一个因数也是个PROMISE
Dialogue: 0,0:40:18.40,0:40:19.43,Default,,0,0,0,,然后我又自调用
Dialogue: 0,0:40:19.43,0:40:21.13,Default,,0,0,0,,如果你用代换模型
Dialogue: 0,0:40:21.98,0:40:23.60,Default,,0,0,0,,来推演这个迭代步骤
Dialogue: 0,0:40:23.77,0:40:26.83,Default,,0,0,0,,你会发现同样的状态增长
Dialogue: 0,0:40:27.16,0:40:28.96,Default,,0,0,0,,所有的PROMISE都需要被记住
Dialogue: 0,0:40:28.97,0:40:30.76,Default,,0,0,0,,以便在最后被调用
Dialogue: 0,0:40:31.79,0:40:35.02,Default,,0,0,0,,所以 正则序的缺点之一
Dialogue: 0,0:40:35.05,0:40:36.86,Default,,0,0,0,,就是无法有效地表达迭代
Dialogue: 0,0:40:36.98,0:40:39.60,Default,,0,0,0,,也许这个理由有点偏理论
Dialogue: 0,0:40:39.61,0:40:43.90,Default,,0,0,0,,但事实上 那些使用这类语言来编写
Dialogue: 0,0:40:44.27,0:40:47.56,Default,,0,0,0,,实际操作系统的人 也都遇到了这类问题
Dialogue: 0,0:40:48.20,0:40:50.75,Default,,0,0,0,,当然 完全可以
Dialogue: 0,0:40:51.64,0:40:54.38,Default,,0,0,0,,用这类语言实现一个文本编辑器
Dialogue: 0,0:40:54.61,0:40:56.08,Default,,0,0,0,,但是你才用了一会儿
Dialogue: 0,0:40:56.72,0:40:59.39,Default,,0,0,0,,就发现已经占用了3MB空间
Dialogue: 0,0:40:59.44,0:41:02.04,Default,,0,0,0,,我想 那些遇到这类问题的人
Dialogue: 0,0:41:02.16,0:41:05.60,Default,,0,0,0,,把它叫做 “拖尾问题”
Dialogue: 0,0:41:05.82,0:41:08.20,Default,,0,0,0,,由于不能有效地表达迭代计算
Dialogue: 0,0:41:08.24,0:41:10.46,Default,,0,0,0,,导致堆积了一堆没有被调用的PROMISE
Dialogue: 0,0:41:10.72,0:41:14.81,Default,,0,0,0,,针对这类语言的一个研究方向就是
Dialogue: 0,0:41:14.83,0:41:17.48,Default,,0,0,0,,找出一种有效的编译器技术
Dialogue: 0,0:41:17.82,0:41:19.85,Default,,0,0,0,,来避免这种所谓的“拖尾问题”
Dialogue: 0,0:41:20.17,0:41:21.61,Default,,0,0,0,,这并不简单
Dialogue: 0,0:41:23.94,0:41:27.31,Default,,0,0,0,,但是 还有一个很突出的问题
Dialogue: 0,0:41:27.96,0:41:31.04,Default,,0,0,0,,使你的语言不能变成正则序
Dialogue: 0,0:41:32.51,0:41:33.29,Default,,0,0,0,,问题就在于
Dialogue: 0,0:41:35.05,0:41:38.09,Default,,0,0,0,,正则序和副作用
Dialogue: 0,0:41:38.89,0:41:40.19,Default,,0,0,0,,是不相容的
Dialogue: 0,0:41:42.00,0:41:43.96,Default,,0,0,0,,它们不能很好地相互配合
Dialogue: 0,0:41:45.44,0:41:46.65,Default,,0,0,0,,这是因为 你不能
Dialogue: 0,0:41:48.28,0:41:50.80,Default,,0,0,0,,你不能一边
Dialogue: 0,0:41:51.00,0:41:54.33,Default,,0,0,0,,建模具有局部状态的对象
Dialogue: 0,0:41:55.72,0:41:56.96,Default,,0,0,0,,同时又
Dialogue: 0,0:41:57.18,0:41:59.55,Default,,0,0,0,,使用正则序的技巧来解耦时间
Dialogue: 0,0:42:00.40,0:42:03.55,Default,,0,0,0,,我来举一个非常简单的例子
Dialogue: 0,0:42:03.79,0:42:05.50,Default,,0,0,0,,假设语言是正则序求值
Dialogue: 0,0:42:07.52,0:42:09.55,Default,,0,0,0,,例子是这样的
Dialogue: 0,0:42:09.55,0:42:10.52,Default,,0,0,0,,注意现在是正则序求值
Dialogue: 0,0:42:10.52,0:42:12.22,Default,,0,0,0,,(DEFINE X 0)
Dialogue: 0,0:42:13.57,0:42:15.56,Default,,0,0,0,,这只是变量的初始化
Dialogue: 0,0:42:15.75,0:42:17.69,Default,,0,0,0,,现在我要定义一个有趣的函数
Dialogue: 0,0:42:18.57,0:42:20.44,Default,,0,0,0,,它就是恒等函数ID
Dialogue: 0,0:42:22.64,0:42:23.90,Default,,0,0,0,,它所做的就是
Dialogue: 0,0:42:24.11,0:42:26.60,Default,,0,0,0,,用X来记录上一次调用它时N的值
Dialogue: 0,0:42:31.40,0:42:34.16,Default,,0,0,0,,因此(ID N)就返回N
Dialogue: 0,0:42:34.17,0:42:35.39,Default,,0,0,0,,但还要把X赋值为N
Dialogue: 0,0:42:36.76,0:42:38.54,Default,,0,0,0,,最后再定义一个过程INC
Dialogue: 0,0:42:39.55,0:42:42.30,Default,,0,0,0,,也非常简单
Dialogue: 0,0:42:42.58,0:42:45.34,Default,,0,0,0,,假设在正则序求值的语言里
Dialogue: 0,0:42:46.27,0:42:47.23,Default,,0,0,0,,求值下面的表达式
Dialogue: 0,0:42:47.23,0:42:52.83,Default,,0,0,0,,我输入 (DEFINE Y (INC (ID 3)))
Dialogue: 0,0:42:52.83,0:42:53.96,Default,,0,0,0,,因此Y的值应该是4
Dialogue: 0,0:42:57.41,0:42:58.35,Default,,0,0,0,,X应该是多少呢？
Dialogue: 0,0:42:59.52,0:43:02.16,Default,,0,0,0,,X应该是最后一次被记住的值
Dialogue: 0,0:43:02.64,0:43:04.01,Default,,0,0,0,,也就是我调用函数ID的时候
Dialogue: 0,0:43:04.71,0:43:06.73,Default,,0,0,0,,你可能会想 这里X应该是3
Dialogue: 0,0:43:06.91,0:43:07.52,Default,,0,0,0,,但是并不是这样
Dialogue: 0,0:43:08.53,0:43:11.15,Default,,0,0,0,,这是因为当我在这里定义Y的时候
Dialogue: 0,0:43:11.79,0:43:13.45,Default,,0,0,0,,Y的真正定义却是
Dialogue: 0,0:43:13.47,0:43:15.71,Default,,0,0,0,,一个调用函数ID的PROMISE的增量
Dialogue: 0,0:43:17.00,0:43:18.17,Default,,0,0,0,,因为我没有访问Y
Dialogue: 0,0:43:18.36,0:43:20.25,Default,,0,0,0,,所以ID没有运行
Dialogue: 0,0:43:21.56,0:43:23.20,Default,,0,0,0,,我输入这个定义之后
Dialogue: 0,0:43:23.31,0:43:24.80,Default,,0,0,0,,然后查询X得到的结果是0
Dialogue: 0,0:43:28.36,0:43:31.20,Default,,0,0,0,,现在 我输入Y查询它的值
Dialogue: 0,0:43:31.52,0:43:32.43,Default,,0,0,0,,就会得到结果4
Dialogue: 0,0:43:32.67,0:43:35.16,Default,,0,0,0,,对Y的主动查询
Dialogue: 0,0:43:35.29,0:43:37.42,Default,,0,0,0,,会导致ID运行
Dialogue: 0,0:43:38.72,0:43:40.48,Default,,0,0,0,,现在X=3就被记住
Dialogue: 0,0:43:40.74,0:43:41.87,Default,,0,0,0,,所以上面这里的X就应该是0
Dialogue: 0,0:43:41.93,0:43:42.96,Default,,0,0,0,,下面这里是3
Dialogue: 0,0:43:43.28,0:43:46.16,Default,,0,0,0,,这是一个非常简单的场景
Dialogue: 0,0:43:46.30,0:43:49.28,Default,,0,0,0,,但你会发现 调试正则序语言
Dialogue: 0,0:43:50.36,0:43:53.34,Default,,0,0,0,,的交互式程序
Dialogue: 0,0:43:54.12,0:43:55.88,Default,,0,0,0,,会变得相当混乱
Dialogue: 0,0:43:57.10,0:43:58.12,Default,,0,0,0,,很令人迷惑
Dialogue: 0,0:43:59.69,0:44:02.04,Default,,0,0,0,,导致这样的深层次的原因
Dialogue: 0,0:44:02.80,0:44:06.41,Default,,0,0,0,,也就是引入DELAY的根本理念
Dialogue: 0,0:44:06.92,0:44:08.43,Default,,0,0,0,,是因为我们抛弃了时间的概念
Dialogue: 0,0:44:09.78,0:44:11.75,Default,,0,0,0,,也因为如此我们可以处理一些无穷的情况
Dialogue: 0,0:44:11.75,0:44:12.97,Default,,0,0,0,,我们抛弃了时间
Dialogue: 0,0:44:12.99,0:44:14.27,Default,,0,0,0,,就没有必要等它们运行
Dialogue: 0,0:44:17.55,0:44:20.44,Default,,0,0,0,,我们把计算机中事件发生的顺序
Dialogue: 0,0:44:20.83,0:44:22.11,Default,,0,0,0,,与程序中的顺序 分离开来
Dialogue: 0,0:44:22.35,0:44:25.28,Default,,0,0,0,,但是当我们谈及状态、赋值和改变的时候
Dialogue: 0,0:44:25.48,0:44:27.42,Default,,0,0,0,,这些又都是我们想要控制的
Dialogue: 0,0:44:28.76,0:44:33.82,Default,,0,0,0,,我们的目的有着根本性的矛盾
Dialogue: 0,0:44:34.57,0:44:39.12,Default,,0,0,0,,这又让我们进入了一个哲学问题
Dialogue: 0,0:44:39.13,0:44:40.75,Default,,0,0,0,,用什么样的模型
Dialogue: 0,0:44:40.78,0:44:41.77,Default,,0,0,0,,和从什么角度来看这个世界
Dialogue: 0,0:44:42.41,0:44:44.30,Default,,0,0,0,,有时这也被称为
Dialogue: 0,0:44:44.76,0:44:46.60,Default,,0,0,0,,“函数式程序设计的争论”
Dialogue: 0,0:44:54.19,0:44:56.60,Default,,0,0,0,,所谓的“纯函数式语言”
Dialogue: 0,0:44:57.07,0:44:59.20,Default,,0,0,0,,是完全没有副作用的
Dialogue: 0,0:45:00.44,0:45:01.63,Default,,0,0,0,,不需要副作用
Dialogue: 0,0:45:01.64,0:45:03.02,Default,,0,0,0,,也就不需要赋值运算符
Dialogue: 0,0:45:03.34,0:45:05.72,Default,,0,0,0,,也就没有什么糟糕的后果
Dialogue: 0,0:45:06.36,0:45:07.93,Default,,0,0,0,,可以使用类似代换模型
Dialogue: 0,0:45:07.93,0:45:10.48,Default,,0,0,0,,程序更像是数学
Dialogue: 0,0:45:10.76,0:45:13.82,Default,,0,0,0,,而不像现实世界中的模型和对象
Dialogue: 0,0:45:15.05,0:45:17.17,Default,,0,0,0,,函数式语言有很多了不起的特性
Dialogue: 0,0:45:17.17,0:45:19.63,Default,,0,0,0,,没有时间的概念 所以完全不用担心同步的问题
Dialogue: 0,0:45:20.64,0:45:23.72,Default,,0,0,0,,如果你想在并行算法中应用一些东西
Dialogue: 0,0:45:24.72,0:45:28.20,Default,,0,0,0,,你可以在这些并行过程中随心所欲地使用
Dialogue: 0,0:45:29.40,0:45:31.44,Default,,0,0,0,,从来不担心同步问题
Dialogue: 0,0:45:31.50,0:45:33.34,Default,,0,0,0,,在这种环境下这样做是非常方便的
Dialogue: 0,0:45:33.64,0:45:35.71,Default,,0,0,0,,代价则是 放弃了赋值
Dialogue: 0,0:45:39.10,0:45:41.32,Default,,0,0,0,,函数式语言的支持者会认为
Dialogue: 0,0:45:41.34,0:45:43.04,Default,,0,0,0,,这点代价算不了什么
Dialogue: 0,0:45:44.52,0:45:46.51,Default,,0,0,0,,在大部分情况下 你都不应该使用赋值
Dialogue: 0,0:45:46.88,0:45:48.27,Default,,0,0,0,,如果用你放弃了赋值
Dialogue: 0,0:45:48.43,0:45:51.40,Default,,0,0,0,,你可以得到一个比对象世界
Dialogue: 0,0:45:51.96,0:45:53.24,Default,,0,0,0,,好得多的世界
Dialogue: 0,0:45:54.19,0:45:56.30,Default,,0,0,0,,怎么来反驳这个观点呢？
Dialogue: 0,0:45:56.30,0:45:58.59,Default,,0,0,0,,想想 我们如何走到这一步的
Dialogue: 0,0:46:00.06,0:46:03.79,Default,,0,0,0,,我们尝试建模具有局部状态的对象
Dialogue: 0,0:46:04.44,0:46:06.49,Default,,0,0,0,,想一想Gerald教授给你们讲的随机数生成器
Dialogue: 0,0:46:07.16,0:46:08.67,Default,,0,0,0,,这里有一个随机数生成器
Dialogue: 0,0:46:09.28,0:46:10.62,Default,,0,0,0,,它内部有一些状态
Dialogue: 0,0:46:10.83,0:46:12.08,Default,,0,0,0,,用来计算下一个随机数
Dialogue: 0,0:46:12.12,0:46:14.08,Default,,0,0,0,,下下一个 以及再下一个
Dialogue: 0,0:46:14.28,0:46:16.14,Default,,0,0,0,,我们想要把这些状态跟
Dialogue: 0,0:46:16.43,0:46:18.96,Default,,0,0,0,,计算π的Cesaro算法分离开来
Dialogue: 0,0:46:19.84,0:46:20.92,Default,,0,0,0,,这就是我们为什么需要赋值
Dialogue: 0,0:46:20.97,0:46:22.91,Default,,0,0,0,,我们想要把状态封装在模块中
Dialogue: 0,0:46:24.07,0:46:26.36,Default,,0,0,0,,函数式语言程序员可能会说
Dialogue: 0,0:46:26.38,0:46:27.56,Default,,0,0,0,,“你搞错了”
Dialogue: 0,0:46:27.56,0:46:29.84,Default,,0,0,0,,“我的意思是 你能写出另一种更具模块化的程序”
Dialogue: 0,0:46:29.84,0:46:32.46,Default,,0,0,0,,“你对模块化的认识并不正确”
Dialogue: 0,0:46:33.08,0:46:35.02,Default,,0,0,0,,你太执着于 “生成一个随机数
Dialogue: 0,0:46:35.07,0:46:36.88,Default,,0,0,0,,再生成一个 再生成一个” 这种范式了
Dialogue: 0,0:46:36.88,0:46:39.42,Default,,0,0,0,,为什么不写一个这样的程序
Dialogue: 0,0:46:40.09,0:46:41.29,Default,,0,0,0,,构造一个枚举器
Dialogue: 0,0:46:41.95,0:46:44.48,Default,,0,0,0,,它会生成一个随机数的无穷流
Dialogue: 0,0:46:49.01,0:46:50.91,Default,,0,0,0,,我们可以立即生成这个流
Dialogue: 0,0:46:52.64,0:46:54.54,Default,,0,0,0,,这样就可以用作随机数的源泉
Dialogue: 0,0:46:54.54,0:46:55.24,Default,,0,0,0,,如果有需要的话
Dialogue: 0,0:46:55.53,0:46:57.47,Default,,0,0,0,,你可以把它跟某个处理过程相连
Dialogue: 0,0:46:57.77,0:47:01.16,Default,,0,0,0,,比如说Cesaro测试
Dialogue: 0,0:47:04.94,0:47:06.22,Default,,0,0,0,,然后这个处理过程进行自己的计算
Dialogue: 0,0:47:06.88,0:47:08.56,Default,,0,0,0,,从这里出来的则是
Dialogue: 0,0:47:08.72,0:47:27.45,Default,,0,0,0,,其中是一串的对π的估计值组成的流
Dialogue: 0,0:47:28.14,0:47:30.65,Default,,0,0,0,,随着我们深入访问这个流
Dialogue: 0,0:47:30.76,0:47:32.38,Default,,0,0,0,,相当于去拽这个Cesaro盒子
Dialogue: 0,0:47:33.12,0:47:35.36,Default,,0,0,0,,它就会拉取出许多随机数
Dialogue: 0,0:47:35.54,0:47:37.21,Default,,0,0,0,,随着我们对流的深入访问
Dialogue: 0,0:47:37.23,0:47:38.96,Default,,0,0,0,,得到的对π的估计值就越准
Dialogue: 0,0:47:39.72,0:47:41.66,Default,,0,0,0,,具体的计算过程还是一样的
Dialogue: 0,0:47:41.66,0:47:43.79,Default,,0,0,0,,只不过使用了另一种模块化的方式
Dialogue: 0,0:47:43.89,0:47:45.55,Default,,0,0,0,,我们可以想象成一下子
Dialogue: 0,0:47:45.56,0:47:47.47,Default,,0,0,0,,就有了这所有的随机数
Dialogue: 0,0:47:49.28,0:47:52.24,Default,,0,0,0,,这个过程的细节在书上有
Dialogue: 0,0:47:53.61,0:47:57.85,Default,,0,0,0,,我们同样也陷于另外一些类似的事情中
Dialogue: 0,0:47:58.27,0:48:01.20,Default,,0,0,0,,这种关于 这个、下一个以及再下一个的范式
Dialogue: 0,0:48:01.37,0:48:02.81,Default,,0,0,0,,完全可以不这么来做
Dialogue: 0,0:48:03.28,0:48:06.54,Default,,0,0,0,,我们来思考一下银行系统
Dialogue: 0,0:48:07.68,0:48:08.90,Default,,0,0,0,,有个非常简单的场景
Dialogue: 0,0:48:08.90,0:48:12.21,Default,,0,0,0,,我们假设这个程序代表了银行帐户
Dialogue: 0,0:48:18.81,0:48:20.84,Default,,0,0,0,,银行账户中可能有
Dialogue: 0,0:48:22.78,0:48:26.22,Default,,0,0,0,,如果我们以消息传递的角度来看
Dialogue: 0,0:48:26.44,0:48:28.12,Default,,0,0,0,,我们认为银行账户是一个对象
Dialogue: 0,0:48:28.59,0:48:31.51,Default,,0,0,0,,内部保存着标识余额的局部状态BALANCE
Dialogue: 0,0:48:34.11,0:48:36.00,Default,,0,0,0,,如果一个用户使用这个系统
Dialogue: 0,0:48:36.44,0:48:38.14,Default,,0,0,0,,发出交易请求
Dialogue: 0,0:48:39.31,0:48:41.05,Default,,0,0,0,,用户发出的交易请求可能是
Dialogue: 0,0:48:41.07,0:48:42.20,Default,,0,0,0,,存一些钱
Dialogue: 0,0:48:42.28,0:48:43.53,Default,,0,0,0,,银行账户就会
Dialogue: 0,0:48:43.92,0:48:46.78,Default,,0,0,0,,我们假设银行账户总是以当前余额作为回应
Dialogue: 0,0:48:48.22,0:48:50.04,Default,,0,0,0,,用户存了一些钱
Dialogue: 0,0:48:50.06,0:48:53.21,Default,,0,0,0,,银行账户就会返回一个消息指明当前余额
Dialogue: 0,0:48:54.35,0:48:57.42,Default,,0,0,0,,用户再存一些钱
Dialogue: 0,0:48:57.45,0:48:58.81,Default,,0,0,0,,银行就再返回消息
Dialogue: 0,0:48:59.15,0:49:00.75,Default,,0,0,0,,就像生成随机数一样
Dialogue: 0,0:49:00.78,0:49:02.12,Default,,0,0,0,,我们想使用赋值来实现
Dialogue: 0,0:49:03.20,0:49:06.88,Default,,0,0,0,,帐户的内部保存了局部状态BALANCE
Dialogue: 0,0:49:06.88,0:49:08.40,Default,,0,0,0,,因为我们想要把用户状态
Dialogue: 0,0:49:08.41,0:49:09.57,Default,,0,0,0,,和银行账户的状态分离开来
Dialogue: 0,0:49:13.28,0:49:16.42,Default,,0,0,0,,这是从消息传递的角度来看
Dialogue: 0,0:49:16.42,0:49:18.20,Default,,0,0,0,,如果从流的角度来看
Dialogue: 0,0:49:19.48,0:49:22.19,Default,,0,0,0,,不需要赋值或副作用就可以达到同样的效果
Dialogue: 0,0:49:22.74,0:49:26.73,Default,,0,0,0,,再次强调 想法是这样的
Dialogue: 0,0:49:27.37,0:49:30.25,Default,,0,0,0,,我们认为它们都没有局部状态
Dialogue: 0,0:49:31.18,0:49:33.08,Default,,0,0,0,,我们把银行账户看作是
Dialogue: 0,0:49:33.40,0:49:37.71,Default,,0,0,0,,能够处理一系列交易请求的东西
Dialogue: 0,0:49:38.64,0:49:40.16,Default,,0,0,0,,不把银行账户看做
Dialogue: 0,0:49:40.22,0:49:42.00,Default,,0,0,0,,逐个消息地处理
Dialogue: 0,0:49:42.44,0:49:45.85,Default,,0,0,0,,而是处理某种交易请求流的东西
Dialogue: 0,0:49:45.87,0:49:48.49,Default,,0,0,0,,这个请求流可能是一些列的存款声明
Dialogue: 0,0:49:49.49,0:49:54.94,Default,,0,0,0,,比如 1 2 2 4 这样的连续存钱请求
Dialogue: 0,0:49:55.94,0:50:02.44,Default,,0,0,0,,从帐户出来的流应该是 1 3 5 9
Dialogue: 0,0:50:03.77,0:50:06.14,Default,,0,0,0,,我们不把银行账户看做某种具有状态的东西
Dialogue: 0,0:50:06.40,0:50:07.26,Default,,0,0,0,,而是某种能够处理
Dialogue: 0,0:50:08.92,0:50:10.82,Default,,0,0,0,,有关请求的无穷流的东西
Dialogue: 0,0:50:10.82,0:50:12.30,Default,,0,0,0,,但要注意 我们抛弃了时间
Dialogue: 0,0:50:12.37,0:50:14.27,Default,,0,0,0,,如果这里有一个用户
Dialogue: 0,0:50:16.12,0:50:19.13,Default,,0,0,0,,这个无穷请求流的元素
Dialogue: 0,0:50:19.18,0:50:22.54,Default,,0,0,0,,我们可以一次生成一个
Dialogue: 0,0:50:24.06,0:50:26.57,Default,,0,0,0,,而这个交易流
Dialogue: 0,0:50:26.57,0:50:28.80,Default,,0,0,0,,则会逐个打印在屏幕上
Dialogue: 0,0:50:30.01,0:50:31.37,Default,,0,0,0,,如果在这里画一条线
Dialogue: 0,0:50:32.56,0:50:33.08,Default,,0,0,0,,就在这里
Dialogue: 0,0:50:33.28,0:50:34.91,Default,,0,0,0,,对用户来说 他根本无法分辨
Dialogue: 0,0:50:36.19,0:50:37.71,Default,,0,0,0,,这个系统是否有内部状态
Dialogue: 0,0:50:39.56,0:50:41.13,Default,,0,0,0,,这个跟消息传递那种是一样的
Dialogue: 0,0:50:41.29,0:50:42.46,Default,,0,0,0,,只不过这个没有状态
Dialogue: 0,0:50:42.84,0:50:45.87,Default,,0,0,0,,哦 顺便提一下
Dialogue: 0,0:50:46.72,0:50:49.47,Default,,0,0,0,,这是具体的代码实现
Dialogue: 0,0:50:50.52,0:50:52.30,Default,,0,0,0,,我们把它叫做MAKE-DEPOSIT-ACCOUNT
Dialogue: 0,0:50:52.32,0:50:53.32,Default,,0,0,0,,因为它只能够存钱
Dialogue: 0,0:50:54.17,0:50:55.77,Default,,0,0,0,,这个过程接受一个初始余额
Dialogue: 0,0:50:56.09,0:50:58.09,Default,,0,0,0,,以及一个可能发起的存款流
Dialogue: 0,0:51:00.02,0:51:00.82,Default,,0,0,0,,具体怎么做呢？
Dialogue: 0,0:51:00.82,0:51:02.54,Default,,0,0,0,,它只是用CONS-STREAM把余额BALANCE
Dialogue: 0,0:51:03.23,0:51:05.31,Default,,0,0,0,,和一个新的存款账户流组合在一起
Dialogue: 0,0:51:06.24,0:51:07.32,Default,,0,0,0,,新存款流的初始余额
Dialogue: 0,0:51:07.48,0:51:10.27,Default,,0,0,0,,就是之前BALANCE的值加上存款流的第一个元素
Dialogue: 0,0:51:10.86,0:51:13.40,Default,,0,0,0,,而其余部分则是
Dialogue: 0,0:51:13.76,0:51:17.37,Default,,0,0,0,,存款流的尾部分
Dialogue: 0,0:51:18.30,0:51:23.84,Default,,0,0,0,,因此这种非常典型的消息传递式、面向对象的问题
Dialogue: 0,0:51:23.95,0:51:27.55,Default,,0,0,0,,完全可以不用副作用来解决
Dialogue: 0,0:51:29.05,0:51:30.76,Default,,0,0,0,,很多地方都可以这样做
Dialogue: 0,0:51:32.25,0:51:35.23,Default,,0,0,0,,那么 我们可以完全不用赋值么？
Dialogue: 0,0:51:36.40,0:51:39.00,Default,,0,0,0,,可以只用纯函数式语言吗？
Dialogue: 0,0:51:40.05,0:51:42.04,Default,,0,0,0,,这个问题谁也说不清
Dialogue: 0,0:51:42.27,0:51:43.44,Default,,0,0,0,,好像有些地方
Dialogue: 0,0:51:43.92,0:51:46.03,Default,,0,0,0,,纯函数式语言无法派上用场
Dialogue: 0,0:51:48.10,0:51:50.27,Default,,0,0,0,,当遇到像这样的系统时 问题就变得棘手起来
Dialogue: 0,0:51:50.43,0:51:52.32,Default,,0,0,0,,特别是当你
Dialogue: 0,0:51:52.60,0:51:54.27,Default,,0,0,0,,还需要考虑其它因素的时候
Dialogue: 0,0:51:54.30,0:51:55.64,Default,,0,0,0,,有关对象和共享
Dialogue: 0,0:51:55.90,0:51:58.52,Default,,0,0,0,,以及两个独立的主体共享同一个东西
Dialogue: 0,0:51:58.85,0:51:59.93,Default,,0,0,0,,举一个典型的例子
Dialogue: 0,0:51:59.96,0:52:01.63,Default,,0,0,0,,假如你来扩展这个帐户
Dialogue: 0,0:52:03.24,0:52:04.27,Default,,0,0,0,,这是一个帐户
Dialogue: 0,0:52:12.22,0:52:14.75,Default,,0,0,0,,帐户接受一个交易请求流
Dialogue: 0,0:52:15.20,0:52:18.44,Default,,0,0,0,,输出的流则是关于余额的回复
Dialogue: 0,0:52:18.78,0:52:20.16,Default,,0,0,0,,假设你所建模的是联合账户
Dialogue: 0,0:52:20.17,0:52:24.36,Default,,0,0,0,,而由两个独立用户共享
Dialogue: 0,0:52:25.68,0:52:28.65,Default,,0,0,0,,我们假设 假设有两个人
Dialogue: 0,0:52:28.97,0:52:30.96,Default,,0,0,0,,比如说Bill和Dave
Dialogue: 0,0:52:31.77,0:52:33.14,Default,,0,0,0,,他们俩共享一个帐户
Dialogue: 0,0:52:35.96,0:52:36.85,Default,,0,0,0,,怎么来建模呢？
Dialogue: 0,0:52:36.88,0:52:39.80,Default,,0,0,0,,你或许会让Bill输出一个交易请求流
Dialogue: 0,0:52:40.24,0:52:42.25,Default,,0,0,0,,Dave也产生一个这样的流
Dialogue: 0,0:52:42.25,0:52:45.16,Default,,0,0,0,,这两个流需要以某种方式合并到银行账户中
Dialogue: 0,0:52:45.88,0:52:47.85,Default,,0,0,0,,因此你需要编写一个MERGE过程
Dialogue: 0,0:52:47.90,0:52:50.65,Default,,0,0,0,,来处理这些流
Dialogue: 0,0:52:57.23,0:52:59.13,Default,,0,0,0,,它把这些流合并在一起
Dialogue: 0,0:52:59.34,0:53:01.19,Default,,0,0,0,,形成单个流 送入银行账户
Dialogue: 0,0:53:01.19,0:53:02.99,Default,,0,0,0,,现在他们就共享一个帐户了
Dialogue: 0,0:53:03.61,0:53:05.48,Default,,0,0,0,,看起来不错 问题是怎么来实现MERGE
Dialogue: 0,0:53:05.93,0:53:08.24,Default,,0,0,0,,MERGE怎么来合并？
Dialogue: 0,0:53:09.73,0:53:11.42,Default,,0,0,0,,需要合理的合并依据
Dialogue: 0,0:53:12.38,0:53:13.80,Default,,0,0,0,,你可能首先会想
Dialogue: 0,0:53:13.80,0:53:16.68,Default,,0,0,0,,我们从Bill和Dave中选一个请求来处理
Dialogue: 0,0:53:18.19,0:53:20.97,Default,,0,0,0,,但是如果在这中途
Dialogue: 0,0:53:21.18,0:53:23.08,Default,,0,0,0,,Dave突然外出度假两年 会怎么样？
Dialogue: 0,0:53:24.15,0:53:25.40,Default,,0,0,0,,Bill的交易就完全被阻塞了
Dialogue: 0,0:53:27.69,0:53:29.75,Default,,0,0,0,,你想要的是
Dialogue: 0,0:53:29.75,0:53:33.64,Default,,0,0,0,,是一种公平的合并
Dialogue: 0,0:53:38.41,0:53:40.17,Default,,0,0,0,,这个所谓公平的合并
Dialogue: 0,0:53:40.73,0:53:42.46,Default,,0,0,0,,应该是交替地一次处理一个
Dialogue: 0,0:53:42.49,0:53:43.92,Default,,0,0,0,,但是如果一个人没有了交易
Dialogue: 0,0:53:43.96,0:53:44.91,Default,,0,0,0,,应该继续去处理另一个人的交易
Dialogue: 0,0:53:46.01,0:53:48.45,Default,,0,0,0,,但是没有时间 我就不能这样做
Dialogue: 0,0:53:51.30,0:53:56.41,Default,,0,0,0,,函数式语言的另一个活跃研究领域就是
Dialogue: 0,0:53:56.43,0:53:59.48,Default,,0,0,0,,发明类似于“公平合并”的算法
Dialogue: 0,0:54:00.35,0:54:01.31,Default,,0,0,0,,又或者是其它的东西
Dialogue: 0,0:54:01.56,0:54:06.25,Default,,0,0,0,,用于取代原来需要副作用和对象的地方
Dialogue: 0,0:54:06.80,0:54:10.52,Default,,0,0,0,,用一种良好定义的模块化系统来隐藏它们
Dialogue: 0,0:54:10.86,0:54:13.50,Default,,0,0,0,,这样 系统中就不会到处产生
Dialogue: 0,0:54:13.52,0:54:15.34,Default,,0,0,0,,赋值所带来的问题
Dialogue: 0,0:54:15.40,0:54:17.88,Default,,0,0,0,,因为它可以被理解透彻的概念所描述
Dialogue: 0,0:54:20.78,0:54:22.70,Default,,0,0,0,,推而广之 我想你们也发现了
Dialogue: 0,0:54:23.12,0:54:24.06,Default,,0,0,0,,我们正面对 我所认为的
Dialogue: 0,0:54:24.08,0:54:26.67,Default,,0,0,0,,计算机科学中最基本的问题
Dialogue: 0,0:54:26.97,0:54:27.82,Default,,0,0,0,,也就是
Dialogue: 0,0:54:28.24,0:54:32.03,Default,,0,0,0,,我们如何定义一门支持延迟求值的语言
Dialogue: 0,0:54:34.14,0:54:35.08,Default,,0,0,0,,但同时又能够
Dialogue: 0,0:54:35.87,0:54:38.25,Default,,0,0,0,,又能够把事物看做对象来操作
Dialogue: 0,0:54:38.36,0:54:40.36,Default,,0,0,0,,怎么样才能两者兼有之？
Dialogue: 0,0:54:41.23,0:54:43.04,Default,,0,0,0,,我认为这个问题很困难
Dialogue: 0,0:54:43.04,0:54:45.52,Default,,0,0,0,,但是这个很困难的问题
Dialogue: 0,0:54:45.85,0:54:48.17,Default,,0,0,0,,却和计算机科学的关系不大
Dialogue: 0,0:54:48.59,0:54:50.24,Default,,0,0,0,,它真正涉及的是
Dialogue: 0,0:54:50.27,0:54:52.73,Default,,0,0,0,,两种不相容的看待世界的方式
Dialogue: 0,0:54:54.14,0:54:54.72,Default,,0,0,0,,有问题吗？
Dialogue: 0,0:55:17.55,0:55:19.20,Default,,0,0,0,,学生：你之前提到过
Dialogue: 0,0:55:20.11,0:55:21.32,Default,,0,0,0,,一旦引入了赋值
Dialogue: 0,0:55:21.32,0:55:25.89,Default,,0,0,0,,就不能使用代换模型了
Dialogue: 0,0:55:25.89,0:55:27.57,Default,,0,0,0,,除非你非常小心
Dialogue: 0,0:55:27.57,0:55:27.96,Default,,0,0,0,,教授：对的
Dialogue: 0,0:55:28.26,0:55:33.28,Default,,0,0,0,,学生：有什么技术或者指导方针
Dialogue: 0,0:55:33.42,0:55:35.92,Default,,0,0,0,,来确定赋值的影响
Dialogue: 0,0:55:36.52,0:55:40.30,Default,,0,0,0,,以便说清楚这个“很小心”是怎么回事吗？
Dialogue: 0,0:55:40.30,0:55:42.60,Default,,0,0,0,,教授：我不知道
Dialogue: 0,0:55:42.89,0:55:43.58,Default,,0,0,0,,我想想
Dialogue: 0,0:55:45.43,0:55:48.94,Default,,0,0,0,,当然 实现MEM-PROC也使用了赋值
Dialogue: 0,0:55:50.12,0:55:51.48,Default,,0,0,0,,但是它被隐藏了起来
Dialogue: 0,0:55:51.48,0:55:53.00,Default,,0,0,0,,因为它没有对结果造成影响
Dialogue: 0,0:55:53.48,0:55:56.44,Default,,0,0,0,,部分原因之一在于 一旦触发这个过程
Dialogue: 0,0:55:57.15,0:55:58.83,Default,,0,0,0,,它被求值并得到结果
Dialogue: 0,0:55:58.83,0:56:00.06,Default,,0,0,0,,这个结果不会再变化
Dialogue: 0,0:56:00.60,0:56:02.33,Default,,0,0,0,,有点像单次赋值
Dialogue: 0,0:56:02.35,0:56:03.85,Default,,0,0,0,,一个一般性原则就是
Dialogue: 0,0:56:04.30,0:56:06.35,Default,,0,0,0,,如果你只用这种单次赋值
Dialogue: 0,0:56:08.04,0:56:09.24,Default,,0,0,0,,并且它不再改变
Dialogue: 0,0:56:09.63,0:56:10.54,Default,,0,0,0,,我想应该不会有太大问题
Dialogue: 0,0:56:11.25,0:56:14.12,Default,,0,0,0,,还有一个问题在于MERGE --
Dialogue: 0,0:56:14.67,0:56:18.32,Default,,0,0,0,,让我想想对不对
Dialogue: 0,0:56:18.49,0:56:21.55,Default,,0,0,0,,我认为有了公平合并这一技术
Dialogue: 0,0:56:22.25,0:56:26.09,Default,,0,0,0,,你可以在语言的其它地方
Dialogue: 0,0:56:27.02,0:56:28.89,Default,,0,0,0,,有效地模拟赋值
Dialogue: 0,0:56:30.82,0:56:33.29,Default,,0,0,0,,这就像为了解决问题你会引入一些东西
Dialogue: 0,0:56:33.50,0:56:35.50,Default,,0,0,0,,我不清楚对公平合并来说是否成立
Dialogue: 0,0:56:35.53,0:56:39.31,Default,,0,0,0,,但是对人们正在尝试的一些一般性事情是成立的
Dialogue: 0,0:56:39.52,0:56:41.34,Default,,0,0,0,,所以 这可能是你引入的这一点点东西
Dialogue: 0,0:56:41.61,0:56:44.14,Default,,0,0,0,,突然间 使你能构建任何东西
Dialogue: 0,0:56:44.16,0:56:46.51,Default,,0,0,0,,这就几乎跟有了赋值一样糟糕了
Dialogue: 0,0:56:47.97,0:56:50.67,Default,,0,0,0,,这也是人们在研究的一个领域
Dialogue: 0,0:56:51.59,0:56:54.30,Default,,0,0,0,,学生：我还没有太明白MERGE的问题
Dialogue: 0,0:56:54.83,0:56:59.20,Default,,0,0,0,,如果我调用Bill它是个过程
Dialogue: 0,0:56:59.21,0:57:02.41,Default,,0,0,0,,那么Bill就会增加银行账户
Dialogue: 0,0:57:02.44,0:57:04.73,Default,,0,0,0,,或者创建一个表 用于放置下一个存款
Dialogue: 0,0:57:04.73,0:57:06.84,Default,,0,0,0,,如果我连续调用Dave两次 他肯定也会那样
Dialogue: 0,0:57:07.17,0:57:09.35,Default,,0,0,0,,我并不清楚为什么需要公平合并
Dialogue: 0,0:57:09.35,0:57:11.20,Default,,0,0,0,,教授：关键在于你得把这些当作真人一样
Dialogue: 0,0:57:11.20,0:57:14.20,Default,,0,0,0,,这里有一个用户在操作帐户
Dialogue: 0,0:57:14.85,0:57:17.07,Default,,0,0,0,,请求一次 得到结果
Dialogue: 0,0:57:17.20,0:57:17.56,Default,,0,0,0,,学生：对
Dialogue: 0,0:57:18.20,0:57:20.62,Default,,0,0,0,,教授：如果我只能通过从两个流中选择一个
Dialogue: 0,0:57:20.65,0:57:22.25,Default,,0,0,0,,来处理请求的话
Dialogue: 0,0:57:22.91,0:57:24.22,Default,,0,0,0,,学生：为什么要二选一呢？
Dialogue: 0,0:57:24.22,0:57:25.23,Default,,0,0,0,,教授：为什么不呢？
Dialogue: 0,0:57:25.45,0:57:25.80,Default,,0,0,0,,学生：对啊 为什么要这样呢？
Dialogue: 0,0:57:26.60,0:57:27.72,Default,,0,0,0,,教授：假设这些是现实中的人 对吗？
Dialogue: 0,0:57:27.76,0:57:28.97,Default,,0,0,0,,这个人外出一年
Dialogue: 0,0:57:29.28,0:57:31.74,Default,,0,0,0,,你只能在银行账户窗口旁边等待
Dialogue: 0,0:57:32.43,0:57:33.72,Default,,0,0,0,,就是不能处理两个请求
Dialogue: 0,0:57:33.74,0:57:34.94,Default,,0,0,0,,因为你还得等这个人
Dialogue: 0,0:57:35.48,0:57:37.07,Default,,0,0,0,,学生：为什么非得等他呢？
Dialogue: 0,0:57:37.38,0:57:39.11,Default,,0,0,0,,教授：因为这里是在计算一个函数
Dialogue: 0,0:57:39.11,0:57:40.92,Default,,0,0,0,,我必须定义一个函数
Dialogue: 0,0:57:41.72,0:57:42.60,Default,,0,0,0,,换种方式来说
Dialogue: 0,0:57:42.84,0:57:44.99,Default,,0,0,0,,这个MERGE盒子的输出
Dialogue: 0,0:57:46.24,0:57:49.48,Default,,0,0,0,,并不是输入的函数
Dialogue: 0,0:57:51.69,0:57:53.49,Default,,0,0,0,,明白了吗？再来看看这个MERGE是怎么运行的
Dialogue: 0,0:57:53.49,0:57:58.86,Default,,0,0,0,,假设Bill输入 1 1 1 1
Dialogue: 0,0:57:59.82,0:58:02.78,Default,,0,0,0,,Dave输入2 2 2 2
Dialogue: 0,0:58:03.47,0:58:04.80,Default,,0,0,0,,MERGE应该输出什么呢？
Dialogue: 0,0:58:05.58,0:58:08.74,Default,,0,0,0,,这里并不一定是 1 2 1 2 1 2
Dialogue: 0,0:58:08.74,0:58:09.39,Default,,0,0,0,,学生：我明白了
Dialogue: 0,0:58:09.39,0:58:11.56,Default,,0,0,0,,当Bill输入1 1也就进去了
Dialogue: 0,0:58:11.56,0:58:13.95,Default,,0,0,0,,Dave再输入两个2 MERGE就输出两个2
Dialogue: 0,0:58:13.95,0:58:14.73,Default,,0,0,0,,学生：当Bill输入
Dialogue: 0,0:58:14.76,0:58:15.08,Default,,0,0,0,,教授：对的
Dialogue: 0,0:58:15.13,0:58:18.43,Default,,0,0,0,,学生：为什么不能在输入的数据上
Dialogue: 0,0:58:18.59,0:58:20.06,Default,,0,0,0,,加上时间信息呢？
Dialogue: 0,0:58:20.12,0:58:21.84,Default,,0,0,0,,教授：因为这里没有时间这个概念
Dialogue: 0,0:58:23.98,0:58:26.90,Default,,0,0,0,,我只是定义一个函数
Dialogue: 0,0:58:26.90,0:58:28.15,Default,,0,0,0,,没有时间概念
Dialogue: 0,0:58:32.00,0:58:34.19,Default,,0,0,0,,如果是二选一的话
Dialogue: 0,0:58:34.19,0:58:36.54,Default,,0,0,0,,如果选中的流没有人 就得等待它
Dialogue: 0,0:58:38.42,0:58:41.36,Default,,0,0,0,,它只会说 我有一个请求流
Dialogue: 0,0:58:41.74,0:58:43.34,Default,,0,0,0,,这是是Dave生成的
Dialogue: 0,0:58:43.36,0:58:45.29,Default,,0,0,0,,没有时刻的、无穷长度的请求流
Dialogue: 0,0:58:47.55,0:58:50.41,Default,,0,0,0,,Bill可能生成 没有时刻的无穷请求流
Dialogue: 0,0:58:50.54,0:58:51.69,Default,,0,0,0,,我想对这些东西做运算
Dialogue: 0,0:58:51.69,0:58:53.51,Default,,0,0,0,,这就是银行帐户的工作原理
Dialogue: 0,0:58:56.71,0:58:57.58,Default,,0,0,0,,问题是
Dialogue: 0,0:58:57.61,0:59:00.75,Default,,0,0,0,,这些坐在银行窗口前的倒霉蛋们
Dialogue: 0,0:59:00.76,0:59:03.82,Default,,0,0,0,,来得并不是时候
Dialogue: 0,0:59:05.29,0:59:07.13,Default,,0,0,0,,它们才看不到这个无穷流
Dialogue: 0,0:59:07.69,0:59:09.53,Default,,0,0,0,,什么时候其中会有请求
Dialogue: 0,0:59:10.07,0:59:11.55,Default,,0,0,0,,他们只是等着 等待帐户的响应
Dialogue: 0,0:59:14.48,0:59:15.76,Default,,0,0,0,,假设你坐在屏幕前
Dialogue: 0,0:59:16.24,0:59:20.86,Default,,0,0,0,,操作着一台分时系统的计算机
Dialogue: 0,0:59:21.52,0:59:22.60,Default,,0,0,0,,而且它还是函数式的
Dialogue: 0,0:59:22.64,0:59:24.59,Default,,0,0,0,,输入指令后你就希望看到结果
Dialogue: 0,0:59:25.29,0:59:27.42,Default,,0,0,0,,但是你并不想主机在处理完所有其它人的命令
Dialogue: 0,0:59:27.45,0:59:29.92,Default,,0,0,0,,之后再来处理你的命令
Dialogue: 0,0:59:30.91,0:59:31.92,Default,,0,0,0,,这就是问题所在
Dialogue: 0,0:59:34.00,0:59:36.38,Default,,0,0,0,,我的意思就是 用户的世界当然是存在时间概念的
Dialogue: 0,0:59:37.21,0:59:38.62,Default,,0,0,0,,如果没有 这就不构成问题
Dialogue: 0,0:59:49.10,0:59:51.02,Default,,0,0,0,,学生：我想我还是不太理解
Dialogue: 0,0:59:51.08,0:59:54.24,Default,,0,0,0,,银行交易中为什么没有时间概念这一要点
Dialogue: 0,0:59:54.74,0:59:56.65,Default,,0,0,0,,难道时间不是非常重要吗？
Dialogue: 0,0:59:56.88,0:59:59.05,Default,,0,0,0,,举例说 有一系列事件
Dialogue: 0,0:59:59.95,1:00:05.02,Default,,0,0,0,,比如Dave取款$100
Dialogue: 0,1:00:06.30,1:00:08.40,Default,,0,0,0,,这些顺序应该很重要才对
Dialogue: 0,1:00:08.40,1:00:10.86,Default,,0,0,0,,你怎么能把它们看作是流呢？
Dialogue: 0,1:00:11.26,1:00:14.26,Default,,0,0,0,,教授：这就是我一直在强调的
Dialogue: 0,1:00:14.26,1:00:15.61,Default,,0,0,0,,在这个例子中确实做不到那一点
Dialogue: 0,1:00:17.51,1:00:18.12,Default,,0,0,0,,做不到
Dialogue: 0,1:00:18.16,1:00:20.08,Default,,0,0,0,,关键在于 这里的输出
Dialogue: 0,1:00:20.24,1:00:21.88,Default,,0,0,0,,并不是这两个输入流
Dialogue: 0,1:00:21.92,1:00:23.60,Default,,0,0,0,,的函数
Dialogue: 0,1:00:24.17,1:00:25.98,Default,,0,0,0,,这个函数跟这个输入流有关
Dialogue: 0,1:00:26.19,1:00:27.26,Default,,0,0,0,,还跟这个输入流有关
Dialogue: 0,1:00:27.36,1:00:29.07,Default,,0,0,0,,还包括某种有关时间的信息
Dialogue: 0,1:00:29.37,1:00:32.36,Default,,0,0,0,,这也正是正则序语言不想让你知道的
Dialogue: 0,1:00:34.81,1:00:37.95,Default,,0,0,0,,学生：为了让这个系统更加函数式
Dialogue: 0,1:00:38.54,1:00:42.04,Default,,0,0,0,,我们能不能把Bill和Dave的交易请求附上时间戳
Dialogue: 0,1:00:42.54,1:00:46.40,Default,,0,0,0,,而使用时间戳作为公平合并的依据？
Dialogue: 0,1:00:48.41,1:00:49.55,Default,,0,0,0,,教授：当然 当然可以
Dialogue: 0,1:00:49.55,1:00:50.60,Default,,0,0,0,,你可以那样做
Dialogue: 0,1:00:50.60,1:00:52.56,Default,,0,0,0,,或者 我们可以这样来想象
Dialogue: 0,1:00:52.76,1:00:54.44,Default,,0,0,0,,我们把这个函数看作是
Dialogue: 0,1:00:54.78,1:00:56.88,Default,,0,0,0,,MERGE每毫秒读一次输入
Dialogue: 0,1:00:58.86,1:00:59.93,Default,,0,0,0,,如果没有读到东西
Dialogue: 0,1:00:59.93,1:01:00.97,Default,,0,0,0,,就认为没有请求
Dialogue: 0,1:01:00.97,1:01:03.39,Default,,0,0,0,,这和你刚刚说的那种方式是等价的
Dialogue: 0,1:01:03.61,1:01:06.08,Default,,0,0,0,,当然可以这样做 但有点旁门左道
Dialogue: 0,1:01:07.11,1:01:10.14,Default,,0,0,0,,我们不只是关心函数的具体实现
Dialogue: 0,1:01:10.76,1:01:12.73,Default,,0,0,0,,我们关心的是语言的表达力
Dialogue: 0,1:01:12.75,1:01:14.67,Default,,0,0,0,,我们遇到的困难是
Dialogue: 0,1:01:14.99,1:01:17.44,Default,,0,0,0,,我们不能很容易地表达我们想要表达的东西
Dialogue: 0,1:01:19.88,1:01:22.01,Default,,0,0,0,,学生：听起来好像如果两个人同时发出请求
Dialogue: 0,1:01:22.06,1:01:26.09,Default,,0,0,0,,这个方法就会出问题
Dialogue: 0,1:01:26.12,1:01:28.43,Default,,0,0,0,,教授：并不只是这个 只要是你定义的都可能出问题
Dialogue: 0,1:01:28.53,1:01:30.57,Default,,0,0,0,,你当然可以说Dave经常发起两个请求
Dialogue: 0,1:01:30.72,1:01:32.32,Default,,0,0,0,,但是你如果预先定义了什么
Dialogue: 0,1:01:32.68,1:01:33.87,Default,,0,0,0,,这样做也不正确
Dialogue: 0,1:01:36.11,1:01:40.70,Default,,0,0,0,,你不能确定某些特定函数的输入请求
Dialogue: 0,1:01:41.93,1:01:43.37,Default,,0,0,0,,但是还有更坏的情况
Dialogue: 0,1:01:44.12,1:01:45.72,Default,,0,0,0,,有一些情况甚至MERGE也处理不了
Dialogue: 0,1:01:47.29,1:01:49.69,Default,,0,0,0,,比如突然有一天你想要
Dialogue: 0,1:01:50.24,1:01:52.47,Default,,0,0,0,,把另一个人关联在这个银行帐户上
Dialogue: 0,1:01:52.47,1:01:54.51,Default,,0,0,0,,假如这个人是John
Dialogue: 0,1:01:56.03,1:01:58.89,Default,,0,0,0,,现在图上就要多一个流
Dialogue: 0,1:01:58.91,1:02:00.70,Default,,0,0,0,,在一个我们未曾指定的时候
Dialogue: 0,1:02:02.04,1:02:04.00,Default,,0,0,0,,这种情况甚至公平合并也无法给出合理的合并
Dialogue: 0,1:02:04.00,1:02:08.25,Default,,0,0,0,,还需要有MANAGER一类的东西
Dialogue: 0,1:02:08.86,1:02:11.79,Default,,0,0,0,,需要一种更一般性的公平合并来解决
Dialogue: 0,1:02:11.79,1:02:13.98,Default,,0,0,0,,有很多研究都在讨论
Dialogue: 0,1:02:14.00,1:02:16.30,Default,,0,0,0,,通过不断引入新机制
Dialogue: 0,1:02:16.59,1:02:18.72,Default,,0,0,0,,函数式思维能应用到哪种程度？
Dialogue: 0,1:02:19.58,1:02:21.79,Default,,0,0,0,,在我们不得不使用赋值之前
Dialogue: 0,1:02:21.82,1:02:23.40,Default,,0,0,0,,函数式程序设计能干成什么样？
Dialogue: 0,1:02:25.98,1:02:28.00,Default,,0,0,0,,学生：看来自动存款就不行
Dialogue: 0,1:02:39.32,1:02:40.49,Default,,0,0,0,,教授：好的 下课
Dialogue: 0,1:02:41.32,1:03:00.08,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:02:41.32,1:03:00.08,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
