[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Scroll Position: 621
Active Line: 629
Video Position: 66176

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.28,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:01.39,0:00:08.09,title,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:01.39,0:00:08.09,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N邓雄飞\N张大伟
Dialogue: 0,0:00:01.39,0:00:08.09,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:01.39,0:00:08.09,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:01.39,0:00:08.09,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:08.94,0:00:12.59,Declare,,0,0,0,,{\an2\fad(500,500)}元循环求值器 I
Dialogue: 0,0:00:15.79,0:00:17.32,Default,,0,0,0,,教授：今天我们将学习一些
Dialogue: 0,0:00:17.52,0:00:18.41,Default,,0,0,0,,非同一般的东西
Dialogue: 0,0:00:19.20,0:00:21.88,Default,,0,0,0,,我们将对计算机程序
Dialogue: 0,0:00:22.59,0:00:25.21,Default,,0,0,0,,有更深层次的理解
Dialogue: 0,0:00:26.80,0:00:29.12,Default,,0,0,0,,目前为止 我们一直把程序看作
Dialogue: 0,0:00:29.26,0:00:32.09,Default,,0,0,0,,对机器的描述
Dialogue: 0,0:00:32.72,0:00:37.21,Default,,0,0,0,,举个例子 在这个幻灯片上
Dialogue: 0,0:00:37.93,0:00:41.77,Default,,0,0,0,,我们可以看到一个计算阶乘的程序
Dialogue: 0,0:00:42.80,0:00:47.31,Default,,0,0,0,,当然 你可以认为这些字符串描述了
Dialogue: 0,0:00:47.66,0:00:51.98,Default,,0,0,0,,这个线路图所表示的无穷机器
Dialogue: 0,0:00:52.49,0:00:54.80,Default,,0,0,0,,我们可以稍稍地看下 它描述的是什么
Dialogue: 0,0:00:55.13,0:00:58.20,Default,,0,0,0,,这种紧凑的记法 描述的是：
Dialogue: 0,0:00:58.54,0:01:00.17,Default,,0,0,0,,如果N是0 结果就是1
Dialogue: 0,0:01:00.17,0:01:02.00,Default,,0,0,0,,N是从这里进入机器的
Dialogue: 0,0:01:02.33,0:01:03.52,Default,,0,0,0,,如果它是0的话
Dialogue: 0,0:01:03.74,0:01:05.20,Default,,0,0,0,,那么我就控制这个开关
Dialogue: 0,0:01:05.47,0:01:08.20,Default,,0,0,0,,把它掰到输出为1的那一端
Dialogue: 0,0:01:09.34,0:01:10.08,Default,,0,0,0,,否则的话
Dialogue: 0,0:01:10.38,0:01:12.83,Default,,0,0,0,,就是(* N (FACT (- N 1)))
Dialogue: 0,0:01:12.97,0:01:15.13,Default,,0,0,0,,我先计算(FACT (- N 1))
Dialogue: 0,0:01:15.29,0:01:16.68,Default,,0,0,0,,再把结果乘以N
Dialogue: 0,0:01:16.84,0:01:18.91,Default,,0,0,0,,这样如果N不为0的话
Dialogue: 0,0:01:18.91,0:01:20.60,Default,,0,0,0,,这个开关就会输出这里的结果
Dialogue: 0,0:01:21.90,0:01:22.32,Default,,0,0,0,,当然了
Dialogue: 0,0:01:22.36,0:01:25.13,Default,,0,0,0,,这个机器可能有无穷多个部件
Dialogue: 0,0:01:25.48,0:01:28.12,Default,,0,0,0,,因为FACT内部又调用了FACT
Dialogue: 0,0:01:28.43,0:01:30.17,Default,,0,0,0,,因此我们不知道调用栈有多深
Dialogue: 0,0:01:31.07,0:01:33.55,Default,,0,0,0,,但到目前为止
Dialogue: 0,0:01:34.22,0:01:37.69,Default,,0,0,0,,代码对我们来说就是这样的东西了
Dialogue: 0,0:01:38.31,0:01:40.59,Default,,0,0,0,,你可以认为代码是用字符串来描述
Dialogue: 0,0:01:41.28,0:01:44.16,Default,,0,0,0,,某种用其它方式描画的线路图
Dialogue: 0,0:01:44.90,0:01:46.60,Default,,0,0,0,,事实上 很多人都向我提议
Dialogue: 0,0:01:46.84,0:01:49.04,Default,,0,0,0,,说程序设计语言应该像这个一样 是图像化的
Dialogue: 0,0:01:49.49,0:01:51.80,Default,,0,0,0,,不过我不认为用图形表示会有很多优势
Dialogue: 0,0:01:52.00,0:01:53.79,Default,,0,0,0,,当然 最主要的劣势就是
Dialogue: 0,0:01:53.80,0:01:55.63,Default,,0,0,0,,它需要占用很大的平面空间
Dialogue: 0,0:01:55.96,0:01:59.95,Default,,0,0,0,,所以展示和修改起来就非常麻烦
Dialogue: 0,0:02:01.34,0:02:02.16,Default,,0,0,0,,但是不管怎样
Dialogue: 0,0:02:03.58,0:02:05.15,Default,,0,0,0,,在计算的世界中
Dialogue: 0,0:02:05.18,0:02:07.05,Default,,0,0,0,,还有一个非常重要的东西
Dialogue: 0,0:02:07.64,0:02:10.64,Default,,0,0,0,,也就是所谓的“通用机器”
Dialogue: 0,0:02:10.73,0:02:15.24,Default,,0,0,0,,我们再来看第二张幻灯片
Dialogue: 0,0:02:16.04,0:02:17.18,Default,,0,0,0,,我们看到的就是
Dialogue: 0,0:02:18.14,0:02:19.88,Default,,0,0,0,,名为EVAL的特殊机器
Dialogue: 0,0:02:21.26,0:02:22.86,Default,,0,0,0,,这个叫做EVAL的机器
Dialogue: 0,0:02:22.88,0:02:24.24,Default,,0,0,0,,也就是我今天要讲解的
Dialogue: 0,0:02:25.82,0:02:26.67,Default,,0,0,0,,它非常简单
Dialogue: 0,0:02:27.78,0:02:30.80,Default,,0,0,0,,最了不起的是 它简单得可以写在黑板上
Dialogue: 0,0:02:33.35,0:02:35.79,Default,,0,0,0,,然而 EVAL这个机器
Dialogue: 0,0:02:36.00,0:02:39.84,Default,,0,0,0,,是以其它机器的描述作为输入的
Dialogue: 0,0:02:40.45,0:02:42.12,Default,,0,0,0,,它可以接收一个
Dialogue: 0,0:02:42.40,0:02:45.58,Default,,0,0,0,,阶乘机器的线路图作为输入
Dialogue: 0,0:02:46.49,0:02:47.66,Default,,0,0,0,,这样一来
Dialogue: 0,0:02:48.49,0:02:52.57,Default,,0,0,0,,它就可以模拟那台阶乘机器
Dialogue: 0,0:02:53.13,0:02:53.79,Default,,0,0,0,,这样的话
Dialogue: 0,0:02:54.16,0:02:56.36,Default,,0,0,0,,如果输入6 就会得到720
Dialogue: 0,0:02:58.91,0:03:01.68,Default,,0,0,0,,这是一个非常了不起的机器
Dialogue: 0,0:03:02.13,0:03:03.58,Default,,0,0,0,,而最让人惊奇的是
Dialogue: 0,0:03:03.77,0:03:05.13,Default,,0,0,0,,它竟然可以写在一个黑板内
Dialogue: 0,0:03:05.59,0:03:06.65,Default,,0,0,0,,与之相反的是
Dialogue: 0,0:03:07.32,0:03:10.44,Default,,0,0,0,,我们可以想象一下模拟电子世界中的
Dialogue: 0,0:03:11.55,0:03:12.86,Default,,0,0,0,,一台非常不同的机器
Dialogue: 0,0:03:14.57,0:03:16.33,Default,,0,0,0,,这台机器呢
Dialogue: 0,0:03:16.52,0:03:18.81,Default,,0,0,0,,某种意义上 同样也是“通用机器”
Dialogue: 0,0:03:19.26,0:03:23.12,Default,,0,0,0,,只要你输入一个电路图
Dialogue: 0,0:03:23.82,0:03:25.74,Default,,0,0,0,,比如这个小型的低通滤波器
Dialogue: 0,0:03:26.01,0:03:27.48,Default,,0,0,0,,单极低通滤波器之类的
Dialogue: 0,0:03:28.05,0:03:29.53,Default,,0,0,0,,你可以想像
Dialogue: 0,0:03:29.71,0:03:33.15,Default,,0,0,0,,如果我们扫描这个元件得到扫描线
Dialogue: 0,0:03:34.43,0:03:37.13,Default,,0,0,0,,得到的信号描述的就是
Dialogue: 0,0:03:37.39,0:03:40.40,Default,,0,0,0,,这个机器所模拟的
Dialogue: 0,0:03:40.78,0:03:43.39,Default,,0,0,0,,这个模拟机器EVAL是由电路构成
Dialogue: 0,0:03:43.68,0:03:45.15,Default,,0,0,0,,它可以把自己配置成一个滤波器
Dialogue: 0,0:03:45.18,0:03:48.04,Default,,0,0,0,,响应由电路图指定的频率
Dialogue: 0,0:03:49.89,0:03:51.48,Default,,0,0,0,,这种机器很难制造出来
Dialogue: 0,0:03:51.61,0:03:54.06,Default,,0,0,0,,当然 更不可能用一个黑板就把它说清楚
Dialogue: 0,0:03:55.67,0:03:57.58,Default,,0,0,0,,所以今天我们将学习一些神奇的东西
Dialogue: 0,0:03:58.43,0:04:00.81,Default,,0,0,0,,我们将在黑板上见证
Dialogue: 0,0:04:01.16,0:04:02.49,Default,,0,0,0,,通用机器
Dialogue: 0,0:04:02.79,0:04:04.41,Default,,0,0,0,,跟其它程序比起来
Dialogue: 0,0:04:04.52,0:04:05.80,Default,,0,0,0,,它真是非常简单
Dialogue: 0,0:04:06.78,0:04:08.75,Default,,0,0,0,,现在 我们已经非常接近
Dialogue: 0,0:04:09.08,0:04:10.97,Default,,0,0,0,,计算机中真正的精灵了
Dialogue: 0,0:04:11.28,0:04:14.62,Default,,0,0,0,,所以为了保持足够的尊重
Dialogue: 0,0:04:15.18,0:04:17.32,Default,,0,0,0,,我特地穿上外套
Dialogue: 0,0:04:17.52,0:04:19.29,Default,,0,0,0,,你们应该从没见我穿过
Dialogue: 0,0:04:20.47,0:04:22.73,Default,,0,0,0,,在这个盛重的场合
Dialogue: 0,0:04:23.55,0:04:26.70,Default,,0,0,0,,我还得戴上一顶合适的帽子
Dialogue: 0,0:04:28.78,0:04:31.44,Default,,0,0,0,,开讲前再给大家提个醒
Dialogue: 0,0:04:34.14,0:04:36.91,Default,,0,0,0,,那些40岁以下
Dialogue: 0,0:04:37.16,0:04:38.49,Default,,0,0,0,,以及没有孩子的人
Dialogue: 0,0:04:38.67,0:04:40.49,Default,,0,0,0,,你们可要小心了
Dialogue: 0,0:04:40.49,0:04:41.96,Default,,0,0,0,,如果真的受不了 可以选择离开
Dialogue: 0,0:04:43.34,0:04:45.56,Default,,0,0,0,,因为一会儿要发生一些
Dialogue: 0,0:04:45.72,0:04:47.13,Default,,0,0,0,,非常神秘的事情
Dialogue: 0,0:04:47.74,0:04:51.05,Default,,0,0,0,,可能使你的大脑异常混乱
Dialogue: 0,0:04:51.82,0:04:54.28,Default,,0,0,0,,好了 无论如何
Dialogue: 0,0:04:55.71,0:05:01.10,Default,,0,0,0,,我要带着你们写一个Lisp求值器
Dialogue: 0,0:05:02.51,0:05:04.28,Default,,0,0,0,,求值器并不复杂
Dialogue: 0,0:05:05.02,0:05:07.63,Default,,0,0,0,,很像我们以前见到过的程序
Dialogue: 0,0:05:08.24,0:05:09.48,Default,,0,0,0,,这也是它令人吃惊的地方
Dialogue: 0,0:05:10.86,0:05:13.10,Default,,0,0,0,,现在我开始写这个程序
Dialogue: 0,0:05:15.28,0:05:16.62,Default,,0,0,0,,我把这个程序叫做EVAL
Dialogue: 0,0:05:22.90,0:05:26.24,Default,,0,0,0,,这个过程接收两个参数
Dialogue: 0,0:05:26.28,0:05:29.44,Default,,0,0,0,,表达式EXP和环境ENV
Dialogue: 0,0:05:31.86,0:05:33.79,Default,,0,0,0,,跟所有实用过程一样
Dialogue: 0,0:05:34.01,0:05:35.13,Default,,0,0,0,,它是个“按情况分析”语句
Dialogue: 0,0:05:40.46,0:05:41.87,Default,,0,0,0,,但是在我开始之前
Dialogue: 0,0:05:42.52,0:05:43.90,Default,,0,0,0,,我还想你们注意一下
Dialogue: 0,0:05:44.44,0:05:46.06,Default,,0,0,0,,我将要在黑板上写的程序
Dialogue: 0,0:05:46.56,0:05:50.24,Default,,0,0,0,,非常丑陋、混乱、令人作呕
Dialogue: 0,0:05:50.94,0:05:53.16,Default,,0,0,0,,并不是一种专业的写法
Dialogue: 0,0:05:54.32,0:05:56.57,Default,,0,0,0,,它是用具体语法写就的
Dialogue: 0,0:05:57.24,0:05:58.83,Default,,0,0,0,,也就是说用了很多CAR、CDR
Dialogue: 0,0:05:58.84,0:06:00.62,Default,,0,0,0,,我之前告诉过你们这样写并不好
Dialogue: 0,0:06:02.94,0:06:05.61,Default,,0,0,0,,在这里是故意这样来写的
Dialogue: 0,0:06:06.11,0:06:09.02,Default,,0,0,0,,因为我想让它尽量精简
Dialogue: 0,0:06:09.34,0:06:10.40,Default,,0,0,0,,能塞在黑板内
Dialogue: 0,0:06:10.43,0:06:11.85,Default,,0,0,0,,你们就可以看到整个代码
Dialogue: 0,0:06:12.42,0:06:14.80,Default,,0,0,0,,我就不像平时那样实用长变量名了
Dialogue: 0,0:06:15.60,0:06:17.29,Default,,0,0,0,,就用CAR、CDR 因为它们短小
Dialogue: 0,0:06:18.06,0:06:20.78,Default,,0,0,0,,这算是一种取舍
Dialogue: 0,0:06:20.89,0:06:22.81,Default,,0,0,0,,我不希望你们这样来写程序
Dialogue: 0,0:06:23.57,0:06:25.08,Default,,0,0,0,,这里单纯地想达到一种简洁的效果
Dialogue: 0,0:06:25.85,0:06:27.61,Default,,0,0,0,,因此你们读起来可能有些费力
Dialogue: 0,0:06:27.77,0:06:30.19,Default,,0,0,0,,我尽量写得清楚一些
Dialogue: 0,0:06:31.27,0:06:34.40,Default,,0,0,0,,这个解释器已经比较完整了
Dialogue: 0,0:06:34.51,0:06:36.24,Default,,0,0,0,,但是还是缺少一些功能
Dialogue: 0,0:06:36.25,0:06:38.60,Default,,0,0,0,,我就不写定义和赋值的部分了
Dialogue: 0,0:06:39.10,0:06:42.41,Default,,0,0,0,,因为它们都不是最本质的
Dialogue: 0,0:06:42.88,0:06:46.46,Default,,0,0,0,,稍后我就会解释 这是数学上的原因
Dialogue: 0,0:06:46.92,0:06:49.96,Default,,0,0,0,,当然啦 黑板也没有那么大
Dialogue: 0,0:06:51.88,0:06:53.64,Default,,0,0,0,,但是 我们怎么做呢？
Dialogue: 0,0:06:53.95,0:06:55.66,Default,,0,0,0,,我们需要一个分派
Dialogue: 0,0:06:56.09,0:06:57.90,Default,,0,0,0,,它根据表达式的类型
Dialogue: 0,0:06:58.28,0:07:00.38,Default,,0,0,0,,把它们划分为几类
Dialogue: 0,0:07:01.72,0:07:03.26,Default,,0,0,0,,这就是现在要做的
Dialogue: 0,0:07:03.82,0:07:05.15,Default,,0,0,0,,我们都有哪些表达式？
Dialogue: 0,0:07:05.15,0:07:06.36,Default,,0,0,0,,我们先来看几种表达式
Dialogue: 0,0:07:06.81,0:07:09.60,Default,,0,0,0,,比如说 数字“3”就是一个表达式
Dialogue: 0,0:07:10.42,0:07:11.58,Default,,0,0,0,,我想让它代表什么呢？
Dialogue: 0,0:07:12.72,0:07:14.75,Default,,0,0,0,,我有很多选择 但是就现在而言
Dialogue: 0,0:07:15.05,0:07:16.20,Default,,0,0,0,,我就想让它表示数字3
Dialogue: 0,0:07:17.05,0:07:17.88,Default,,0,0,0,,这就是我要的
Dialogue: 0,0:07:18.72,0:07:19.69,Default,,0,0,0,,这个足够简单
Dialogue: 0,0:07:20.03,0:07:22.91,Default,,0,0,0,,那就意味着 如果表达式是数字
Dialogue: 0,0:07:27.29,0:07:31.68,Default,,0,0,0,,表达式本身就应该是求值结果
Dialogue: 0,0:07:35.42,0:07:36.76,Default,,0,0,0,,另外一种情况是
Dialogue: 0,0:07:36.89,0:07:38.86,Default,,0,0,0,,表达式还可能是符号
Dialogue: 0,0:07:39.39,0:07:46.75,Default,,0,0,0,,比如EXP、ENV、EVAL、NUMBER、X之类
Dialogue: 0,0:07:48.01,0:07:49.18,Default,,0,0,0,,它们意味着什么？
Dialogue: 0,0:07:50.16,0:07:51.63,Default,,0,0,0,,它们是一类代表其它事物的事物
Dialogue: 0,0:07:51.63,0:07:53.23,Default,,0,0,0,,也就是我们语言中所谓的变量
Dialogue: 0,0:07:54.77,0:07:56.88,Default,,0,0,0,,因此我想要能够 比如说
Dialogue: 0,0:07:57.05,0:08:01.04,Default,,0,0,0,,对X求值 可能会得到3
Dialogue: 0,0:08:02.64,0:08:05.76,Default,,0,0,0,,又可能是CAR
Dialogue: 0,0:08:07.76,0:08:09.40,Default,,0,0,0,,我希望它的值是
Dialogue: 0,0:08:09.63,0:08:11.34,Default,,0,0,0,,某种类似于过程的东西
Dialogue: 0,0:08:16.51,0:08:18.43,Default,,0,0,0,,我不需要知道它内部是什么
Dialogue: 0,0:08:18.64,0:08:21.15,Default,,0,0,0,,可能是一些机器码 或者类似的东西
Dialogue: 0,0:08:22.84,0:08:24.27,Default,,0,0,0,,到这是还是相对简单的
Dialogue: 0,0:08:24.43,0:08:26.89,Default,,0,0,0,,我想把这部分交给其他人来写
Dialogue: 0,0:08:27.80,0:08:28.89,Default,,0,0,0,,如果我们有一个符号
Dialogue: 0,0:08:30.80,0:08:32.48,Default,,0,0,0,,假如表达式是符号
Dialogue: 0,0:08:33.42,0:08:34.88,Default,,0,0,0,,那么我求值它的结果就应该是
Dialogue: 0,0:08:34.91,0:08:40.24,Default,,0,0,0,,在环境ENV中查找该表达式的值
Dialogue: 0,0:08:46.48,0:08:48.99,Default,,0,0,0,,环境是一个字典
Dialogue: 0,0:08:49.96,0:08:54.06,Default,,0,0,0,,它把符号映射成一个值
Dialogue: 0,0:08:54.28,0:08:55.16,Default,,0,0,0,,就这么简单
Dialogue: 0,0:08:56.28,0:08:57.20,Default,,0,0,0,,怎么完成的呢？
Dialogue: 0,0:08:57.53,0:08:58.52,Default,,0,0,0,,稍后我们再谈这个
Dialogue: 0,0:08:59.68,0:09:00.57,Default,,0,0,0,,其实并不难
Dialogue: 0,0:09:01.67,0:09:04.28,Default,,0,0,0,,编写类似于表的数据结构非常容易
Dialogue: 0,0:09:04.84,0:09:05.74,Default,,0,0,0,,但它只是一个表
Dialogue: 0,0:09:05.77,0:09:07.56,Default,,0,0,0,,而这是存取某个表的过程
Dialogue: 0,0:09:09.55,0:09:10.81,Default,,0,0,0,,好的 接下来
Dialogue: 0,0:09:11.31,0:09:12.56,Default,,0,0,0,,另一类表达式
Dialogue: 0,0:09:12.67,0:09:15.56,Default,,0,0,0,,表达式可能是一些不是数字的常量
Dialogue: 0,0:09:16.06,0:09:17.43,Default,,0,0,0,,比如 'FOO
Dialogue: 0,0:09:20.17,0:09:21.29,Default,,0,0,0,,为了方便起见
Dialogue: 0,0:09:21.31,0:09:23.36,Default,,0,0,0,,我想在语法上
Dialogue: 0,0:09:24.73,0:09:26.80,Default,,0,0,0,,把它转换成表结构
Dialogue: 0,0:09:26.84,0:09:31.52,Default,,0,0,0,,比如说是(QUOTE FOO)
Dialogue: 0,0:09:33.72,0:09:37.18,Default,,0,0,0,,一个被引用起来的对象 无论它是什么
Dialogue: 0,0:09:38.35,0:09:40.83,Default,,0,0,0,,都实际上是一个缩写
Dialogue: 0,0:09:41.04,0:09:42.59,Default,,0,0,0,,这一部分并不由求值器负责
Dialogue: 0,0:09:43.21,0:09:44.46,Default,,0,0,0,,这是在其它地方完成的
Dialogue: 0,0:09:44.75,0:09:47.79,Default,,0,0,0,,左边的符号就是右边表达式的缩略形式
Dialogue: 0,0:09:48.78,0:09:50.48,Default,,0,0,0,,这样 我就可以
Dialogue: 0,0:09:50.57,0:09:53.12,Default,,0,0,0,,依据表达式的CAR部分
Dialogue: 0,0:09:53.31,0:09:55.95,Default,,0,0,0,,来判断它的类型了
Dialogue: 0,0:09:58.46,0:10:01.08,Default,,0,0,0,,因此这一部分也不会出现在求值器中
Dialogue: 0,0:10:01.65,0:10:02.68,Default,,0,0,0,,这在更早时候
Dialogue: 0,0:10:02.70,0:10:03.96,Default,,0,0,0,,比如源代码读取阶段完成
Dialogue: 0,0:10:05.54,0:10:15.04,Default,,0,0,0,,如果是引用表达式
Dialogue: 0,0:10:18.27,0:10:19.10,Default,,0,0,0,,那么求值的结果就是
Dialogue: 0,0:10:19.63,0:10:25.13,Default,,0,0,0,,我想让(QUOTE FOO)求值为自身FOO
Dialogue: 0,0:10:25.14,0:10:25.95,Default,,0,0,0,,一个常量
Dialogue: 0,0:10:27.53,0:10:28.92,Default,,0,0,0,,这条代码是说
Dialogue: 0,0:10:29.08,0:10:30.73,Default,,0,0,0,,这类表达式求值为它自己
Dialogue: 0,0:10:31.79,0:10:33.66,Default,,0,0,0,,怎么才能把它取出来呢？
Dialogue: 0,0:10:33.66,0:10:36.36,Default,,0,0,0,,这是列表第二个元素的第一个部分
Dialogue: 0,0:10:36.59,0:10:37.58,Default,,0,0,0,,也就是表的第二个元素
Dialogue: 0,0:10:38.49,0:10:40.32,Default,,0,0,0,,也就是CADR
Dialogue: 0,0:10:41.28,0:10:42.38,Default,,0,0,0,,所以这里我就写CADR
Dialogue: 0,0:10:51.08,0:10:52.35,Default,,0,0,0,,表达式还可能是什么类型呢？
Dialogue: 0,0:10:52.51,0:10:53.80,Default,,0,0,0,,还有LAMBDA表达式
Dialogue: 0,0:10:55.00,0:11:03.29,Default,,0,0,0,,比如 (LAMBDA (X) (+ X Y))
Dialogue: 0,0:11:04.16,0:11:06.33,Default,,0,0,0,,我还得找到某种表示方法
Dialogue: 0,0:11:06.33,0:11:07.85,Default,,0,0,0,,LAMBDA表达式求值的结果
Dialogue: 0,0:11:08.11,0:11:09.08,Default,,0,0,0,,也就是如何表示过程
Dialogue: 0,0:11:09.60,0:11:12.62,Default,,0,0,0,,过程并不就是表达式(LAMBDA (x))
Dialogue: 0,0:11:13.13,0:11:15.56,Default,,0,0,0,,表达式只是过程的代码描述
Dialogue: 0,0:11:16.41,0:11:18.33,Default,,0,0,0,,如果在词法作用域的语言中实现过程
Dialogue: 0,0:11:18.56,0:11:21.20,Default,,0,0,0,,那么我希望在表示过程的时候
Dialogue: 0,0:11:23.23,0:11:25.36,Default,,0,0,0,,能够把当前的求值环境包括进来
Dialogue: 0,0:11:25.84,0:11:29.07,Default,,0,0,0,,所以这里我还需要
Dialogue: 0,0:11:29.20,0:11:30.67,Default,,0,0,0,,一些类型标志
Dialogue: 0,0:11:30.70,0:11:33.90,Default,,0,0,0,,这样后面我就可以用它们来区分过程
Dialogue: 0,0:11:34.30,0:11:36.59,Default,,0,0,0,,看哪些是由LAMBDA表达式生成的
Dialogue: 0,0:11:36.81,0:11:38.03,Default,,0,0,0,,哪些是基本过程
Dialogue: 0,0:11:39.06,0:11:41.96,Default,,0,0,0,,所以这里是个类型标志
Dialogue: 0,0:11:41.98,0:11:43.56,Default,,0,0,0,,出于历史原因
Dialogue: 0,0:11:43.56,0:11:45.10,Default,,0,0,0,,我用CLOSURE作为类型标志
Dialogue: 0,0:11:47.68,0:11:49.60,Default,,0,0,0,,现在来看看 哪部分比较重要
Dialogue: 0,0:11:49.92,0:11:51.12,Default,,0,0,0,,我需要知道
Dialogue: 0,0:11:51.24,0:11:52.92,Default,,0,0,0,,绑定变量表和过程的体
Dialogue: 0,0:11:54.22,0:11:55.40,Default,,0,0,0,,这是它的CDR部分
Dialogue: 0,0:11:56.09,0:12:01.85,Default,,0,0,0,,这里就是((X) (+ X Y))
Dialogue: 0,0:12:03.04,0:12:03.87,Default,,0,0,0,,以及某个环境<ENV>
Dialogue: 0,0:12:08.17,0:12:12.20,Default,,0,0,0,,用户不应该看到这个东西
Dialogue: 0,0:12:13.53,0:12:16.19,Default,,0,0,0,,这只是过程对象的
Dialogue: 0,0:12:16.76,0:12:18.30,Default,,0,0,0,,一种内部表示
Dialogue: 0,0:12:18.52,0:12:20.52,Default,,0,0,0,,它包括绑定变量表
Dialogue: 0,0:12:20.70,0:12:22.62,Default,,0,0,0,,过程的体和某个环境
Dialogue: 0,0:12:23.53,0:12:25.80,Default,,0,0,0,,以及一个类型标签 表示这是一个过程
Dialogue: 0,0:12:26.34,0:12:27.37,Default,,0,0,0,,接下来写代码
Dialogue: 0,0:12:28.08,0:12:38.72,Default,,0,0,0,,如果表达式的CAR部分是'LAMBDA
Dialogue: 0,0:12:43.47,0:12:44.81,Default,,0,0,0,,这里 我就要
Dialogue: 0,0:12:45.64,0:12:51.84,Default,,0,0,0,,创建一个表 表头是'CLOSURE
Dialogue: 0,0:12:55.15,0:13:00.73,Default,,0,0,0,,接着是 过程代码的CDR部分
Dialogue: 0,0:13:01.56,0:13:02.97,Default,,0,0,0,,也就是除开LAMBDA的其它部分
Dialogue: 0,0:13:07.74,0:13:08.86,Default,,0,0,0,,以及当前的环境
Dialogue: 0,0:13:10.25,0:13:15.32,Default,,0,0,0,,这样就实现了环境模型中的那些规则
Dialogue: 0,0:13:15.45,0:13:18.52,Default,,0,0,0,,这是从LAMBDA表达式中构建过程所必须遵守的
Dialogue: 0,0:13:19.40,0:13:20.97,Default,,0,0,0,,那个求值器在遇到
Dialogue: 0,0:13:21.48,0:13:24.32,Default,,0,0,0,,LAMBDA表达式时的环境
Dialogue: 0,0:13:25.04,0:13:28.46,Default,,0,0,0,,在过程运行的时候
Dialogue: 0,0:13:28.68,0:13:31.77,Default,,0,0,0,,会去这个环境中查找自由变量的值
Dialogue: 0,0:13:34.72,0:13:35.82,Default,,0,0,0,,所以需要把它囊括进来
Dialogue: 0,0:13:35.92,0:13:37.55,Default,,0,0,0,,因此我们必须把求值时的环境
Dialogue: 0,0:13:37.56,0:13:38.86,Default,,0,0,0,,作为过程对象的一部分
Dialogue: 0,0:13:39.21,0:13:40.62,Default,,0,0,0,,之后再来看它的作用
Dialogue: 0,0:13:42.03,0:13:43.77,Default,,0,0,0,,我们也有COND表达式
Dialogue: 0,0:13:44.59,0:13:52.81,Default,,0,0,0,,像是(COND (P1 E1) (P2 E2) ...)这样的
Dialogue: 0,0:13:54.40,0:13:56.09,Default,,0,0,0,,P1是谓词
Dialogue: 0,0:13:56.35,0:13:58.43,Default,,0,0,0,,谓词总是返回TRUE或者FALSE
Dialogue: 0,0:13:58.99,0:14:01.76,Default,,0,0,0,,如果谓词P1为真时 表达式E1才被求值
Dialogue: 0,0:14:03.44,0:14:06.08,Default,,0,0,0,,当然 你也可以列这么一组子句
Dialogue: 0,0:14:06.79,0:14:09.36,Default,,0,0,0,,我会把它封装在另一个过程中
Dialogue: 0,0:14:09.36,0:14:11.56,Default,,0,0,0,,我们稍后在那个过程中进行处理
Dialogue: 0,0:14:12.42,0:14:21.28,Default,,0,0,0,,如果表达式的CAR部分是'COND的话
Dialogue: 0,0:14:24.00,0:14:26.84,Default,,0,0,0,,那么我就用EVCOND来求值这个表达式
Dialogue: 0,0:14:30.20,0:14:31.42,Default,,0,0,0,,求值表达式的CDR部分
Dialogue: 0,0:14:34.40,0:14:38.49,Default,,0,0,0,,记得带上环境
Dialogue: 0,0:14:41.43,0:14:42.60,Default,,0,0,0,,好的 还有一种情况
Dialogue: 0,0:14:44.09,0:14:48.22,Default,,0,0,0,,任意的像(+ X 3)这样的表达式
Dialogue: 0,0:14:50.62,0:14:53.95,Default,,0,0,0,,这是把运算符应用在运算对象上
Dialogue: 0,0:14:55.13,0:14:56.59,Default,,0,0,0,,这并没有什么特殊的
Dialogue: 0,0:14:56.59,0:14:59.63,Default,,0,0,0,,就是说 它不属于这里的特殊形式
Dialogue: 0,0:14:59.85,0:15:01.42,Default,,0,0,0,,上面写的这些都是特殊形式
Dialogue: 0,0:15:09.65,0:15:12.12,Default,,0,0,0,,再说明一下 如果我要把这个程序写得专业一点
Dialogue: 0,0:15:12.36,0:15:14.17,Default,,0,0,0,,我会把它设计成数据导向的
Dialogue: 0,0:15:14.48,0:15:16.52,Default,,0,0,0,,那样的话 这里就不会是一系列的条件判断
Dialogue: 0,0:15:16.65,0:15:18.20,Default,,0,0,0,,而是根据一些比特位来做分派
Dialogue: 0,0:15:19.42,0:15:22.25,Default,,0,0,0,,这样来设计会更加专业一些
Dialogue: 0,0:15:22.36,0:15:24.14,Default,,0,0,0,,并且 我不用大量修改程序
Dialogue: 0,0:15:24.68,0:15:26.38,Default,,0,0,0,,就可以添加规则
Dialogue: 0,0:15:26.71,0:15:28.46,Default,,0,0,0,,这样来做可能运行得更快
Dialogue: 0,0:15:29.04,0:15:30.43,Default,,0,0,0,,但这里我并不打算这么做
Dialogue: 0,0:15:31.28,0:15:33.98,Default,,0,0,0,,现在的目的是把握EVAL过程的整体
Dialogue: 0,0:15:35.07,0:15:35.80,Default,,0,0,0,,那么 最后一种情况
Dialogue: 0,0:15:37.69,0:15:38.56,Default,,0,0,0,,要怎么做呢？
Dialogue: 0,0:15:38.56,0:15:41.23,Default,,0,0,0,,在这种情况下 我需要进行加法运算
Dialogue: 0,0:15:44.35,0:15:46.16,Default,,0,0,0,,那么我就得搞清楚 '+到底是什么
Dialogue: 0,0:15:46.84,0:15:49.29,Default,,0,0,0,,我还得知道X和3又代表什么
Dialogue: 0,0:15:50.55,0:15:53.96,Default,,0,0,0,,然后再把'+的所代表的东西
Dialogue: 0,0:15:54.43,0:15:57.00,Default,,0,0,0,,应用于'X与3所代表的东西上
Dialogue: 0,0:15:58.11,0:15:59.39,Default,,0,0,0,,具体来写一下
Dialogue: 0,0:15:59.87,0:16:09.55,Default,,0,0,0,,我要把表达式CAR部分的求值结果
Dialogue: 0,0:16:11.20,0:16:12.14,Default,,0,0,0,,应用在
Dialogue: 0,0:16:13.21,0:16:15.50,Default,,0,0,0,,表达式的CAR部分就是运算符
Dialogue: 0,0:16:17.20,0:16:18.51,Default,,0,0,0,,要在给定的环境中进行
Dialogue: 0,0:16:20.51,0:16:22.89,Default,,0,0,0,,对运算符求值会得到一个过程
Dialogue: 0,0:16:24.05,0:16:26.78,Default,,0,0,0,,现在 我要求值所有运算对象来取得参数
Dialogue: 0,0:16:27.29,0:16:28.22,Default,,0,0,0,,我将调用EVLIST
Dialogue: 0,0:16:31.26,0:16:35.53,Default,,0,0,0,,来求值表达式的CDR部分 也就是运算对象
Dialogue: 0,0:16:36.76,0:16:39.00,Default,,0,0,0,,当然是在相应的环境中
Dialogue: 0,0:16:41.94,0:16:43.13,Default,,0,0,0,,我们待会儿再定义EVLIST
Dialogue: 0,0:16:43.26,0:16:48.07,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,0:16:50.90,0:16:52.33,Default,,0,0,0,,你现在看到的
Dialogue: 0,0:16:52.67,0:16:56.11,Default,,0,0,0,,基本上就是一个完整的求值器
Dialogue: 0,0:16:56.49,0:17:01.00,Default,,0,0,0,,它根据表达式的类型分情况处理
Dialogue: 0,0:17:01.24,0:17:02.11,Default,,0,0,0,,默认的情况是
Dialogue: 0,0:17:04.99,0:17:07.95,Default,,0,0,0,,表达式应用或者说是组合式
Dialogue: 0,0:17:17.52,0:17:19.52,Default,,0,0,0,,不过还有好些过程 我们没有定义
Dialogue: 0,0:17:20.08,0:17:21.60,Default,,0,0,0,,接下来就看这些未定义的部分
Dialogue: 0,0:17:21.78,0:17:24.12,Default,,0,0,0,,我们还要定义EVCOND
Dialogue: 0,0:17:25.48,0:17:26.67,Default,,0,0,0,,我得定义APPLY
Dialogue: 0,0:17:27.57,0:17:28.62,Default,,0,0,0,,还有EVLIST
Dialogue: 0,0:17:28.94,0:17:30.20,Default,,0,0,0,,以及LOOKUP
Dialogue: 0,0:17:31.79,0:17:33.43,Default,,0,0,0,,我看看 没别的了吧？
Dialogue: 0,0:17:33.43,0:17:35.16,Default,,0,0,0,,剩下的东西都很简单
Dialogue: 0,0:17:35.16,0:17:37.18,Default,,0,0,0,,比如基本元素之类的东西
Dialogue: 0,0:17:38.57,0:17:39.48,Default,,0,0,0,,当然
Dialogue: 0,0:17:39.69,0:17:42.06,Default,,0,0,0,,在这里 可以扩充很多特殊形式
Dialogue: 0,0:17:42.25,0:17:44.45,Default,,0,0,0,,但如果在通用语言中这么做就很糟糕
Dialogue: 0,0:17:44.45,0:17:45.92,Default,,0,0,0,,在这里添加大量的东西
Dialogue: 0,0:17:46.00,0:17:47.48,Default,,0,0,0,,会让语言变得复杂
Dialogue: 0,0:17:47.69,0:17:50.35,Default,,0,0,0,,语言中的保留字
Dialogue: 0,0:17:50.76,0:17:53.61,Default,,0,0,0,,不该比你能用几个手指、脚指记住的数目多
Dialogue: 0,0:17:54.16,0:17:55.53,Default,,0,0,0,,有些语言的保留字有成百上千个
Dialogue: 0,0:17:55.56,0:17:58.20,Default,,0,0,0,,我都不知道该说什么了
Dialogue: 0,0:17:59.41,0:18:00.71,Default,,0,0,0,,保留字就是在这里定义的
Dialogue: 0,0:18:03.15,0:18:06.54,Default,,0,0,0,,好 接下来 我们来看下一个部分
Dialogue: 0,0:18:06.56,0:18:07.69,Default,,0,0,0,,求值器的核心 APPLY
Dialogue: 0,0:18:09.64,0:18:10.75,Default,,0,0,0,,它还做些什么呢？
Dialogue: 0,0:18:11.59,0:18:17.53,Default,,0,0,0,,APPLY把还是符号状态的求值运算符和运算对象
Dialogue: 0,0:18:17.66,0:18:20.68,Default,,0,0,0,,求值为相应的过程以及参数值
Dialogue: 0,0:18:20.91,0:18:23.85,Default,,0,0,0,,然后把得到的过程应用在参数上
Dialogue: 0,0:18:24.09,0:18:26.96,Default,,0,0,0,,无论它们是什么符号表达式
Dialogue: 0,0:18:33.27,0:18:35.08,Default,,0,0,0,,我们把APPLY定义为
Dialogue: 0,0:18:38.35,0:18:40.65,Default,,0,0,0,,接收两个参数的过程
Dialogue: 0,0:18:40.75,0:18:43.44,Default,,0,0,0,,一个过程和对应的参数
Dialogue: 0,0:18:47.24,0:18:48.12,Default,,0,0,0,,它要怎么做呢？
Dialogue: 0,0:18:48.14,0:18:49.55,Default,,0,0,0,,其实并不复杂
Dialogue: 0,0:18:49.93,0:18:50.78,Default,,0,0,0,,分两种情况就够了
Dialogue: 0,0:18:53.58,0:18:55.16,Default,,0,0,0,,如果这个过程是基本过程--
Dialogue: 0,0:19:03.42,0:19:06.41,Default,,0,0,0,,我不知道这个谓词具体是如何判断的
Dialogue: 0,0:19:06.86,0:19:10.24,Default,,0,0,0,,可能这里面有某种类型信息
Dialogue: 0,0:19:10.38,0:19:12.41,Default,,0,0,0,,就像我们在这里用'CLOSURE
Dialogue: 0,0:19:12.68,0:19:15.05,Default,,0,0,0,,来描述一些复合对象一样
Dialogue: 0,0:19:16.33,0:19:17.79,Default,,0,0,0,,我想可能是这样
Dialogue: 0,0:19:18.55,0:19:20.20,Default,,0,0,0,,但是具体怎么判断并不重要
Dialogue: 0,0:19:20.68,0:19:22.01,Default,,0,0,0,,事实上
Dialogue: 0,0:19:22.19,0:19:23.85,Default,,0,0,0,,你可能已经知道或者推断过
Dialogue: 0,0:19:23.87,0:19:25.47,Default,,0,0,0,,我们并不需要任何基本过程
Dialogue: 0,0:19:27.35,0:19:29.28,Default,,0,0,0,,就算没有它们 照样可以进行计算
Dialogue: 0,0:19:30.46,0:19:33.19,Default,,0,0,0,,因为我们可以用一直在用的LAMBDA
Dialogue: 0,0:19:33.61,0:19:34.76,Default,,0,0,0,,但是有它们总归方便点儿
Dialogue: 0,0:19:34.81,0:19:36.27,Default,,0,0,0,,我在这儿略施魔法
Dialogue: 0,0:19:36.30,0:19:37.47,Default,,0,0,0,,但不会去解释
Dialogue: 0,0:19:38.06,0:19:41.44,Default,,0,0,0,,转到机器语言 执行APPLY-PRIMOP
Dialogue: 0,0:19:42.91,0:19:43.80,Default,,0,0,0,,加法是在这里运算的
Dialogue: 0,0:19:44.78,0:19:46.10,Default,,0,0,0,,执行加法指令
Dialogue: 0,0:19:50.62,0:19:52.11,Default,,0,0,0,,然而一门语言有趣的部分
Dialogue: 0,0:19:52.14,0:19:54.27,Default,,0,0,0,,在于组合基本元素的粘合剂
Dialogue: 0,0:19:54.91,0:19:55.90,Default,,0,0,0,,我们接着往下看
Dialogue: 0,0:19:56.91,0:19:58.38,Default,,0,0,0,,另一种可能就是
Dialogue: 0,0:19:58.75,0:20:04.12,Default,,0,0,0,,这个复合对象是求值LAMBDA表达式得到的
Dialogue: 0,0:20:04.97,0:20:07.05,Default,,0,0,0,,这是个复合过程
Dialogue: 0,0:20:07.62,0:20:09.36,Default,,0,0,0,,检测它的类型标志
Dialogue: 0,0:20:10.11,0:20:17.07,Default,,0,0,0,,如果是'CLOSURE
Dialogue: 0,0:20:20.51,0:20:24.09,Default,,0,0,0,,如果是的话 我就得求值这个过程的体
Dialogue: 0,0:20:24.19,0:20:27.39,Default,,0,0,0,,过程的体的求值方式则是
Dialogue: 0,0:20:28.08,0:20:31.69,Default,,0,0,0,,我求值过程的应用是通过
Dialogue: 0,0:20:31.72,0:20:33.71,Default,,0,0,0,,先扩充程序的求值环境
Dialogue: 0,0:20:34.19,0:20:37.80,Default,,0,0,0,,在这个环境中 把过程的形式参数
Dialogue: 0,0:20:37.92,0:20:40.48,Default,,0,0,0,,跟传递过来的实际参数绑定在一起
Dialogue: 0,0:20:41.02,0:20:43.68,Default,,0,0,0,,在这个环境中求值过程的体
Dialogue: 0,0:20:46.70,0:20:47.87,Default,,0,0,0,,这句话很长
Dialogue: 0,0:20:51.13,0:20:52.16,Default,,0,0,0,,但其实简单
Dialogue: 0,0:20:52.82,0:20:54.48,Default,,0,0,0,,一会儿可能会出现许多CAR CDR...
Dialogue: 0,0:20:56.46,0:20:58.11,Default,,0,0,0,,现在我先要得到过程体
Dialogue: 0,0:20:59.40,0:21:02.30,Default,,0,0,0,,如何取出过程体呢？
Dialogue: 0,0:21:02.96,0:21:04.08,Default,,0,0,0,,这里是CAR部分
Dialogue: 0,0:21:04.49,0:21:06.13,Default,,0,0,0,,这一块是剩下部分的CDR部分
Dialogue: 0,0:21:06.13,0:21:06.96,Default,,0,0,0,,因此这就是CADR
Dialogue: 0,0:21:07.40,0:21:09.45,Default,,0,0,0,,所以这里我得到的过程体
Dialogue: 0,0:21:09.45,0:21:13.04,Default,,0,0,0,,是过程对象第二个元素的第二个元素
Dialogue: 0,0:21:13.20,0:21:15.15,Default,,0,0,0,,因此CADR的CADR 也就是CADADR
Dialogue: 0,0:21:19.17,0:21:27.68,Default,,0,0,0,,这里取过程对象的CADADR部分
Dialogue: 0,0:21:30.26,0:21:31.56,Default,,0,0,0,,为了求值过程体
Dialogue: 0,0:21:31.98,0:21:36.48,Default,,0,0,0,,要在参数绑定后的新环境之中进行
Dialogue: 0,0:21:38.09,0:21:42.06,Default,,0,0,0,,我还得获取过程的形式参数
Dialogue: 0,0:21:42.06,0:21:42.72,Default,,0,0,0,,要怎么取呢？
Dialogue: 0,0:21:43.50,0:21:45.13,Default,,0,0,0,,就是CADR部分的CAR部分
Dialogue: 0,0:21:46.52,0:21:48.78,Default,,0,0,0,,这很糟糕不是吗？
Dialogue: 0,0:21:52.65,0:21:53.63,Default,,0,0,0,,过程的CADR部分
Dialogue: 0,0:21:55.44,0:22:00.86,Default,,0,0,0,,在随着过程一起传递过来的环境中
Dialogue: 0,0:22:00.89,0:22:04.14,Default,,0,0,0,,把形参和由环境传递过来的实参绑定起来
Dialogue: 0,0:22:04.54,0:22:07.90,Default,,0,0,0,,也就是CDR的CDR的CAR
Dialogue: 0,0:22:09.79,0:22:16.62,Default,,0,0,0,,也就是过程的CADDR部分
Dialogue: 0,0:22:20.29,0:22:24.96,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,0:22:26.14,0:22:29.68,Default,,0,0,0,,当然 如果我非常追求整洁
Dialogue: 0,0:22:29.87,0:22:31.34,Default,,0,0,0,,并且又非常谨慎
Dialogue: 0,0:22:32.24,0:22:34.12,Default,,0,0,0,,我会在后面多加一个情况
Dialogue: 0,0:22:34.38,0:22:35.98,Default,,0,0,0,,来判断是否出错
Dialogue: 0,0:22:36.17,0:22:38.41,Default,,0,0,0,,比如应用在参数上的是一个过程吗？
Dialogue: 0,0:22:39.00,0:22:41.69,Default,,0,0,0,,如果不是 这里就是未定义的过程类型
Dialogue: 0,0:22:42.57,0:22:44.09,Default,,0,0,0,,我在这里也会这么做
Dialogue: 0,0:22:45.80,0:22:55.96,Default,,0,0,0,,像这样 在ELSE子句中返回错误
Dialogue: 0,0:22:57.61,0:23:01.61,Default,,0,0,0,,当然 在现实中的一些系统中
Dialogue: 0,0:23:02.56,0:23:04.22,Default,,0,0,0,,出于专业设计的考虑
Dialogue: 0,0:23:05.32,0:23:08.00,Default,,0,0,0,,这里可能会根据某种分派
Dialogue: 0,0:23:08.36,0:23:09.90,Default,,0,0,0,,来进行“分情况处理”
Dialogue: 0,0:23:10.75,0:23:12.68,Default,,0,0,0,,回到这里 我可能还会添加新的条件来检查
Dialogue: 0,0:23:12.70,0:23:14.14,Default,,0,0,0,,比如 这是编译过的代码吗？
Dialogue: 0,0:23:16.22,0:23:16.84,Default,,0,0,0,,这很重要
Dialogue: 0,0:23:16.88,0:23:18.35,Default,,0,0,0,,这样的话我就可以区分
Dialogue: 0,0:23:18.38,0:23:22.33,Default,,0,0,0,,过程是直接由解释LAMBDA表达式而来
Dialogue: 0,0:23:22.94,0:23:25.87,Default,,0,0,0,,还是从另外的编译器中得到的 等等
Dialogue: 0,0:23:26.11,0:23:27.23,Default,,0,0,0,,之后再讨论这个话题
Dialogue: 0,0:23:27.23,0:23:29.61,Default,,0,0,0,,又或许是 我必须要执行的一段Frotran代码
Dialogue: 0,0:23:30.51,0:23:32.51,Default,,0,0,0,,这完全是可能的
Dialogue: 0,0:23:32.92,0:23:36.41,Default,,0,0,0,,实际上 我用具体语法写的这个求值器
Dialogue: 0,0:23:37.45,0:23:40.86,Default,,0,0,0,,假定了它是用Lisp来编写的
Dialogue: 0,0:23:42.30,0:23:43.82,Default,,0,0,0,,这是因为我用了CAR和CDR
Dialogue: 0,0:23:43.84,0:23:45.10,Default,,0,0,0,,用CAR来取运算符
Dialogue: 0,0:23:45.28,0:23:46.64,Default,,0,0,0,,用CDR来取运算对象
Dialogue: 0,0:23:46.75,0:23:49.96,Default,,0,0,0,,教科书上给出了一个用抽象语法编写的求值器
Dialogue: 0,0:23:50.35,0:23:53.15,Default,,0,0,0,,它使用的都是抽象的名字
Dialogue: 0,0:23:53.16,0:23:54.09,Default,,0,0,0,,比如OPERATOR、OPERAND
Dialogue: 0,0:23:54.14,0:23:55.82,Default,,0,0,0,,以及类似的名字
Dialogue: 0,0:23:56.16,0:23:56.86,Default,,0,0,0,,那样的话
Dialogue: 0,0:23:57.02,0:24:00.91,Default,,0,0,0,,你可以毫无问题地用ALGOL来重新实现
Dialogue: 0,0:24:03.36,0:24:06.40,Default,,0,0,0,,写完APPLY之后
Dialogue: 0,0:24:07.20,0:24:08.43,Default,,0,0,0,,又有一些东西没有定义
Dialogue: 0,0:24:10.81,0:24:12.57,Default,,0,0,0,,我先不操心这两个
Dialogue: 0,0:24:13.39,0:24:15.05,Default,,0,0,0,,我们稍后讨论这个很重要的BIND
Dialogue: 0,0:24:17.18,0:24:19.76,Default,,0,0,0,,现在我们来快速过一遍 结束这一部分
Dialogue: 0,0:24:20.55,0:24:22.65,Default,,0,0,0,,只剩下两块黑板了 不能够写太长
Dialogue: 0,0:24:27.40,0:24:29.08,Default,,0,0,0,,我还得悉心裁剪才能刚好写下
Dialogue: 0,0:24:30.07,0:24:30.98,Default,,0,0,0,,嗯 还剩下点什么？
Dialogue: 0,0:24:30.98,0:24:33.20,Default,,0,0,0,,我们得定义这里的EVLIST
Dialogue: 0,0:24:33.73,0:24:35.07,Default,,0,0,0,,EVLIST只不过是
Dialogue: 0,0:24:35.26,0:24:43.08,Default,,0,0,0,,在运算对象上映射某个函数得到参数
Dialogue: 0,0:24:44.30,0:24:45.40,Default,,0,0,0,,但是我还是要写出来看看
Dialogue: 0,0:24:45.82,0:24:48.30,Default,,0,0,0,,我把它写出来的原因有点神秘
Dialogue: 0,0:24:49.88,0:24:52.04,Default,,0,0,0,,我想让这个求值器简单得
Dialogue: 0,0:24:52.06,0:24:53.56,Default,,0,0,0,,可以求值自身
Dialogue: 0,0:24:56.45,0:24:58.09,Default,,0,0,0,,我真的很在意这一点
Dialogue: 0,0:25:00.23,0:25:01.74,Default,,0,0,0,,现在我就把它完全写在这里
Dialogue: 0,0:25:02.85,0:25:04.24,Default,,0,0,0,,我并不关心
Dialogue: 0,0:25:04.27,0:25:06.08,Default,,0,0,0,,它能否把过程作为参数传递
Dialogue: 0,0:25:06.27,0:25:08.06,Default,,0,0,0,,求值器并不会用到这些参数
Dialogue: 0,0:25:08.98,0:25:10.78,Default,,0,0,0,,求值器也不会生成一个是过程的值
Dialogue: 0,0:25:10.88,0:25:12.67,Default,,0,0,0,,因此 如果另外有个不同的语言
Dialogue: 0,0:25:12.80,0:25:13.96,Default,,0,0,0,,跟这个又非常相似
Dialogue: 0,0:25:15.16,0:25:17.79,Default,,0,0,0,,这个求值器能够求值像Scheme这样的复杂语言
Dialogue: 0,0:25:17.80,0:25:23.12,Default,,0,0,0,,Scheme是能够把过程当做参数传递的
Dialogue: 0,0:25:24.07,0:25:25.95,Default,,0,0,0,,但当我在求值ALGOL时
Dialogue: 0,0:25:27.34,0:25:28.96,Default,,0,0,0,,尽管ALGOL并不支持过程值
Dialogue: 0,0:25:29.47,0:25:30.59,Default,,0,0,0,,这个求值器也能正常工作
Dialogue: 0,0:25:31.58,0:25:33.92,Default,,0,0,0,,因为这个解释器 并没有对这个做过什么假定
Dialogue: 0,0:25:34.27,0:25:36.03,Default,,0,0,0,,实际上 就算这个求值器
Dialogue: 0,0:25:36.27,0:25:37.50,Default,,0,0,0,,被限制不允许那么做 也没有什么关系
Dialogue: 0,0:25:37.52,0:25:40.03,Default,,0,0,0,,因为它没有使用那些高级功能
Dialogue: 0,0:25:40.64,0:25:42.41,Default,,0,0,0,,这就是我为什么要把它设计得非常简单
Dialogue: 0,0:25:44.07,0:25:46.46,Default,,0,0,0,,这几乎是所有可能的语言求值器的核心
Dialogue: 0,0:25:47.81,0:25:48.48,Default,,0,0,0,,回到这个定义上来
Dialogue: 0,0:25:49.42,0:25:53.56,Default,,0,0,0,,EVLIST -- 它是什么呢？
Dialogue: 0,0:25:53.82,0:25:57.04,Default,,0,0,0,,这个过程接收两个参数 L和ENV
Dialogue: 0,0:25:58.09,0:25:59.08,Default,,0,0,0,,其中L是个表
Dialogue: 0,0:25:59.58,0:26:08.27,Default,,0,0,0,,这样的话 如果参数表是空表
Dialogue: 0,0:26:10.19,0:26:12.68,Default,,0,0,0,,那么结果就是空表
Dialogue: 0,0:26:14.03,0:26:19.23,Default,,0,0,0,,否则的话 我就要组合
Dialogue: 0,0:26:20.75,0:26:26.67,Default,,0,0,0,,在ENV中求值运算对象表的CAR部分
Dialogue: 0,0:26:28.16,0:26:32.51,Default,,0,0,0,,在ENV中求值运算对象CAR部分的结果
Dialogue: 0,0:26:33.34,0:26:35.71,Default,,0,0,0,,我想先求值第一个运算对象
Dialogue: 0,0:26:35.98,0:26:38.40,Default,,0,0,0,,返回的结果将是一个新表
Dialogue: 0,0:26:38.97,0:26:40.76,Default,,0,0,0,,是通过把这个和
Dialogue: 0,0:26:41.08,0:26:45.42,Default,,0,0,0,,用CDR递归EVLIST的结果组合得到的
Dialogue: 0,0:26:46.22,0:26:50.13,Default,,0,0,0,,在同样的ENV下 L的CDR部分
Dialogue: 0,0:26:53.08,0:26:58.24,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,0:26:59.66,0:27:01.84,Default,,0,0,0,,还有一个过程
Dialogue: 0,0:27:01.84,0:27:03.36,Default,,0,0,0,,我也想写在这里
Dialogue: 0,0:27:03.62,0:27:05.21,Default,,0,0,0,,它是这整个的关键
Dialogue: 0,0:27:05.64,0:27:08.13,Default,,0,0,0,,还要深入一个层次
Dialogue: 0,0:27:14.54,0:27:15.44,Default,,0,0,0,,也就是COND语句
Dialogue: 0,0:27:15.69,0:27:16.99,Default,,0,0,0,,在剩下的东西中
Dialogue: 0,0:27:17.02,0:27:18.17,Default,,0,0,0,,EVCOND是唯一的重要过程
Dialogue: 0,0:27:18.88,0:27:20.75,Default,,0,0,0,,解决完这个后
Dialogue: 0,0:27:21.07,0:27:22.94,Default,,0,0,0,,我们再讨论LOOKUP和BIND
Dialogue: 0,0:27:23.56,0:27:25.36,Default,,0,0,0,,稍后再来讨论
Dialogue: 0,0:27:25.53,0:27:27.93,Default,,0,0,0,,在这个层次上 这是非常重要的
Dialogue: 0,0:27:28.65,0:27:30.62,Default,,0,0,0,,下一个重要的事就是如何处理COND语句
Dialogue: 0,0:27:31.60,0:27:33.33,Default,,0,0,0,,那么 我们怎么来处理呢？
Dialogue: 0,0:27:36.97,0:27:38.56,Default,,0,0,0,,它是一个过程
Dialogue: 0,0:27:39.48,0:27:45.00,Default,,0,0,0,,参数是一组子句CLAUSES和环境ENV
Dialogue: 0,0:27:47.71,0:27:48.51,Default,,0,0,0,,它做些什么呢？
Dialogue: 0,0:27:49.82,0:27:55.47,Default,,0,0,0,,如果子句为空
Dialogue: 0,0:28:02.60,0:28:03.96,Default,,0,0,0,,我得有一个返回值
Dialogue: 0,0:28:04.70,0:28:05.87,Default,,0,0,0,,可能是一个错误
Dialogue: 0,0:28:06.54,0:28:08.59,Default,,0,0,0,,如果遍历完了所有条件 都没有符合的
Dialogue: 0,0:28:09.15,0:28:10.06,Default,,0,0,0,,那么它可能有任意的行为
Dialogue: 0,0:28:10.06,0:28:12.88,Default,,0,0,0,,这完全取决于程序员要怎么处理
Dialogue: 0,0:28:13.65,0:28:15.45,Default,,0,0,0,,现在对我来说最方便的是
Dialogue: 0,0:28:15.63,0:28:17.53,Default,,0,0,0,,让它返回一个空表
Dialogue: 0,0:28:18.14,0:28:18.83,Default,,0,0,0,,这无所谓
Dialogue: 0,0:28:20.10,0:28:20.88,Default,,0,0,0,,为了检查出错误
Dialogue: 0,0:28:20.89,0:28:22.76,Default,,0,0,0,,有些人喜欢在这里写点别的
Dialogue: 0,0:28:23.11,0:28:24.81,Default,,0,0,0,,下面的更有意思
Dialogue: 0,0:28:25.39,0:28:27.24,Default,,0,0,0,,如果我遇到了ELSE子句
Dialogue: 0,0:28:31.00,0:28:32.73,Default,,0,0,0,,请看 我们有一个由子句组成的表
Dialogue: 0,0:28:33.21,0:28:34.41,Default,,0,0,0,,其中每个子句也是一个表
Dialogue: 0,0:28:35.44,0:28:40.52,Default,,0,0,0,,因此谓词就应该是CLAUSES的CAAR部分
Dialogue: 0,0:28:43.56,0:28:45.02,Default,,0,0,0,,它是
Dialogue: 0,0:28:45.04,0:28:49.00,Default,,0,0,0,,CLAUSES表中第一个元素的CAR部分
Dialogue: 0,0:28:51.09,0:28:51.84,Default,,0,0,0,,如果它是'ELSE的话
Dialogue: 0,0:28:54.32,0:28:56.51,Default,,0,0,0,,就意味着整个COND表达式的结果
Dialogue: 0,0:28:56.64,0:28:59.15,Default,,0,0,0,,就是求值匹配表达式的结果
Dialogue: 0,0:29:00.12,0:29:04.32,Default,,0,0,0,,所以我求值CADAR部分
Dialogue: 0,0:29:07.00,0:29:09.56,Default,,0,0,0,,这是第一个子句的
Dialogue: 0,0:29:10.12,0:29:11.63,Default,,0,0,0,,第二个元素 也就是CADAR
Dialogue: 0,0:29:12.81,0:29:17.08,Default,,0,0,0,,也就是CLAUSES的CAR部分的CADR部分
Dialogue: 0,0:29:21.23,0:29:22.57,Default,,0,0,0,,求值的环境是ENV
Dialogue: 0,0:29:26.62,0:29:28.60,Default,,0,0,0,,下一种可能性更有意思
Dialogue: 0,0:29:29.63,0:29:30.44,Default,,0,0,0,,如果它返回FALSE的话
Dialogue: 0,0:29:33.05,0:29:35.10,Default,,0,0,0,,如果谓词表中的第一个谓词
Dialogue: 0,0:29:35.74,0:29:37.68,Default,,0,0,0,,既不是ELSE子句 又不为FALSE
Dialogue: 0,0:29:38.32,0:29:39.50,Default,,0,0,0,,也就是它不是保留字ELSE
Dialogue: 0,0:29:40.16,0:29:42.00,Default,,0,0,0,,并且也不是一个值为FALSE的东西
Dialogue: 0,0:29:42.03,0:29:43.66,Default,,0,0,0,,如果为FALSE又要怎么处理呢？
Dialogue: 0,0:29:44.36,0:29:50.08,Default,,0,0,0,,如果在相应的环境中
Dialogue: 0,0:29:52.33,0:29:56.76,Default,,0,0,0,,求值子句中第一个谓词的结果
Dialogue: 0,0:29:58.19,0:30:01.00,Default,,0,0,0,,如果求值的结果是FALSE的话
Dialogue: 0,0:30:01.69,0:30:03.82,Default,,0,0,0,,这就意味着 还得接着判断后面的子句
Dialogue: 0,0:30:04.36,0:30:05.74,Default,,0,0,0,,第一个就扔掉不管了
Dialogue: 0,0:30:06.25,0:30:08.33,Default,,0,0,0,,所以就进入下一个EVCOND循环
Dialogue: 0,0:30:09.95,0:30:16.49,Default,,0,0,0,,在对应的环境中继续判断子句的CDR部分
Dialogue: 0,0:30:19.95,0:30:25.15,Default,,0,0,0,,又或者 我遇到了求值为TRUE的子句
Dialogue: 0,0:30:26.84,0:30:28.96,Default,,0,0,0,,这样的话 我想在对应的环境中
Dialogue: 0,0:30:31.85,0:30:41.45,Default,,0,0,0,,求值CLAUSES的CADAR部分
Dialogue: 0,0:30:48.20,0:30:49.61,Default,,0,0,0,,快了 快完成了
Dialogue: 0,0:30:51.21,0:30:52.80,Default,,0,0,0,,基本上完整了
Dialogue: 0,0:30:53.73,0:30:55.87,Default,,0,0,0,,把这一部分结束
Dialogue: 0,0:30:56.21,0:30:58.57,Default,,0,0,0,,再回顾一下这个求值器
Dialogue: 0,0:30:58.81,0:31:00.70,Default,,0,0,0,,它基本上就是这样了
Dialogue: 0,0:31:01.08,0:31:04.04,Default,,0,0,0,,接着来看一张幻灯片
Dialogue: 0,0:31:06.32,0:31:10.43,Default,,0,0,0,,这是BIND的定义
Dialogue: 0,0:31:11.98,0:31:14.54,Default,,0,0,0,,BIND用于在环境中添加新的绑定
Dialogue: 0,0:31:15.46,0:31:18.67,Default,,0,0,0,,我们要在这里
Dialogue: 0,0:31:19.24,0:31:22.80,Default,,0,0,0,,为环境结构创建一个新框架
Dialogue: 0,0:31:22.80,0:31:25.42,Default,,0,0,0,,环境结构是通过由框架组成的表
Dialogue: 0,0:31:25.93,0:31:27.20,Default,,0,0,0,,来表示的
Dialogue: 0,0:31:28.08,0:31:30.19,Default,,0,0,0,,给定一个已有的环境
Dialogue: 0,0:31:30.32,0:31:32.11,Default,,0,0,0,,我可以通过把一个新建的框架
Dialogue: 0,0:31:32.25,0:31:33.82,Default,,0,0,0,,CONS在已有的环境上
Dialogue: 0,0:31:33.93,0:31:35.69,Default,,0,0,0,,来获得新的环境
Dialogue: 0,0:31:36.62,0:31:40.36,Default,,0,0,0,,正在应用的过程中 那些被绑定变量
Dialogue: 0,0:31:41.05,0:31:43.79,Default,,0,0,0,,与传递给过程的参数值结合在一起
Dialogue: 0,0:31:44.12,0:31:48.25,Default,,0,0,0,,组成了我们所创建的新框架
Dialogue: 0,0:31:49.69,0:31:50.65,Default,,0,0,0,,BIND其实就是创建表
Dialogue: 0,0:31:51.64,0:31:54.06,Default,,0,0,0,,环境就是一组由框架组成的表
Dialogue: 0,0:31:54.30,0:31:55.60,Default,,0,0,0,,把新的元素加入其中
Dialogue: 0,0:31:55.74,0:31:56.89,Default,,0,0,0,,也就形成了新的环境
Dialogue: 0,0:31:58.65,0:32:00.65,Default,,0,0,0,,而PAIR-UP的定义非常简单
Dialogue: 0,0:32:01.54,0:32:02.84,Default,,0,0,0,,PAIR-UP只不过是
Dialogue: 0,0:32:03.13,0:32:05.56,Default,,0,0,0,,如果我们有一个变量表和一个值表
Dialogue: 0,0:32:05.93,0:32:08.62,Default,,0,0,0,,那么 如果它俩的元素个数又相同
Dialogue: 0,0:32:08.62,0:32:09.58,Default,,0,0,0,,就可以让它们一一对应
Dialogue: 0,0:32:09.72,0:32:11.48,Default,,0,0,0,,否则的话 就是参数传递多了
Dialogue: 0,0:32:12.51,0:32:15.98,Default,,0,0,0,,如果值的个数比变量的个数多
Dialogue: 0,0:32:16.06,0:32:17.37,Default,,0,0,0,,那就说明参数传递少了
Dialogue: 0,0:32:18.51,0:32:19.63,Default,,0,0,0,,通常的情况是
Dialogue: 0,0:32:19.63,0:32:21.48,Default,,0,0,0,,如果没有出错 又没有完成的话
Dialogue: 0,0:32:22.06,0:32:25.61,Default,,0,0,0,,我就添加一个由第一个变量
Dialogue: 0,0:32:25.76,0:32:30.17,Default,,0,0,0,,和第一个参数组成的新序对
Dialogue: 0,0:32:30.94,0:32:32.12,Default,,0,0,0,,这是第一个值
Dialogue: 0,0:32:32.76,0:32:36.40,Default,,0,0,0,,把它们CONS在
Dialogue: 0,0:32:37.12,0:32:40.64,Default,,0,0,0,,剩余变量和值组成的表上
Dialogue: 0,0:32:42.95,0:32:44.78,Default,,0,0,0,,LOOKUP也同样简单
Dialogue: 0,0:32:46.28,0:32:49.63,Default,,0,0,0,,加入我要在环境中查找一个符号
Dialogue: 0,0:32:49.93,0:32:51.39,Default,,0,0,0,,那么 如果是空环境
Dialogue: 0,0:32:51.56,0:32:53.00,Default,,0,0,0,,那么就说明 该变量尚未绑定
Dialogue: 0,0:32:54.65,0:32:55.47,Default,,0,0,0,,否则
Dialogue: 0,0:32:56.86,0:33:00.36,Default,,0,0,0,,我就要使用一个特殊的关联表查找过程
Dialogue: 0,0:33:00.38,0:33:01.87,Default,,0,0,0,,我们不久就会看到它的定义
Dialogue: 0,0:33:02.24,0:33:05.44,Default,,0,0,0,,用它在环境的第一个框架中查找该符号
Dialogue: 0,0:33:05.93,0:33:07.21,Default,,0,0,0,,由于我知道这个环境不是空的
Dialogue: 0,0:33:07.23,0:33:08.40,Default,,0,0,0,,因此 它至少有一个框架
Dialogue: 0,0:33:09.20,0:33:11.14,Default,,0,0,0,,所以 我就在它第一个框架中查找
Dialogue: 0,0:33:11.56,0:33:13.58,Default,,0,0,0,,找到的序对会传递给这里的VCELL
Dialogue: 0,0:33:14.38,0:33:17.61,Default,,0,0,0,,如果VCELL为空
Dialogue: 0,0:33:18.44,0:33:20.57,Default,,0,0,0,,那就说明当前框架中没有这个符号
Dialogue: 0,0:33:20.70,0:33:22.84,Default,,0,0,0,,我就需要在环境中剩下的框架中查找
Dialogue: 0,0:33:23.72,0:33:25.04,Default,,0,0,0,,VCELL为空 意味着当前框架没有相应的符号
Dialogue: 0,0:33:25.99,0:33:28.89,Default,,0,0,0,,如果没有找到
Dialogue: 0,0:33:29.52,0:33:30.80,Default,,0,0,0,,ASSQ就会返回空表
Dialogue: 0,0:33:32.32,0:33:33.85,Default,,0,0,0,,如果找到了
Dialogue: 0,0:33:33.85,0:33:36.06,Default,,0,0,0,,那么我就使用VCELL的CDR部分
Dialogue: 0,0:33:36.46,0:33:40.25,Default,,0,0,0,,因为VCELL是变量和值组成的序对
Dialogue: 0,0:33:41.05,0:33:43.93,Default,,0,0,0,,因此可以用CDR取得对应的值
Dialogue: 0,0:33:45.00,0:33:47.82,Default,,0,0,0,,ASSQ这个过程你们之前见过
Dialogue: 0,0:33:47.97,0:33:50.83,Default,,0,0,0,,ASSQ的参数是一个符号和一个由序对组成的表
Dialogue: 0,0:33:51.42,0:33:53.40,Default,,0,0,0,,如果表为空 它就返回空表
Dialogue: 0,0:33:53.52,0:33:56.30,Default,,0,0,0,,如果这个符号是ALIST的第一个元素
Dialogue: 0,0:33:58.06,0:33:58.91,Default,,0,0,0,,这里写错了
Dialogue: 0,0:33:59.82,0:34:02.17,Default,,0,0,0,,应该是CAAR
Dialogue: 0,0:34:03.16,0:34:04.16,Default,,0,0,0,,大家注意一下
Dialogue: 0,0:34:07.63,0:34:09.37,Default,,0,0,0,,就是这里 看到了吗？
Dialogue: 0,0:34:13.42,0:34:14.41,Default,,0,0,0,,总之
Dialogue: 0,0:34:14.56,0:34:16.81,Default,,0,0,0,,如果符号等于表的CAAR
Dialogue: 0,0:34:17.16,0:34:20.97,Default,,0,0,0,,那么我就返回ALIST中第一个序对
Dialogue: 0,0:34:22.08,0:34:25.50,Default,,0,0,0,,换句话说 这个键匹配了正确的条目
Dialogue: 0,0:34:26.24,0:34:26.97,Default,,0,0,0,,否则的话
Dialogue: 0,0:34:27.08,0:34:28.94,Default,,0,0,0,,我就需要在剩下的表中继续查找
Dialogue: 0,0:34:30.08,0:34:33.31,Default,,0,0,0,,这里有个笔误 很抱歉
Dialogue: 0,0:34:35.19,0:34:36.28,Default,,0,0,0,,好了 不管如何
Dialogue: 0,0:34:37.05,0:34:39.48,Default,,0,0,0,,你们基本上已经看到了全貌
Dialogue: 0,0:34:41.88,0:34:43.29,Default,,0,0,0,,虽然我们的代码风格非常丑陋
Dialogue: 0,0:34:44.19,0:34:46.00,Default,,0,0,0,,但是作为所有语言的核心
Dialogue: 0,0:34:46.76,0:34:48.30,Default,,0,0,0,,它却是非常美妙
Dialogue: 0,0:34:49.60,0:34:51.37,Default,,0,0,0,,我提议 让我们再欣赏一会儿
Dialogue: 0,0:35:00.32,0:35:47.02,Default,,0,0,0,,[音乐]
Dialogue: 0,0:35:49.75,0:35:50.91,Default,,0,0,0,,大家有什么问题吗？
Dialogue: 0,0:36:01.18,0:36:03.29,Default,,0,0,0,,没有的话就休息一会儿吧
Dialogue: 0,0:36:04.04,0:36:10.73,Default,,0,0,0,,[音乐]
Dialogue: 0,0:36:13.88,0:36:17.64,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:36:40.80,0:36:43.93,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:36:43.95,0:36:47.98,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:36:48.06,0:36:51.93,Declare,,0,0,0,,{\an2\fad(500,500)}元循环求值器 I
Dialogue: 0,0:36:56.78,0:36:58.99,Default,,0,0,0,,现在 我们将用一个实例
Dialogue: 0,0:36:59.29,0:37:02.67,Default,,0,0,0,,来理解一下求值器的运作过程
Dialogue: 0,0:37:03.47,0:37:05.48,Default,,0,0,0,,我们通过手工进行代换
Dialogue: 0,0:37:05.50,0:37:10.36,Default,,0,0,0,,来深入解释器的详细工作原理
Dialogue: 0,0:37:11.50,0:37:14.94,Default,,0,0,0,,由于我们的求值器不支持赋值和定义
Dialogue: 0,0:37:15.20,0:37:17.34,Default,,0,0,0,,我们也就不用担心副作用
Dialogue: 0,0:37:17.98,0:37:22.03,Default,,0,0,0,,因此我们可以放心大胆地进行代换
Dialogue: 0,0:37:22.52,0:37:24.59,Default,,0,0,0,,不用担心任何副作用
Dialogue: 0,0:37:25.33,0:37:27.80,Default,,0,0,0,,我们将要尝试去手工代换
Dialogue: 0,0:37:28.06,0:37:29.63,Default,,0,0,0,,这个复杂的表达式
Dialogue: 0,0:37:30.69,0:37:34.09,Default,,0,0,0,,(EVAL
Dialogue: 0,0:37:34.91,0:37:48.08,Default,,0,0,0,,'(((LAMBDA (X) (LAMBDA (Y) (+ X Y)))
Dialogue: 0,0:37:50.30,0:37:52.62,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,0:37:53.04,0:37:56.12,Default,,0,0,0,,要把它应用在3和4上
Dialogue: 0,0:37:56.94,0:37:59.58,Default,,0,0,0,,求值过程是发生在全局环境E0中的
Dialogue: 0,0:38:04.93,0:38:05.96,Default,,0,0,0,,这里的这个表达式
Dialogue: 0,0:38:06.36,0:38:08.04,Default,,0,0,0,,是个参数为X的一元过程
Dialogue: 0,0:38:08.09,0:38:11.05,Default,,0,0,0,,返回一个参数为Y的一元过程
Dialogue: 0,0:38:11.07,0:38:12.12,Default,,0,0,0,,后者计算X+Y
Dialogue: 0,0:38:14.30,0:38:17.96,Default,,0,0,0,,外层的这个过程应用于数字3
Dialogue: 0,0:38:17.96,0:38:19.39,Default,,0,0,0,,所以X应该是3
Dialogue: 0,0:38:21.40,0:38:23.98,Default,,0,0,0,,返回的结果是一个参数为Y的一元过程
Dialogue: 0,0:38:24.33,0:38:25.82,Default,,0,0,0,,该过程将应用于数字4
Dialogue: 0,0:38:28.91,0:38:30.32,Default,,0,0,0,,然后要做的也很简单
Dialogue: 0,0:38:31.04,0:38:32.73,Default,,0,0,0,,计算X+Y即可
Dialogue: 0,0:38:34.79,0:38:35.82,Default,,0,0,0,,具体做之前
Dialogue: 0,0:38:35.84,0:38:37.76,Default,,0,0,0,,先来构造一个非常简单的环境模型
Dialogue: 0,0:38:37.90,0:38:40.48,Default,,0,0,0,,到了现在 我相信你们已经想到
Dialogue: 0,0:38:40.99,0:38:42.59,Default,,0,0,0,,这个过程产生的环境了
Dialogue: 0,0:38:44.46,0:38:46.62,Default,,0,0,0,,我们从全局环境开始
Dialogue: 0,0:38:48.59,0:38:50.06,Default,,0,0,0,,我们把它记作E0
Dialogue: 0,0:38:54.60,0:38:55.47,Default,,0,0,0,,就像这样
Dialogue: 0,0:38:56.74,0:39:02.46,Default,,0,0,0,,里面应该有过程+、*的定义
Dialogue: 0,0:39:06.30,0:39:10.36,Default,,0,0,0,,这里 我们用希腊字母来表示过程对象 这样有趣点
Dialogue: 0,0:39:11.21,0:39:27.93,Default,,0,0,0,,-、/、CAR、CDR、CONS以及EQ?
Dialogue: 0,0:39:28.59,0:39:31.05,Default,,0,0,0,,其它需要的基本过程都在全局环境中
Dialogue: 0,0:39:31.27,0:39:33.82,Default,,0,0,0,,每个符号都对应着一个过程对象
Dialogue: 0,0:39:34.62,0:39:36.09,Default,,0,0,0,,这些都是解释器自带的
Dialogue: 0,0:39:37.10,0:39:38.09,Default,,0,0,0,,这就是E0
Dialogue: 0,0:39:39.22,0:39:41.84,Default,,0,0,0,,现在 这个求值要怎样进行呢？
Dialogue: 0,0:39:42.94,0:39:45.18,Default,,0,0,0,,我们来看看这些特殊形式
Dialogue: 0,0:39:45.69,0:39:47.05,Default,,0,0,0,,首先 这不是数字
Dialogue: 0,0:39:48.67,0:39:50.38,Default,,0,0,0,,也不是符号
Dialogue: 0,0:39:53.13,0:39:55.60,Default,,0,0,0,,这不是一个引用表达式
Dialogue: 0,0:39:56.60,0:39:58.38,Default,,0,0,0,,虽然外层是一个引用表达式
Dialogue: 0,0:39:59.47,0:40:00.80,Default,,0,0,0,,但并不是我想要去求值的那个
Dialogue: 0,0:40:00.83,0:40:01.36,Default,,0,0,0,,我想问的是
Dialogue: 0,0:40:01.39,0:40:04.96,Default,,0,0,0,,被引用的这个表达式 是否也是个引用表达式？
Dialogue: 0,0:40:05.89,0:40:07.96,Default,,0,0,0,,我是在求值一个表达式
Dialogue: 0,0:40:07.96,0:40:09.98,Default,,0,0,0,,这个引号是为了引用这个特定表达式
Dialogue: 0,0:40:11.41,0:40:12.66,Default,,0,0,0,,而被引用的并非引用表达式
Dialogue: 0,0:40:13.71,0:40:17.21,Default,,0,0,0,,当然 它也不是以LAMBDA开头
Dialogue: 0,0:40:19.12,0:40:20.67,Default,,0,0,0,,也不以COND开头
Dialogue: 0,0:40:22.03,0:40:25.95,Default,,0,0,0,,因此它是过程的应用
Dialogue: 0,0:40:26.31,0:40:27.12,Default,,0,0,0,,这是一个组合式
Dialogue: 0,0:40:28.57,0:40:30.70,Default,,0,0,0,,既然它是组合式
Dialogue: 0,0:40:30.89,0:40:34.00,Default,,0,0,0,,这就是它的运算符
Dialogue: 0,0:40:34.64,0:40:36.08,Default,,0,0,0,,而这是它的运算对象
Dialogue: 0,0:40:40.13,0:40:42.41,Default,,0,0,0,,这就意味着 我要
Dialogue: 0,0:40:42.57,0:40:47.90,Default,,0,0,0,,把它转换成
Dialogue: 0,0:40:50.12,0:40:57.61,Default,,0,0,0,,(APPLY (EVAL '((LAMBDA (X) (LAMBDA (y)
Dialogue: 0,0:40:57.88,0:40:59.12,Default,,0,0,0,,也就是在E0环境中
Dialogue: 0,0:40:59.95,0:41:04.19,Default,,0,0,0,,求值(+ X Y)
Dialogue: 0,0:41:07.26,0:41:08.64,Default,,0,0,0,,不要漏了<E0>
Dialogue: 0,0:41:12.78,0:41:15.20,Default,,0,0,0,,要应用到的运算对象则是
Dialogue: 0,0:41:15.26,0:41:17.28,Default,,0,0,0,,用EVLIST求值参数的结果
Dialogue: 0,0:41:21.21,0:41:24.49,Default,,0,0,0,,也就是'(4)
Dialogue: 0,0:41:29.01,0:41:31.26,Default,,0,0,0,,我用这个特殊的记号来表示<E0>
Dialogue: 0,0:41:32.32,0:41:34.83,Default,,0,0,0,,这是为了指代那个环境
Dialogue: 0,0:41:35.45,0:41:37.77,Default,,0,0,0,,我无法为它命名
Dialogue: 0,0:41:37.80,0:41:39.15,Default,,0,0,0,,因为我没有环境来存放<E0>的名字
Dialogue: 0,0:41:41.96,0:41:44.09,Default,,0,0,0,,你当然可以把<E0>看作是
Dialogue: 0,0:41:44.17,0:41:46.17,Default,,0,0,0,,某种引用表达式
Dialogue: 0,0:41:47.73,0:41:51.16,Default,,0,0,0,,在那里 它表示环境这种数据结构
Dialogue: 0,0:41:53.04,0:41:55.04,Default,,0,0,0,,好的 这是变换后的结果
Dialogue: 0,0:41:55.85,0:41:56.67,Default,,0,0,0,,为了执行这个表达式
Dialogue: 0,0:41:56.68,0:41:58.04,Default,,0,0,0,,我还得求值这两个表达式
Dialogue: 0,0:41:59.61,0:42:00.49,Default,,0,0,0,,EVLIST简单点
Dialogue: 0,0:42:00.57,0:42:03.18,Default,,0,0,0,,我们先计算这个吧
Dialogue: 0,0:42:03.77,0:42:07.44,Default,,0,0,0,,这就被归约为
Dialogue: 0,0:42:07.45,0:42:08.83,Default,,0,0,0,,上面的某些部分直接抄过来就好
Dialogue: 0,0:42:09.42,0:42:11.00,Default,,0,0,0,,代换的过程中少不了照抄
Dialogue: 0,0:42:18.53,0:42:21.24,Default,,0,0,0,,抄写的时候我就不多加解释了
Dialogue: 0,0:42:21.71,0:42:23.87,Default,,0,0,0,,这样能快一点儿
Dialogue: 0,0:42:26.41,0:42:28.64,Default,,0,0,0,,EVLIST的部分就代换成为
Dialogue: 0,0:42:28.65,0:42:36.72,Default,,0,0,0,,(CONS (EVAL '4 <E0>)
Dialogue: 0,0:42:38.78,0:42:40.17,Default,,0,0,0,,因为它不是空表
Dialogue: 0,0:42:41.44,0:42:49.39,Default,,0,0,0,,(EVLIST '() <E0>))
Dialogue: 0,0:42:52.58,0:42:54.20,Default,,0,0,0,,我要省略一些步骤了
Dialogue: 0,0:42:54.24,0:42:55.36,Default,,0,0,0,,因为太详细就有些无聊了
Dialogue: 0,0:42:59.87,0:43:05.42,Default,,0,0,0,,下一步跟上面基本上一样
Dialogue: 0,0:43:07.50,0:43:08.54,Default,,0,0,0,,继续照抄
Dialogue: 0,0:43:10.68,0:43:20.24,Default,,0,0,0,,(((LAMBDA (X) (LAMBDA (Y) (+ X Y)) 3) 4) <E0>)
Dialogue: 0,0:43:20.24,0:43:21.20,Default,,0,0,0,,看来我还宝刀未老嘛
Dialogue: 0,0:43:24.24,0:43:26.24,Default,,0,0,0,,下面对4求值
Dialogue: 0,0:43:26.56,0:43:28.44,Default,,0,0,0,,4是一个数字
Dialogue: 0,0:43:29.00,0:43:33.90,Default,,0,0,0,,结果就应该是(CONS 4
Dialogue: 0,0:43:34.03,0:43:37.47,Default,,0,0,0,,EVLIST对空表求值 结果也是空表
Dialogue: 0,0:43:38.33,0:43:39.24,Default,,0,0,0,,也就是这个
Dialogue: 0,0:43:42.62,0:43:45.08,Default,,0,0,0,,这个非常容易理解
Dialogue: 0,0:43:45.10,0:43:47.44,Default,,0,0,0,,就是一个只含有4的表
Dialogue: 0,0:43:48.71,0:43:53.84,Default,,0,0,0,,继续代换为 (APPLY (EVAL
Dialogue: 0,0:43:55.28,0:44:02.51,Default,,0,0,0,,'((LAMBDA (X) (LAMBDA (Y) (+ X Y))
Dialogue: 0,0:44:03.40,0:44:07.48,Default,,0,0,0,,3) 4) <E0>)
Dialogue: 0,0:44:08.68,0:44:12.60,Default,,0,0,0,,应用在'(4)上 这样就完成了
Dialogue: 0,0:44:13.94,0:44:15.05,Default,,0,0,0,,这是这一步的结果
Dialogue: 0,0:44:17.00,0:44:19.96,Default,,0,0,0,,现在让我们进行下一步 更有意思的一步
Dialogue: 0,0:44:20.36,0:44:21.72,Default,,0,0,0,,这行代码要如何求值？
Dialogue: 0,0:44:23.07,0:44:24.44,Default,,0,0,0,,为了求值这一部分
Dialogue: 0,0:44:25.20,0:44:28.65,Default,,0,0,0,,我得先求值-- 首先 它不是--
Dialogue: 0,0:44:29.46,0:44:31.04,Default,,0,0,0,,这是一个应用
Dialogue: 0,0:44:31.68,0:44:33.10,Default,,0,0,0,,它并不是特殊形式
Dialogue: 0,0:44:33.57,0:44:36.51,Default,,0,0,0,,如果应用中的运算符
Dialogue: 0,0:44:36.51,0:44:37.37,Default,,0,0,0,,就是这里
Dialogue: 0,0:44:37.66,0:44:38.94,Default,,0,0,0,,这就是运算符
Dialogue: 0,0:44:40.19,0:44:41.77,Default,,0,0,0,,应用在这个运算对象上
Dialogue: 0,0:44:44.54,0:44:45.74,Default,,0,0,0,,形成了一个组合式
Dialogue: 0,0:44:46.72,0:44:48.25,Default,,0,0,0,,现在我们要如何来求值呢？
Dialogue: 0,0:44:48.84,0:44:52.37,Default,,0,0,0,,它是COND语句中的最后一种情况
Dialogue: 0,0:44:52.37,0:44:55.52,Default,,0,0,0,,在这步求值中 进行的代换是
Dialogue: 0,0:44:55.71,0:44:57.47,Default,,0,0,0,,把运算符的求值结果
Dialogue: 0,0:44:57.50,0:44:59.00,Default,,0,0,0,,应用在EVLIST的运算对象上
Dialogue: 0,0:45:01.16,0:45:08.20,Default,,0,0,0,,这也就是 (APPLY (APPLY (EVAL
Dialogue: 0,0:45:10.57,0:45:21.07,Default,,0,0,0,,'(LAMBDA (X) (LAMBDA (Y) (+ X Y)))
Dialogue: 0,0:45:21.80,0:45:23.45,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,0:45:23.74,0:45:25.42,Default,,0,0,0,,<E0>)
Dialogue: 0,0:45:30.52,0:45:32.67,Default,,0,0,0,,我就直接给出运算对象的求值结果了
Dialogue: 0,0:45:32.68,0:45:34.14,Default,,0,0,0,,具体过程跟之前是一样的
Dialogue: 0,0:45:35.23,0:45:36.48,Default,,0,0,0,,我有一个表'(3)
Dialogue: 0,0:45:36.51,0:45:39.16,Default,,0,0,0,,把它应用于'(4)
Dialogue: 0,0:45:42.44,0:45:43.56,Default,,0,0,0,,我们接着看
Dialogue: 0,0:45:44.41,0:45:46.38,Default,,0,0,0,,对一个LAMBDA表达式求值
Dialogue: 0,0:45:48.01,0:45:49.45,Default,,0,0,0,,会产生一个过程对象
Dialogue: 0,0:45:52.03,0:45:57.88,Default,,0,0,0,,继续变换就是 (APPLY (APPLY
Dialogue: 0,0:46:00.30,0:46:02.27,Default,,0,0,0,,然后是一个过程对象 '(CLOSURE
Dialogue: 0,0:46:04.52,0:46:08.68,Default,,0,0,0,,它里面包含了过程的体
Dialogue: 0,0:46:08.94,0:46:11.92,Default,,0,0,0,,它绑定了变量X
Dialogue: 0,0:46:12.13,0:46:15.40,Default,,0,0,0,,然后是函数体内部
Dialogue: 0,0:46:15.80,0:46:18.17,Default,,0,0,0,,它返回一个参数为Y的单参过程
Dialogue: 0,0:46:18.56,0:46:20.63,Default,,0,0,0,,这个过程计算X+Y
Dialogue: 0,0:46:23.21,0:46:25.50,Default,,0,0,0,,这个过程对象捕获了环境<E0>
Dialogue: 0,0:46:27.24,0:46:29.63,Default,,0,0,0,,因为这些求值都是在<E0>中发生的
Dialogue: 0,0:46:30.11,0:46:32.43,Default,,0,0,0,,现在 <E0>也是CLOSURE对象的一部分
Dialogue: 0,0:46:33.04,0:46:38.19,Default,,0,0,0,,先应用于'(3)
Dialogue: 0,0:46:38.81,0:46:41.30,Default,,0,0,0,,再应用于'(4)
Dialogue: 0,0:46:47.39,0:46:49.29,Default,,0,0,0,,在这步到这步的过程中
Dialogue: 0,0:46:49.31,0:46:50.89,Default,,0,0,0,,我构建了一个过程对象
Dialogue: 0,0:46:50.91,0:46:52.03,Default,,0,0,0,,它捕获了<E0>
Dialogue: 0,0:46:53.88,0:46:55.98,Default,,0,0,0,,并将其作为本身的一部分
Dialogue: 0,0:46:57.15,0:46:58.51,Default,,0,0,0,,现在 要把它们传递给APPLY了
Dialogue: 0,0:46:58.52,0:46:59.71,Default,,0,0,0,,我们得把这个过程
Dialogue: 0,0:47:00.48,0:47:01.58,Default,,0,0,0,,应用在对应的参数上
Dialogue: 0,0:47:02.71,0:47:06.51,Default,,0,0,0,,这里的过程并不是基本过程
Dialogue: 0,0:47:07.38,0:47:09.88,Default,,0,0,0,,它有一个类型标志'CLOSURE
Dialogue: 0,0:47:10.24,0:47:12.09,Default,,0,0,0,,因此还需要进行参数绑定
Dialogue: 0,0:47:13.71,0:47:14.72,Default,,0,0,0,,必须要绑定
Dialogue: 0,0:47:15.83,0:47:19.40,Default,,0,0,0,,在这里构造的新环境
Dialogue: 0,0:47:20.44,0:47:22.80,Default,,0,0,0,,它有一个父环境
Dialogue: 0,0:47:22.94,0:47:27.56,Default,,0,0,0,,父环境是这里的<E0>
Dialogue: 0,0:47:30.32,0:47:31.57,Default,,0,0,0,,我们把新环境记作<E1>
Dialogue: 0,0:47:34.62,0:47:35.74,Default,,0,0,0,,这里要绑定些什么呢？
Dialogue: 0,0:47:36.04,0:47:37.48,Default,,0,0,0,,变量X绑定为值3
Dialogue: 0,0:47:38.62,0:47:40.44,Default,,0,0,0,,这里写X=3
Dialogue: 0,0:47:41.48,0:47:42.33,Default,,0,0,0,,就是这些
Dialogue: 0,0:47:44.94,0:47:46.24,Default,,0,0,0,,新环境记作E1
Dialogue: 0,0:47:46.24,0:47:48.44,Default,,0,0,0,,而这个表达式会变换为
Dialogue: 0,0:47:49.13,0:47:50.72,Default,,0,0,0,,对一个过程体的求值
Dialogue: 0,0:47:51.72,0:47:53.07,Default,,0,0,0,,就是这个 在这里
Dialogue: 0,0:47:54.40,0:47:55.72,Default,,0,0,0,,这个过程的体
Dialogue: 0,0:47:56.44,0:47:58.52,Default,,0,0,0,,在刚才创建的<E1>中进行求值
Dialogue: 0,0:48:00.29,0:48:05.05,Default,,0,0,0,,也就是 (APPLY (EVAL
Dialogue: 0,0:48:06.92,0:48:16.43,Default,,0,0,0,,'(LAMBDA (Y) (+ X Y)) <E1>)
Dialogue: 0,0:48:20.49,0:48:22.48,Default,,0,0,0,,把求值的结果应用于4
Dialogue: 0,0:48:23.68,0:48:26.73,Default,,0,0,0,,也就是'(4)
Dialogue: 0,0:48:28.43,0:48:29.87,Default,,0,0,0,,到了这里就很清晰了
Dialogue: 0,0:48:30.08,0:48:32.27,Default,,0,0,0,,我知道该如何求值LAMBDA表达式
Dialogue: 0,0:48:33.11,0:48:34.17,Default,,0,0,0,,也就是(APPLY
Dialogue: 0,0:48:37.16,0:48:38.92,Default,,0,0,0,,一个过程对象'(CLOSURE
Dialogue: 0,0:48:43.74,0:48:46.84,Default,,0,0,0,,它绑定参数Y 计算X+Y
Dialogue: 0,0:48:49.28,0:48:52.15,Default,,0,0,0,,并且捕获了环境<E1>
Dialogue: 0,0:48:55.79,0:48:57.42,Default,,0,0,0,,你应该已经见过了 对吧？
Dialogue: 0,0:48:57.80,0:49:00.14,Default,,0,0,0,,我构造了一个CLOSURE对象
Dialogue: 0,0:49:00.14,0:49:01.16,Default,,0,0,0,,放在这里
Dialogue: 0,0:49:01.79,0:49:03.04,Default,,0,0,0,,之前的那个也是
Dialogue: 0,0:49:05.90,0:49:07.47,Default,,0,0,0,,这是现在的这个
Dialogue: 0,0:49:08.08,0:49:09.80,Default,,0,0,0,,它捕获了环境<E1>
Dialogue: 0,0:49:10.41,0:49:14.25,Default,,0,0,0,,而这个是参数为Y的一元过程
Dialogue: 0,0:49:15.45,0:49:16.70,Default,,0,0,0,,先不管它具体是什么
Dialogue: 0,0:49:18.09,0:49:20.72,Default,,0,0,0,,我们只知道它是一个CLOSURE
Dialogue: 0,0:49:22.57,0:49:26.46,Default,,0,0,0,,将这个过程应用于'(4)
Dialogue: 0,0:49:30.28,0:49:31.77,Default,,0,0,0,,很简单
Dialogue: 0,0:49:36.83,0:49:38.73,Default,,0,0,0,,我需要通过复制一个指针
Dialogue: 0,0:49:38.86,0:49:40.52,Default,,0,0,0,,就是这个过程的指针
Dialogue: 0,0:49:41.56,0:49:43.21,Default,,0,0,0,,来构造一个新环境
Dialogue: 0,0:49:44.94,0:49:48.96,Default,,0,0,0,,同时还得把参数Y跟值4绑定
Dialogue: 0,0:49:49.82,0:49:52.22,Default,,0,0,0,,我把这个新环境 记作<E2>
Dialogue: 0,0:49:56.03,0:49:58.12,Default,,0,0,0,,当然 这里的这个应用
Dialogue: 0,0:49:58.22,0:50:00.33,Default,,0,0,0,,其过程体的求值 是在<E2>中进行的
Dialogue: 0,0:50:01.58,0:50:07.87,Default,,0,0,0,,所以这就变成了对过程体的求值
Dialogue: 0,0:50:07.90,0:50:11.85,Default,,0,0,0,,也就是 (EVAL '(+ X Y) <E2>)
Dialogue: 0,0:50:13.71,0:50:14.94,Default,,0,0,0,,但由于这是一个应用
Dialogue: 0,0:50:15.48,0:50:23.88,Default,,0,0,0,,所以又代换为 (APPLY (EVAL '+ <E2>)
Dialogue: 0,0:50:26.33,0:50:37.34,Default,,0,0,0,,(EVLIST '(X Y) <E2>))
Dialogue: 0,0:50:44.88,0:50:45.59,Default,,0,0,0,,我们来看
Dialogue: 0,0:50:45.59,0:50:51.71,Default,,0,0,0,,下一步代换为 (APPLY
Dialogue: 0,0:50:52.08,0:50:53.87,Default,,0,0,0,,求值‘+得到的结果
Dialogue: 0,0:50:54.19,0:50:55.66,Default,,0,0,0,,所以我们从<E2>开始找
Dialogue: 0,0:50:55.69,0:50:57.72,Default,,0,0,0,,'+既不在<E2> 也不在<E1>
Dialogue: 0,0:50:57.74,0:51:01.05,Default,,0,0,0,,‘+是<E0>中的基本运算符
Dialogue: 0,0:51:01.78,0:51:04.74,Default,,0,0,0,,这个基本运算符是用于加法的
Dialogue: 0,0:51:07.47,0:51:14.12,Default,,0,0,0,,把它应用于 在<E2>中求值X和Y的结果
Dialogue: 0,0:51:14.37,0:51:17.00,Default,,0,0,0,,我们知道X是3 Y是4
Dialogue: 0,0:51:18.11,0:51:23.31,Default,,0,0,0,,所以这里是'(3 4)
Dialogue: 0,0:51:24.16,0:51:26.28,Default,,0,0,0,,然后就神奇地得到结果7
Dialogue: 0,0:51:30.52,0:51:32.44,Default,,0,0,0,,我再来整理一下这个过程 这样你们
Dialogue: 0,0:51:32.70,0:51:34.73,Default,,0,0,0,,就能了解这其中的重要本质
Dialogue: 0,0:51:35.76,0:51:37.29,Default,,0,0,0,,这个过程中传递了些什么？
Dialogue: 0,0:51:37.31,0:51:39.56,Default,,0,0,0,,每个模块持有什么 又负责什么？
Dialogue: 0,0:51:40.47,0:51:41.61,Default,,0,0,0,,有哪些模块呢？
Dialogue: 0,0:51:41.70,0:51:42.62,Default,,0,0,0,,一个是EVAL
Dialogue: 0,0:51:44.80,0:51:45.64,Default,,0,0,0,,还有个APPLY
Dialogue: 0,0:51:45.66,0:51:46.62,Default,,0,0,0,,两个主要角色
Dialogue: 0,0:51:49.37,0:51:51.56,Default,,0,0,0,,它们之间有个像这样的大循环
Dialogue: 0,0:51:52.32,0:52:04.57,Default,,0,0,0,,其中 EVAL为APPLY生成过程和参数
Dialogue: 0,0:52:06.27,0:52:08.57,Default,,0,0,0,,也有些事情 EVAL也可以自己做
Dialogue: 0,0:52:09.50,0:52:10.86,Default,,0,0,0,,都是一些细小的事情
Dialogue: 0,0:52:10.86,0:52:11.74,Default,,0,0,0,,并不十分有趣
Dialogue: 0,0:52:12.70,0:52:15.60,Default,,0,0,0,,同时 EVAL也逐个求值所有的参数
Dialogue: 0,0:52:16.24,0:52:17.28,Default,,0,0,0,,也没什么意思
Dialogue: 0,0:52:17.65,0:52:20.09,Default,,0,0,0,,APPLY可以应用像+这类的过程
Dialogue: 0,0:52:21.02,0:52:22.04,Default,,0,0,0,,这很普通
Dialogue: 0,0:52:22.30,0:52:24.64,Default,,0,0,0,,然而 如果APPLY不能应用像+这样的过程
Dialogue: 0,0:52:25.31,0:52:33.31,Default,,0,0,0,,它就为EVAL生成一个表达式及相应的环境
Dialogue: 0,0:52:35.47,0:52:37.61,Default,,0,0,0,,过程的参数封装了
Dialogue: 0,0:52:38.24,0:52:40.60,Default,,0,0,0,,计算所必需的状态
Dialogue: 0,0:52:41.66,0:52:43.42,Default,,0,0,0,,以及相应的环境
Dialogue: 0,0:52:43.74,0:52:45.31,Default,,0,0,0,,但我们接下来要做的
Dialogue: 0,0:52:45.32,0:52:46.46,Default,,0,0,0,,并不是完整的状态
Dialogue: 0,0:52:46.48,0:52:48.82,Default,,0,0,0,,因为它没有说明谁需要返回的结果
Dialogue: 0,0:52:51.28,0:52:52.20,Default,,0,0,0,,我们要做的就是
Dialogue: 0,0:52:52.24,0:52:54.80,Default,,0,0,0,,总是把某个表达式以及相应的环境
Dialogue: 0,0:52:54.99,0:52:56.14,Default,,0,0,0,,或者过程对象以及其参数
Dialogue: 0,0:52:56.28,0:52:58.08,Default,,0,0,0,,在这个循环之间不断传递
Dialogue: 0,0:52:58.97,0:53:01.80,Default,,0,0,0,,这里还有一些小型的子循环 比如EVLIST
Dialogue: 0,0:53:04.49,0:53:06.76,Default,,0,0,0,,又或者是EVAL中的EVCOND循环
Dialogue: 0,0:53:09.10,0:53:11.96,Default,,0,0,0,,甚至于APPLY调用PRIMITIVE-APPLY
Dialogue: 0,0:53:16.14,0:53:17.64,Default,,0,0,0,,但是它们并不是最主要的
Dialogue: 0,0:53:18.86,0:53:20.28,Default,,0,0,0,,这整个就是我想让你们看到的
Dialogue: 0,0:53:21.86,0:53:22.88,Default,,0,0,0,,有什么问题吗？
Dialogue: 0,0:53:25.93,0:53:27.37,Default,,0,0,0,,David 请说
Dialogue: 0,0:53:27.74,0:53:33.31,Default,,0,0,0,,学生：我不明白为什么X是3
Dialogue: 0,0:53:34.01,0:53:36.30,Default,,0,0,0,,而不是4
Dialogue: 0,0:53:37.07,0:53:38.52,Default,,0,0,0,,在那个部分
Dialogue: 0,0:53:38.56,0:53:40.54,Default,,0,0,0,,教授：是在这里
Dialogue: 0,0:53:41.31,0:53:43.31,Default,,0,0,0,,你想知道X是如何跟3绑定的
Dialogue: 0,0:53:43.52,0:53:47.42,Default,,0,0,0,,学生：因为X是外层过程的参数
Dialogue: 0,0:53:48.46,0:53:50.99,Default,,0,0,0,,而内层过程中既有X又有Y
Dialogue: 0,0:53:51.26,0:53:51.88,Default,,0,0,0,,教授：明白了
Dialogue: 0,0:53:52.84,0:53:54.62,Default,,0,0,0,,代换的过程中 我已经非常小心了
Dialogue: 0,0:53:55.02,0:53:56.92,Default,,0,0,0,,或许首先 我应该把这些过程
Dialogue: 0,0:53:56.94,0:53:58.41,Default,,0,0,0,,重新编排得更易读一点
Dialogue: 0,0:54:00.61,0:54:01.47,Default,,0,0,0,,你之所以有所疑惑
Dialogue: 0,0:54:01.48,0:54:02.99,Default,,0,0,0,,或许是因为你把程序看岔了
Dialogue: 0,0:54:03.83,0:54:04.70,Default,,0,0,0,,所以这里应该是
Dialogue: 0,0:54:05.15,0:54:09.60,Default,,0,0,0,,一个以X为参数的过程
Dialogue: 0,0:54:11.21,0:54:14.99,Default,,0,0,0,,它返回一个以Y为参数的过程
Dialogue: 0,0:54:15.72,0:54:18.44,Default,,0,0,0,,后者计算X+Y
Dialogue: 0,0:54:19.82,0:54:21.10,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,0:54:21.40,0:54:22.89,Default,,0,0,0,,外面的过程应用到3上
Dialogue: 0,0:54:24.08,0:54:26.12,Default,,0,0,0,,把得到的结果应用到4上
Dialogue: 0,0:54:26.14,0:54:28.81,Default,,0,0,0,,这个和之前那个是一样的 对吧？
Dialogue: 0,0:54:28.81,0:54:32.33,Default,,0,0,0,,现在 你可以立马发现
Dialogue: 0,0:54:33.77,0:54:34.94,Default,,0,0,0,,这里是一个应用
Dialogue: 0,0:54:35.16,0:54:36.46,Default,,0,0,0,,我先换根白粉笔
Dialogue: 0,0:54:37.32,0:54:41.12,Default,,0,0,0,,这一部分是应用 是一个组合式
Dialogue: 0,0:54:43.44,0:54:46.40,Default,,0,0,0,,这部分是组合式的运算符
Dialogue: 0,0:54:48.14,0:54:49.55,Default,,0,0,0,,而这是运算对象
Dialogue: 0,0:54:51.04,0:54:53.05,Default,,0,0,0,,这个3会跟这里的X绑定
Dialogue: 0,0:54:54.90,0:54:56.36,Default,,0,0,0,,而这个组合式的结果
Dialogue: 0,0:54:56.56,0:54:58.46,Default,,0,0,0,,是一个参数为Y的一元过程
Dialogue: 0,0:54:58.73,0:54:59.79,Default,,0,0,0,,它将应用于4
Dialogue: 0,0:55:00.88,0:55:01.58,Default,,0,0,0,,明白了吧？
Dialogue: 0,0:55:02.20,0:55:04.08,Default,,0,0,0,,所以你可能只是看岔了
Dialogue: 0,0:55:04.40,0:55:07.85,Default,,0,0,0,,而你们在这里看到的
Dialogue: 0,0:55:09.42,0:55:12.96,Default,,0,0,0,,是一个实际的过程对象 它有一个参数X
Dialogue: 0,0:55:13.34,0:55:15.31,Default,,0,0,0,,这个CLOSURE将应用于3
Dialogue: 0,0:55:15.95,0:55:17.07,Default,,0,0,0,,也就是'(3)
Dialogue: 0,0:55:18.98,0:55:21.34,Default,,0,0,0,,得到的结果再应用于'(4)
Dialogue: 0,0:55:24.08,0:55:25.20,Default,,0,0,0,,还有疑问吗？
Dialogue: 0,0:55:28.35,0:55:30.38,Default,,0,0,0,,那就休息一下吧
Dialogue: 0,0:55:30.83,0:55:31.37,Default,,0,0,0,,谢谢大家
Dialogue: 0,0:55:33.73,0:55:41.40,Default,,0,0,0,,[音乐]
Dialogue: 0,0:55:42.12,0:55:47.44,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:55:50.70,0:55:54.08,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:55:54.12,0:55:59.16,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:55:59.23,0:56:03.95,Declare,,0,0,0,,{\an2\fad(500,500)}元循环求值器 I
Dialogue: 0,0:56:08.41,0:56:11.29,Default,,0,0,0,,教授：课上到这里
Dialogue: 0,0:56:13.32,0:56:14.59,Default,,0,0,0,,你们可能开始觉得
Dialogue: 0,0:56:14.75,0:56:17.96,Default,,0,0,0,,Sussman教授又在胡说八道些什么
Dialogue: 0,0:56:20.74,0:56:23.92,Default,,0,0,0,,他讲的东西奇怪、愚蠢又毫无意义
Dialogue: 0,0:56:24.80,0:56:27.40,Default,,0,0,0,,他还宣称要给我们解释Lisp
Dialogue: 0,0:56:28.01,0:56:29.90,Default,,0,0,0,,然后在黑板上给我们写了一个Lisp程序
Dialogue: 0,0:56:31.23,0:56:33.53,Default,,0,0,0,,他还说：“这个Lisp程序就是Lisp解释器”
Dialogue: 0,0:56:33.85,0:56:35.02,Default,,0,0,0,,但是为了运行这个Lisp程序
Dialogue: 0,0:56:35.04,0:56:36.30,Default,,0,0,0,,你还先得有一个Lisp解释器啊
Dialogue: 0,0:56:38.37,0:56:40.19,Default,,0,0,0,,那个程序怎么能告诉我
Dialogue: 0,0:56:40.22,0:56:43.20,Default,,0,0,0,,有关于Lisp的知识呢？
Dialogue: 0,0:56:44.15,0:56:46.22,Default,,0,0,0,,它为什么又不是空中楼阁呢？
Dialogue: 0,0:56:48.49,0:56:50.25,Default,,0,0,0,,这件事非常奇怪
Dialogue: 0,0:56:50.99,0:56:52.43,Default,,0,0,0,,它究竟告诉了我什么？
Dialogue: 0,0:56:56.07,0:56:57.20,Default,,0,0,0,,我们发现 其实这整件事
Dialogue: 0,0:56:57.32,0:56:59.79,Default,,0,0,0,,非常像我们在这张幻灯片上看到的
Dialogue: 0,0:57:00.46,0:57:03.55,Default,,0,0,0,,Escher所画的手
Dialogue: 0,0:57:06.18,0:57:07.72,Default,,0,0,0,,是的 EVAL和APPLY
Dialogue: 0,0:57:07.76,0:57:10.16,Default,,0,0,0,,彼此画出彼此
Dialogue: 0,0:57:11.50,0:57:14.16,Default,,0,0,0,,并且构造出了真实的东西
Dialogue: 0,0:57:14.86,0:57:16.30,Default,,0,0,0,,它完全是自己画出了自己
Dialogue: 0,0:57:17.11,0:57:18.46,Default,,0,0,0,,Escher真是绝顶聪明
Dialogue: 0,0:57:18.68,0:57:20.41,Default,,0,0,0,,他只不过叫不出这些精灵的名字
Dialogue: 0,0:57:23.91,0:57:25.00,Default,,0,0,0,,我现在要做的就是
Dialogue: 0,0:57:26.09,0:57:28.00,Default,,0,0,0,,使你们相信
Dialogue: 0,0:57:28.16,0:57:29.87,Default,,0,0,0,,这一切都是有意义的
Dialogue: 0,0:57:30.16,0:57:31.98,Default,,0,0,0,,并且
Dialogue: 0,0:57:32.99,0:57:34.72,Default,,0,0,0,,我将要解释为什么我们不需要DEFINE
Dialogue: 0,0:57:36.09,0:57:37.71,Default,,0,0,0,,事实证明 我们并不需要DEFINE
Dialogue: 0,0:57:38.09,0:57:41.12,Default,,0,0,0,,为了进行数学意义上的计算
Dialogue: 0,0:57:42.51,0:57:44.89,Default,,0,0,0,,DEFINE并不是必需的
Dialogue: 0,0:57:49.10,0:57:50.03,Default,,0,0,0,,我们来看一下
Dialogue: 0,0:57:50.69,0:57:53.31,Default,,0,0,0,,考虑下面的一小段程序
Dialogue: 0,0:57:53.74,0:57:54.64,Default,,0,0,0,,它有什么作用？
Dialogue: 0,0:57:54.87,0:57:57.64,Default,,0,0,0,,这是一个计算指数的程序
Dialogue: 0,0:58:07.27,0:58:13.23,Default,,0,0,0,,EXPT计算X的N次方
Dialogue: 0,0:58:16.83,0:58:18.12,Default,,0,0,0,,如果N为0
Dialogue: 0,0:58:19.20,0:58:20.76,Default,,0,0,0,,那么结果就是1
Dialogue: 0,0:58:22.07,0:58:22.81,Default,,0,0,0,,否则
Dialogue: 0,0:58:25.56,0:58:28.48,Default,,0,0,0,,结果就是X乘以
Dialogue: 0,0:58:28.75,0:58:33.93,Default,,0,0,0,,(EXPT X (- N 1))))
Dialogue: 0,0:58:43.69,0:58:44.56,Default,,0,0,0,,应该没错
Dialogue: 0,0:58:46.63,0:58:48.72,Default,,0,0,0,,一个递归定义
Dialogue: 0,0:58:49.47,0:58:52.17,Default,,0,0,0,,用EXPT自身
Dialogue: 0,0:58:52.46,0:58:54.78,Default,,0,0,0,,来定义EXPT过程自己
Dialogue: 0,0:58:56.41,0:58:58.32,Default,,0,0,0,,就像我之前说的那样
Dialogue: 0,0:58:59.28,0:59:01.68,Default,,0,0,0,,你们高中数学老师在教这些东西的时候
Dialogue: 0,0:59:01.84,0:59:04.04,Default,,0,0,0,,你们一定学得很痛苦
Dialogue: 0,0:59:05.65,0:59:06.73,Default,,0,0,0,,这样定义合理吗？
Dialogue: 0,0:59:07.91,0:59:10.84,Default,,0,0,0,,为什么这种自引用的定义
Dialogue: 0,0:59:10.96,0:59:12.04,Default,,0,0,0,,能够说得通呢？
Dialogue: 0,0:59:13.43,0:59:15.10,Default,,0,0,0,,首先我要说的是
Dialogue: 0,0:59:15.13,0:59:17.60,Default,,0,0,0,,你们高中数学老师并非在胡说八道
Dialogue: 0,0:59:20.37,0:59:23.42,Default,,0,0,0,,考虑下面的几组定义
Dialogue: 0,0:59:24.27,0:59:27.42,Default,,0,0,0,,X+Y=3
Dialogue: 0,0:59:28.24,0:59:32.24,Default,,0,0,0,,X-Y=1
Dialogue: 0,0:59:33.07,0:59:35.56,Default,,0,0,0,,这个方程用Y来告诉你X
Dialogue: 0,0:59:35.58,0:59:37.84,Default,,0,0,0,,而这个方程或许是用X来告诉你Y
Dialogue: 0,0:59:40.15,0:59:42.95,Default,,0,0,0,,碰巧这组方程有唯一的解
Dialogue: 0,0:59:55.91,0:59:58.11,Default,,0,0,0,,然而 我也可能有这样的方程
Dialogue: 0,0:59:59.87,1:00:04.25,Default,,0,0,0,,2X+2Y=6
Dialogue: 0,1:00:06.83,1:00:09.87,Default,,0,0,0,,这两个方程有无穷多个解
Dialogue: 0,1:00:15.73,1:00:17.42,Default,,0,0,0,,我还可以有像这样的方程
Dialogue: 0,1:00:18.89,1:00:21.53,Default,,0,0,0,,X-Y=2
Dialogue: 0,1:00:22.14,1:00:24.41,Default,,0,0,0,,而下面的这两个方程没有解
Dialogue: 0,1:00:29.82,1:00:33.04,Default,,0,0,0,,这里 我有三组线性方程组
Dialogue: 0,1:00:35.45,1:00:39.51,Default,,0,0,0,,分别是这组、这组和这组
Dialogue: 0,1:00:39.88,1:00:41.79,Default,,0,0,0,,它们的解的数目完全不同
Dialogue: 0,1:00:42.90,1:00:45.76,Default,,0,0,0,,解的数目并不取决于方程的形式
Dialogue: 0,1:00:46.33,1:00:48.20,Default,,0,0,0,,三组方程都有一样的形式
Dialogue: 0,1:00:48.54,1:00:50.41,Default,,0,0,0,,解的数目取决于方程的内容
Dialogue: 0,1:00:53.00,1:00:55.15,Default,,0,0,0,,我不能通过观察方程的形式
Dialogue: 0,1:00:55.16,1:00:56.24,Default,,0,0,0,,来判断解的数目
Dialogue: 0,1:00:56.86,1:00:58.60,Default,,0,0,0,,必须要看它的内容
Dialogue: 0,1:00:59.66,1:01:00.88,Default,,0,0,0,,比如 对于线性方程组
Dialogue: 0,1:01:01.34,1:01:03.39,Default,,0,0,0,,它的系数都是什么？
Dialogue: 0,1:01:05.10,1:01:06.72,Default,,0,0,0,,我不能够通过观察
Dialogue: 0,1:01:06.99,1:01:08.33,Default,,0,0,0,,像这样的简单情况
Dialogue: 0,1:01:08.59,1:01:09.95,Default,,0,0,0,,来判定
Dialogue: 0,1:01:10.08,1:01:14.49,Default,,0,0,0,,EXPT就是这个递归方程的解
Dialogue: 0,1:01:16.03,1:01:18.41,Default,,0,0,0,,我不能说 EXPT就是那个过程
Dialogue: 0,1:01:18.91,1:01:21.10,Default,,0,0,0,,如果我们把它代换入其中
Dialogue: 0,1:01:22.04,1:01:24.06,Default,,0,0,0,,它就能给我们返回EXPT
Dialogue: 0,1:01:25.32,1:01:25.68,Default,,0,0,0,,能跟上吗？
Dialogue: 0,1:01:26.04,1:01:29.24,Default,,0,0,0,,通过观察这个形式 我也无法判别
Dialogue: 0,1:01:29.80,1:01:32.60,Default,,0,0,0,,EXPT是否有唯一解
Dialogue: 0,1:01:33.23,1:01:35.31,Default,,0,0,0,,有无穷个解 还是根本没有解
Dialogue: 0,1:01:37.20,1:01:38.62,Default,,0,0,0,,我们要了解它是如何计数的
Dialogue: 0,1:01:38.64,1:01:40.14,Default,,0,0,0,,或者是一些类似的计算细节
Dialogue: 0,1:01:40.60,1:01:42.75,Default,,0,0,0,,这可比在线性代数难多了
Dialogue: 0,1:01:43.28,1:01:45.21,Default,,0,0,0,,程序设计中可用的定理并不多
Dialogue: 0,1:01:48.45,1:01:51.21,Default,,0,0,0,,我想把这些方程稍稍重写一下
Dialogue: 0,1:01:51.93,1:01:53.77,Default,,0,0,0,,就是这里的方程
Dialogue: 0,1:01:53.97,1:01:56.62,Default,,0,0,0,,因为我们要研究的是这种形式的方程
Dialogue: 0,1:01:57.00,1:01:58.38,Default,,0,0,0,,但是我想用我们比较了解的方程
Dialogue: 0,1:01:58.40,1:01:59.53,Default,,0,0,0,,来做演示
Dialogue: 0,1:02:00.70,1:02:02.91,Default,,0,0,0,,以便于对于这类问题有深入的洞见
Dialogue: 0,1:02:04.72,1:02:06.43,Default,,0,0,0,,我们可以把这里的方程 改写为
Dialogue: 0,1:02:06.75,1:02:08.67,Default,,0,0,0,,这样的一种有趣形式
Dialogue: 0,1:02:09.77,1:02:14.86,Default,,0,0,0,,X=3-Y
Dialogue: 0,1:02:15.88,1:02:19.68,Default,,0,0,0,,Y=X-1
Dialogue: 0,1:02:22.01,1:02:24.05,Default,,0,0,0,,我们把这种变换叫什么来着？
Dialogue: 0,1:02:24.05,1:02:26.52,Default,,0,0,0,,这是一个线性变换 记为T
Dialogue: 0,1:02:29.43,1:02:32.25,Default,,0,0,0,,我们这里就得到了一个方程
Dialogue: 0,1:02:32.97,1:02:37.37,Default,,0,0,0,,<X Y> = T<X Y>
Dialogue: 0,1:02:42.99,1:02:43.98,Default,,0,0,0,,我要去找什么呢？
Dialogue: 0,1:02:44.56,1:02:46.01,Default,,0,0,0,,我在找T的不动点
Dialogue: 0,1:02:46.97,1:02:59.42,Default,,0,0,0,,T的不动点就是方程的解
Dialogue: 0,1:03:01.91,1:03:05.53,Default,,0,0,0,,所以 如果我们能通过找不动点
Dialogue: 0,1:03:05.90,1:03:07.48,Default,,0,0,0,,来求解方程
Dialogue: 0,1:03:08.65,1:03:09.87,Default,,0,0,0,,这看来是可行的
Dialogue: 0,1:03:10.88,1:03:12.36,Default,,0,0,0,,如果我可以用不动点
Dialogue: 0,1:03:12.38,1:03:14.32,Default,,0,0,0,,来求解方程
Dialogue: 0,1:03:15.52,1:03:18.19,Default,,0,0,0,,当然 也许它不可行
Dialogue: 0,1:03:18.57,1:03:19.80,Default,,0,0,0,,不过也可以借鉴来
Dialogue: 0,1:03:20.09,1:03:22.27,Default,,0,0,0,,研究如何求解这类方程
Dialogue: 0,1:03:27.24,1:03:29.48,Default,,0,0,0,,重要的是 我想让你们把它看成一个方程
Dialogue: 0,1:03:30.26,1:03:31.21,Default,,0,0,0,,它是一个表达式
Dialogue: 0,1:03:31.36,1:03:33.58,Default,,0,0,0,,其中有不同的变量
Dialogue: 0,1:03:34.70,1:03:37.66,Default,,0,0,0,,只不过这些名字还得满足一定的约束
Dialogue: 0,1:03:38.43,1:03:40.52,Default,,0,0,0,,这些名字限定了对应变量的取值
Dialogue: 0,1:03:41.48,1:03:45.01,Default,,0,0,0,,我们不能够随意、机械地代换
Dialogue: 0,1:03:47.74,1:03:49.77,Default,,0,0,0,,这就是我尝试求解的方程
Dialogue: 0,1:03:51.22,1:03:52.43,Default,,0,0,0,,我们来试试看
Dialogue: 0,1:03:53.96,1:03:55.66,Default,,0,0,0,,首先我需要写下
Dialogue: 0,1:03:56.64,1:03:59.00,Default,,0,0,0,,跟T相对应的函数
Dialogue: 0,1:04:00.32,1:04:03.00,Default,,0,0,0,,我写下的这个T对应的函数
Dialogue: 0,1:04:04.49,1:04:06.96,Default,,0,0,0,,它的不动点就是这个方程的解
Dialogue: 0,1:04:10.76,1:04:11.28,Default,,0,0,0,,能明白吗？
Dialogue: 0,1:04:12.25,1:04:14.30,Default,,0,0,0,,让我们来看下面这个过程F
Dialogue: 0,1:04:16.87,1:04:18.30,Default,,0,0,0,,我说 F计算的是这样一个函数
Dialogue: 0,1:04:19.34,1:04:22.91,Default,,0,0,0,,F本身是一个参数为G的一元过程
Dialogue: 0,1:04:25.23,1:04:25.93,Default,,0,0,0,,它返回
Dialogue: 0,1:04:26.40,1:04:32.00,Default,,0,0,0,,一个参数为X和N的过程
Dialogue: 0,1:04:33.43,1:04:34.73,Default,,0,0,0,,这个过程的定义是：
Dialogue: 0,1:04:36.72,1:04:40.43,Default,,0,0,0,,如果N为0
Dialogue: 0,1:04:41.72,1:04:43.20,Default,,0,0,0,,那么结果就是1
Dialogue: 0,1:04:45.34,1:04:46.17,Default,,0,0,0,,否则的话
Dialogue: 0,1:04:49.90,1:05:01.40,Default,,0,0,0,,结果就是(* X (G X (- N 1)))
Dialogue: 0,1:05:03.37,1:05:07.80,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,1:05:08.94,1:05:09.40,Default,,0,0,0,,没问题吧
Dialogue: 0,1:05:12.30,1:05:14.62,Default,,0,0,0,,这里 F是一个过程
Dialogue: 0,1:05:15.05,1:05:17.79,Default,,0,0,0,,如果我能解出这个方程
Dialogue: 0,1:05:19.04,1:05:22.04,Default,,0,0,0,,如果我找到了一个良好的指数过程
Dialogue: 0,1:05:23.42,1:05:26.32,Default,,0,0,0,,我把这个F应用到那个过程上
Dialogue: 0,1:05:27.60,1:05:31.24,Default,,0,0,0,,那么返回的应该也是一个良好的指数过程
Dialogue: 0,1:05:37.46,1:05:38.57,Default,,0,0,0,,这是为什么呢？
Dialogue: 0,1:05:39.42,1:05:40.88,Default,,0,0,0,,这是因为
Dialogue: 0,1:05:42.36,1:05:44.64,Default,,0,0,0,,F假设G是一个良好的指数过程
Dialogue: 0,1:05:45.63,1:05:47.58,Default,,0,0,0,,那么这里就会返回
Dialogue: 0,1:05:47.84,1:05:49.68,Default,,0,0,0,,一个参数为X和N的过程
Dialogue: 0,1:05:50.49,1:05:51.52,Default,,0,0,0,,其中如果N=0
Dialogue: 0,1:05:51.55,1:05:52.41,Default,,0,0,0,,结果就是1
Dialogue: 0,1:05:52.44,1:05:54.16,Default,,0,0,0,,这是非常符合定义的
Dialogue: 0,1:05:54.64,1:05:57.05,Default,,0,0,0,,否则 就返回X乘以
Dialogue: 0,1:05:57.26,1:05:59.26,Default,,0,0,0,,用给定的指数过程G
Dialogue: 0,1:06:00.17,1:06:02.44,Default,,0,0,0,,计算(G X (- N 1))
Dialogue: 0,1:06:03.47,1:06:04.78,Default,,0,0,0,,因此如果G能够
Dialogue: 0,1:06:04.81,1:06:06.30,Default,,0,0,0,,正确计算X^(N-1)
Dialogue: 0,1:06:07.87,1:06:11.28,Default,,0,0,0,,那么这个表达式就能正确计算X^N
Dialogue: 0,1:06:12.17,1:06:14.41,Default,,0,0,0,,所以整个就会是一个正确的求指数过程
Dialogue: 0,1:06:17.50,1:06:19.82,Default,,0,0,0,,因此 我在这里真正想指出的是
Dialogue: 0,1:06:21.02,1:06:32.44,Default,,0,0,0,,过程EXPT是函数F的不动点
Dialogue: 0,1:06:36.99,1:06:38.35,Default,,0,0,0,,现在我们的问题在于
Dialogue: 0,1:06:38.35,1:06:39.68,Default,,0,0,0,,不动点可能不止一个
Dialogue: 0,1:06:40.06,1:06:42.19,Default,,0,0,0,,也可能没有不动点
Dialogue: 0,1:06:43.27,1:06:44.81,Default,,0,0,0,,所以我们必须求出不动点
Dialogue: 0,1:06:48.22,1:06:49.37,Default,,0,0,0,,需要来解这个方程
Dialogue: 0,1:06:52.16,1:06:54.28,Default,,0,0,0,,求不动点的方法有很多种
Dialogue: 0,1:06:55.58,1:06:57.08,Default,,0,0,0,,本门课程的第一节课
Dialogue: 0,1:06:57.24,1:07:01.16,Default,,0,0,0,,我们就用余弦函数做了演示
Dialogue: 0,1:07:02.73,1:07:07.69,Default,,0,0,0,,先把你的计算器调成弧度制
Dialogue: 0,1:07:07.85,1:07:10.51,Default,,0,0,0,,然后一直按COS键
Dialogue: 0,1:07:11.84,1:07:15.45,Default,,0,0,0,,最后数字会稳定在0.73、0.74左右
Dialogue: 0,1:07:16.09,1:07:17.18,Default,,0,0,0,,我记不清是哪个了
Dialogue: 0,1:07:20.57,1:07:22.64,Default,,0,0,0,,通过迭代一个过程
Dialogue: 0,1:07:22.81,1:07:24.40,Default,,0,0,0,,我们不断迭代
Dialogue: 0,1:07:25.60,1:07:27.16,Default,,0,0,0,,想要寻找不动点的函数
Dialogue: 0,1:07:27.50,1:07:31.13,Default,,0,0,0,,有时候 它就会收敛在一个点上
Dialogue: 0,1:07:31.87,1:07:33.08,Default,,0,0,0,,这就是不动点
Dialogue: 0,1:07:33.77,1:07:35.44,Default,,0,0,0,,碰碰运气
Dialogue: 0,1:07:36.44,1:07:37.21,Default,,0,0,0,,来试试这种方法
Dialogue: 0,1:07:39.91,1:07:46.28,Default,,0,0,0,,来看这张幻灯片
Dialogue: 0,1:07:48.03,1:07:51.71,Default,,0,0,0,,考虑这么一连串的过程
Dialogue: 0,1:07:56.40,1:07:57.79,Default,,0,0,0,,这里的E0
Dialogue: 0,1:07:59.24,1:08:01.63,Default,,0,0,0,,这个E0过程什么也不做
Dialogue: 0,1:08:02.89,1:08:05.10,Default,,0,0,0,,无论你给它传递什么参数
Dialogue: 0,1:08:05.10,1:08:06.24,Default,,0,0,0,,它都会产生ERROR
Dialogue: 0,1:08:07.78,1:08:09.03,Default,,0,0,0,,基本上没什么用
Dialogue: 0,1:08:14.48,1:08:20.08,Default,,0,0,0,,然而 我可以做近似
Dialogue: 0,1:08:20.08,1:08:23.93,Default,,0,0,0,,让我们考虑下 指数过程的最差近似
Dialogue: 0,1:08:24.73,1:08:25.53,Default,,0,0,0,,因为它什么也做不了
Dialogue: 0,1:08:26.99,1:08:29.68,Default,,0,0,0,,假设我调用F
Dialogue: 0,1:08:30.35,1:08:33.26,Default,,0,0,0,,用E0去代换G
Dialogue: 0,1:08:33.79,1:08:36.30,Default,,0,0,0,,这里 G就被代换为了E0
Dialogue: 0,1:08:37.38,1:08:39.77,Default,,0,0,0,,所以在这里就是E0
Dialogue: 0,1:08:40.84,1:08:42.35,Default,,0,0,0,,那么E1又成了什么呢？
Dialogue: 0,1:08:43.63,1:08:46.03,Default,,0,0,0,,如果用E1来计算X^0
Dialogue: 0,1:08:46.67,1:08:48.78,Default,,0,0,0,,没什么问题
Dialogue: 0,1:08:49.60,1:08:50.75,Default,,0,0,0,,它返回的结果是正确的
Dialogue: 0,1:08:51.05,1:08:52.35,Default,,0,0,0,,任何数的0次幂都是1
Dialogue: 0,1:08:52.68,1:08:54.25,Default,,0,0,0,,然而计算其它次幂就会出错
Dialogue: 0,1:08:57.39,1:09:01.56,Default,,0,0,0,,现在如果我用E1来调用F
Dialogue: 0,1:09:02.30,1:09:07.40,Default,,0,0,0,,把G代换为E1 会发生什么？
Dialogue: 0,1:09:09.58,1:09:11.18,Default,,0,0,0,,这样的话
Dialogue: 0,1:09:12.01,1:09:15.02,Default,,0,0,0,,我就会得到这个二元过程
Dialogue: 0,1:09:15.67,1:09:16.84,Default,,0,0,0,,想一想 E1这个过程
Dialogue: 0,1:09:16.96,1:09:19.66,Default,,0,0,0,,只能正确计算X^0
Dialogue: 0,1:09:21.47,1:09:23.37,Default,,0,0,0,,它只能计算0次幂
Dialogue: 0,1:09:24.20,1:09:25.00,Default,,0,0,0,,所以这里
Dialogue: 0,1:09:25.52,1:09:27.28,Default,,0,0,0,,如果N为0 结果就是1
Dialogue: 0,1:09:27.29,1:09:28.67,Default,,0,0,0,,E2的这部分也正确
Dialogue: 0,1:09:29.52,1:09:32.01,Default,,0,0,0,,然而 我可以通过把0次幂乘以X
Dialogue: 0,1:09:32.51,1:09:35.26,Default,,0,0,0,,来计算1次幂
Dialogue: 0,1:09:35.97,1:09:39.67,Default,,0,0,0,,所以E2可以正确计算0次幂和1次幂
Dialogue: 0,1:09:41.60,1:09:41.92,Default,,0,0,0,,对吧？
Dialogue: 0,1:09:43.71,1:09:46.67,Default,,0,0,0,,E3的构造过程和E2是类似的
Dialogue: 0,1:09:47.89,1:09:50.24,Default,,0,0,0,,当然 E3具有同样的参数
Dialogue: 0,1:09:50.32,1:09:53.37,Default,,0,0,0,,能够正确计算0、1、2次幂
Dialogue: 0,1:09:55.12,1:09:55.40,Default,,0,0,0,,对吧？
Dialogue: 0,1:09:56.09,1:09:59.08,Default,,0,0,0,,因此我就不加证明地告诉你结论
Dialogue: 0,1:09:59.66,1:10:01.72,Default,,0,0,0,,因为这个证明过程太难了
Dialogue: 0,1:10:02.52,1:10:03.60,Default,,0,0,0,,这种事情
Dialogue: 0,1:10:03.63,1:10:06.36,Default,,0,0,0,,是由人们所谓“指称语义学家”完成的
Dialogue: 0,1:10:06.59,1:10:07.64,Default,,0,0,0,,这个伟大的想法
Dialogue: 0,1:10:07.87,1:10:10.59,Default,,0,0,0,,应该是由Scott和Strachey提出的
Dialogue: 0,1:10:11.64,1:10:16.32,Default,,0,0,0,,他们是非常著名的数学家
Dialogue: 0,1:10:16.86,1:10:21.21,Default,,0,0,0,,他们发明了这些程序的解释方式
Dialogue: 0,1:10:22.36,1:10:24.00,Default,,0,0,0,,就是我刚才讲的那些
Dialogue: 0,1:10:24.24,1:10:26.17,Default,,0,0,0,,他们通过拓扑学的方法证明了
Dialogue: 0,1:10:27.04,1:10:29.32,Default,,0,0,0,,在我们刚才那种情况下
Dialogue: 0,1:10:29.82,1:10:31.26,Default,,0,0,0,,不动点是存在的
Dialogue: 0,1:10:32.22,1:10:33.24,Default,,0,0,0,,这个结论就是：
Dialogue: 0,1:10:33.40,1:10:44.24,Default,,0,0,0,,当N趋近于无穷时 EXPT是E(N)的极限
Dialogue: 0,1:10:45.52,1:10:47.90,Default,,0,0,0,,我们是通过下面这种方式来构造这个极限的
Dialogue: 0,1:10:50.52,1:10:55.66,Default,,0,0,0,,EXPT=(F (F (F (F ....
Dialogue: 0,1:10:57.61,1:11:00.19,Default,,0,0,0,,(F 丄)
Dialogue: 0,1:11:01.12,1:11:02.46,Default,,0,0,0,,它是什么都无所谓
Dialogue: 0,1:11:03.18,1:11:05.00,Default,,0,0,0,,因为它总会生成一个错误
Dialogue: 0,1:11:07.45,1:11:08.41,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,1:11:12.89,1:11:14.48,Default,,0,0,0,,这是F无穷嵌套调用
Dialogue: 0,1:11:16.38,1:11:17.71,Default,,0,0,0,,现在我们的问题
Dialogue: 0,1:11:18.22,1:11:19.76,Default,,0,0,0,,又变成了如何构造出无穷调用
Dialogue: 0,1:11:22.59,1:11:24.08,Default,,0,0,0,,我们需要它们
Dialogue: 0,1:11:24.92,1:11:26.25,Default,,0,0,0,,我怎样才能把F
Dialogue: 0,1:11:26.56,1:11:27.80,Default,,0,0,0,,嵌套无穷层呢？
Dialogue: 0,1:11:28.98,1:11:30.12,Default,,0,0,0,,我得把它构造出来
Dialogue: 0,1:11:32.38,1:11:32.93,Default,,0,0,0,,好吧 我不知道
Dialogue: 0,1:11:32.93,1:11:34.32,Default,,0,0,0,,到底怎么样构建一个无穷循环呢？
Dialogue: 0,1:11:34.81,1:11:36.32,Default,,0,0,0,,我们先来看个非常简单的无穷循环
Dialogue: 0,1:11:36.57,1:11:38.34,Default,,0,0,0,,能想到的最简单的无穷循环
Dialogue: 0,1:11:43.55,1:11:47.55,Default,,0,0,0,,把这样一个参数为X的函数过程
Dialogue: 0,1:11:48.00,1:11:49.79,Default,,0,0,0,,过程体是(X X)
Dialogue: 0,1:11:53.55,1:11:53.92,Default,,0,0,0,,看到了吧？
Dialogue: 0,1:11:55.05,1:11:58.41,Default,,0,0,0,,应用在一个参数为X过程上
Dialogue: 0,1:11:59.36,1:12:01.05,Default,,0,0,0,,后者的过程体也是(X X)
Dialogue: 0,1:12:04.83,1:12:06.00,Default,,0,0,0,,这就形成了一个无穷循环
Dialogue: 0,1:12:07.21,1:12:09.31,Default,,0,0,0,,这个循环之所以是无穷的
Dialogue: 0,1:12:09.98,1:12:11.31,Default,,0,0,0,,是因为
Dialogue: 0,1:12:11.52,1:12:13.69,Default,,0,0,0,,我用实际参数代换掉
Dialogue: 0,1:12:14.22,1:12:16.59,Default,,0,0,0,,过程体的形式参数
Dialogue: 0,1:12:18.85,1:12:21.60,Default,,0,0,0,,这样做了以后 这里的每个X
Dialogue: 0,1:12:22.40,1:12:23.76,Default,,0,0,0,,都被代换为了这个
Dialogue: 0,1:12:24.36,1:12:26.96,Default,,0,0,0,,相当于把最初的表达式又复制了一遍
Dialogue: 0,1:12:28.35,1:12:29.37,Default,,0,0,0,,这就是最简单的无穷循环
Dialogue: 0,1:12:35.44,1:12:39.29,Default,,0,0,0,,现在 我要介绍一个特殊的运算符
Dialogue: 0,1:12:40.38,1:12:43.09,Default,,0,0,0,,它是通过对这个无穷循环稍作修改而来
Dialogue: 0,1:12:46.96,1:12:47.92,Default,,0,0,0,,我把它记作“Y”
Dialogue: 0,1:12:50.89,1:12:55.82,Default,,0,0,0,,它的全称是：Curry的矛盾Y组合子
Dialogue: 0,1:12:56.62,1:12:58.99,Default,,0,0,0,,这是用二十世纪三十年代的逻辑学家
Dialogue: 0,1:12:59.34,1:13:01.85,Default,,0,0,0,,Curry的名字来命名的
Dialogue: 0,1:13:04.48,1:13:06.88,Default,,0,0,0,,Y组合子是一个参数为f的过程
Dialogue: 0,1:13:08.17,1:13:09.33,Default,,0,0,0,,它的过程体是什么呢？
Dialogue: 0,1:13:09.33,1:13:11.20,Default,,0,0,0,,它的内部是某种无穷循环
Dialogue: 0,1:13:11.98,1:13:15.47,Default,,0,0,0,,是一个参数为x的过程
Dialogue: 0,1:13:15.95,1:13:18.80,Default,,0,0,0,,它调用(f (x x))
Dialogue: 0,1:13:21.63,1:13:24.75,Default,,0,0,0,,这个过程应用在一个参数为X的过程上
Dialogue: 0,1:13:25.10,1:13:27.34,Default,,0,0,0,,后者调用(f (x x))
Dialogue: 0,1:13:32.30,1:13:33.13,Default,,0,0,0,,这个是怎么运作的？
Dialogue: 0,1:13:34.80,1:13:36.06,Default,,0,0,0,,假设执行(Y F)
Dialogue: 0,1:13:41.31,1:13:42.57,Default,,0,0,0,,这非常简单
Dialogue: 0,1:13:43.15,1:13:44.62,Default,,0,0,0,,这里大写的F跟那边的是同一个
Dialogue: 0,1:13:46.91,1:13:48.16,Default,,0,0,0,,在这里 很简单
Dialogue: 0,1:13:48.30,1:13:49.92,Default,,0,0,0,,我把F代换到这里来
Dialogue: 0,1:13:55.32,1:13:57.07,Default,,0,0,0,,基本上 我就会得到
Dialogue: 0,1:13:58.75,1:14:00.84,Default,,0,0,0,,因为我待会儿要用这个表达式
Dialogue: 0,1:14:01.45,1:14:02.80,Default,,0,0,0,,代换这里的x
Dialogue: 0,1:14:04.17,1:14:05.23,Default,,0,0,0,,这里就是(F
Dialogue: 0,1:14:08.97,1:14:10.09,Default,,0,0,0,,我还是把这步写出来吧
Dialogue: 0,1:14:10.22,1:14:11.45,Default,,0,0,0,,这样你们就能看得更全面
Dialogue: 0,1:14:11.92,1:14:14.27,Default,,0,0,0,,我会非常小心 好吗？
Dialogue: 0,1:14:15.02,1:14:18.25,Default,,0,0,0,,这里是 ((LAMBDA (x)
Dialogue: 0,1:14:19.08,1:14:22.11,Default,,0,0,0,,(F (x x))
Dialogue: 0,1:14:26.88,1:14:35.55,Default,,0,0,0,,把它应用到自身 (LAMBDA (x) (F (x x)))
Dialogue: 0,1:14:37.91,1:14:39.66,Default,,0,0,0,,把这个表达式代换进去
Dialogue: 0,1:14:40.06,1:14:40.91,Default,,0,0,0,,就得到
Dialogue: 0,1:14:43.13,1:14:48.35,Default,,0,0,0,,把这个代进去 得到什么呢？
Dialogue: 0,1:14:48.65,1:14:54.81,Default,,0,0,0,,(F (LAMBDA (x) (F (x x)))
Dialogue: 0,1:14:57.07,1:14:58.17,Default,,0,0,0,,应用到
Dialogue: 0,1:14:59.18,1:15:06.48,Default,,0,0,0,,(LAMBDA (x) (F (x x))))
Dialogue: 0,1:15:06.99,1:15:10.44,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,1:15:11.51,1:15:12.40,Default,,0,0,0,,哇 这又是什么？
Dialogue: 0,1:15:13.42,1:15:16.35,Default,,0,0,0,,我刚才计算的这一部分
Dialogue: 0,1:15:17.13,1:15:18.56,Default,,0,0,0,,就是这里的这部分
Dialogue: 0,1:15:20.19,1:15:21.84,Default,,0,0,0,,只不过它被包在另一个F里面
Dialogue: 0,1:15:23.37,1:15:24.67,Default,,0,0,0,,因此 通过把Y应用在F上
Dialogue: 0,1:15:24.68,1:15:26.22,Default,,0,0,0,,我构造出了F的无穷嵌套
Dialogue: 0,1:15:27.85,1:15:29.45,Default,,0,0,0,,我如果让它一直这样进行下去
Dialogue: 0,1:15:29.69,1:15:31.77,Default,,0,0,0,,我在外层就会得到越来越多的F
Dialogue: 0,1:15:33.17,1:15:34.80,Default,,0,0,0,,我运行一个无用的循环
Dialogue: 0,1:15:35.20,1:15:37.02,Default,,0,0,0,,但内部是无用的并不重要
Dialogue: 0,1:15:39.85,1:15:47.85,Default,,0,0,0,,因此 我们有 (Y F)=(F (Y F))
Dialogue: 0,1:15:50.33,1:15:52.14,Default,,0,0,0,,Y组合子十分神奇
Dialogue: 0,1:15:53.85,1:15:56.25,Default,,0,0,0,,如果把它应用于某个函数
Dialogue: 0,1:15:57.37,1:16:00.38,Default,,0,0,0,,它就会返回这个函数的不动点
Dialogue: 0,1:16:01.69,1:16:04.25,Default,,0,0,0,,当然是在不动点存在的前提下
Dialogue: 0,1:16:07.91,1:16:10.08,Default,,0,0,0,,这是因为 如果我把(Y F)带入F
Dialogue: 0,1:16:10.12,1:16:11.12,Default,,0,0,0,,结果还是(Y F)
Dialogue: 0,1:16:16.24,1:16:18.86,Default,,0,0,0,,现在我想让你们在
Dialogue: 0,1:16:19.85,1:16:22.38,Default,,0,0,0,,EVAL-APPLY解释器方面思考一下
Dialogue: 0,1:16:23.86,1:16:26.27,Default,,0,0,0,,我在这里写了一大堆递归方程组
Dialogue: 0,1:16:28.54,1:16:30.22,Default,,0,0,0,,那些联立方程组像
Dialogue: 0,1:16:30.22,1:16:31.23,Default,,0,0,0,,这些方程一样联立起来
Dialogue: 0,1:16:31.47,1:16:33.31,Default,,0,0,0,,但EXPT不是联立方程
Dialogue: 0,1:16:33.31,1:16:35.79,Default,,0,0,0,,只是一个需要我赋义的变量
Dialogue: 0,1:16:38.15,1:16:40.76,Default,,0,0,0,,而Lisp则是某个过程的不动点
Dialogue: 0,1:16:40.81,1:16:42.57,Default,,0,0,0,,对这个过程来说 如果我知道Lisp的定义
Dialogue: 0,1:16:42.59,1:16:46.51,Default,,0,0,0,,然后在递归方程等号的右边
Dialogue: 0,1:16:46.59,1:16:49.79,Default,,0,0,0,,用它来代换EVAL、APPLY等变量
Dialogue: 0,1:16:50.94,1:16:53.96,Default,,0,0,0,,如果它是一个良好定义的Lisp的话
Dialogue: 0,1:16:54.36,1:16:56.30,Default,,0,0,0,,那么递归方程等号左边 也是一个良好定义的Lisp
Dialogue: 0,1:16:58.22,1:16:59.82,Default,,0,0,0,,这样 那个定义就讲得通了
Dialogue: 0,1:17:02.42,1:17:05.41,Default,,0,0,0,,不过是否有解却不太明显
Dialogue: 0,1:17:05.69,1:17:06.75,Default,,0,0,0,,我也说不清
Dialogue: 0,1:17:07.74,1:17:09.21,Default,,0,0,0,,现在我要介绍的论证
Dialogue: 0,1:17:09.26,1:17:10.27,Default,,0,0,0,,相当危险
Dialogue: 0,1:17:10.66,1:17:11.64,Default,,0,0,0,,具体看这里
Dialogue: 0,1:17:13.05,1:17:14.61,Default,,0,0,0,,这些是关于极限的论证
Dialogue: 0,1:17:14.61,1:17:15.39,Default,,0,0,0,,我们要讨论的极限
Dialogue: 0,1:17:15.45,1:17:17.68,Default,,0,0,0,,是微积分或者拓扑学的概念
Dialogue: 0,1:17:17.87,1:17:20.03,Default,,0,0,0,,或者说是类似的 数学分析中的概念
Dialogue: 0,1:17:20.76,1:17:23.38,Default,,0,0,0,,这个论证是你们都承认的
Dialogue: 0,1:17:23.38,1:17:25.29,Default,,0,0,0,,我想让你们意识到
Dialogue: 0,1:17:25.42,1:17:27.66,Default,,0,0,0,,我可以把你们耍得团团转
Dialogue: 0,1:17:28.86,1:17:30.48,Default,,0,0,0,,准备好了吗？ 这是什么？
Dialogue: 0,1:17:34.25,1:17:39.52,Default,,0,0,0,,u = 1 + 1/2 + 1/4 + .......
Dialogue: 0,1:17:39.74,1:17:41.32,Default,,0,0,0,,这是几何级数求和
Dialogue: 0,1:17:42.82,1:17:44.68,Default,,0,0,0,,当然 我也可以耍点小把戏
Dialogue: 0,1:17:44.82,1:17:47.57,Default,,0,0,0,,u - 1 = 1/2 + 1/4 + 1/8 ......
Dialogue: 0,1:17:51.90,1:17:54.46,Default,,0,0,0,,这里我可以
Dialogue: 0,1:17:56.09,1:17:57.93,Default,,0,0,0,,糟糕了 这里漏掉了括号
Dialogue: 0,1:17:58.92,1:18:01.45,Default,,0,0,0,,这里应该是
Dialogue: 0,1:18:01.74,1:18:03.99,Default,,0,0,0,,2(u - 1) = 1 + 1/2 + 1/4 + 1/8 ........
Dialogue: 0,1:18:07.57,1:18:08.54,Default,,0,0,0,,这里能修改一下吗？
Dialogue: 0,1:18:14.01,1:18:16.43,Default,,0,0,0,,哦 可以
Dialogue: 0,1:18:18.19,1:18:18.65,Default,,0,0,0,,看到了吗？
Dialogue: 0,1:18:19.52,1:18:20.64,Default,,0,0,0,,这样 我就得到
Dialogue: 0,1:18:23.53,1:18:26.64,Default,,0,0,0,,2(u - 1) = u
Dialogue: 0,1:18:27.80,1:18:29.58,Default,,0,0,0,,因此我们推断出 u=2
Dialogue: 0,1:18:30.30,1:18:31.37,Default,,0,0,0,,这是正确的
Dialogue: 0,1:18:31.96,1:18:33.32,Default,,0,0,0,,这个推理过程没有问题
Dialogue: 0,1:18:34.04,1:18:37.55,Default,,0,0,0,,但如果我要是做点别的什么呢？
Dialogue: 0,1:18:38.54,1:18:39.48,Default,,0,0,0,,假设我要求和的式子
Dialogue: 0,1:18:39.50,1:18:41.20,Default,,0,0,0,,明显没有和
Dialogue: 0,1:18:41.56,1:18:46.99,Default,,0,0,0,,v = 1 + 2 + 4 + ........
Dialogue: 0,1:18:47.39,1:18:51.39,Default,,0,0,0,,v - 1 = 2 + 4 + 8 + ......
Dialogue: 0,1:18:52.27,1:18:56.03,Default,,0,0,0,,(v - 1)/2 = v
Dialogue: 0,1:18:57.41,1:19:00.54,Default,,0,0,0,,这里我就可以推断出
Dialogue: 0,1:19:01.37,1:19:02.91,Default,,0,0,0,,显然这里又写错了
Dialogue: 0,1:19:03.07,1:19:04.51,Default,,0,0,0,,应该是 v = -1
Dialogue: 0,1:19:12.45,1:19:13.82,Default,,0,0,0,,这里应该是-1
Dialogue: 0,1:19:15.28,1:19:16.91,Default,,0,0,0,,这个结论明显是错误的
Dialogue: 0,1:19:22.00,1:19:23.47,Default,,0,0,0,,当你处理极限的时候
Dialogue: 0,1:19:24.22,1:19:27.85,Default,,0,0,0,,在某种方式下可行的论证
Dialogue: 0,1:19:29.42,1:19:30.75,Default,,0,0,0,,在其它情况下可能又不行了
Dialogue: 0,1:19:30.75,1:19:31.69,Default,,0,0,0,,要多加注意
Dialogue: 0,1:19:32.24,1:19:33.87,Default,,0,0,0,,参数必须具有良好的形式
Dialogue: 0,1:19:36.14,1:19:39.23,Default,,0,0,0,,但我不清楚 通常来说
Dialogue: 0,1:19:39.85,1:19:41.93,Default,,0,0,0,,像这样的论证有什么样的要求
Dialogue: 0,1:19:43.27,1:19:45.24,Default,,0,0,0,,我们要研习一大堆拓扑学文献来寻找答案
Dialogue: 0,1:19:46.27,1:19:48.64,Default,,0,0,0,,但是至少你们现在理解了
Dialogue: 0,1:19:49.10,1:19:51.13,Default,,0,0,0,,为什么我们在黑板上写的这些东西
Dialogue: 0,1:19:51.15,1:19:52.76,Default,,0,0,0,,是有一定语义的
Dialogue: 0,1:19:53.66,1:19:55.61,Default,,0,0,0,,你们也理解了它的语义
Dialogue: 0,1:19:56.48,1:19:58.35,Default,,0,0,0,,我想现在是时候
Dialogue: 0,1:19:59.07,1:20:03.84,Default,,0,0,0,,祝贺你们成为
Dialogue: 0,1:20:04.28,1:20:05.55,Default,,0,0,0,,神圣的递归秩序中的
Dialogue: 0,1:20:05.56,1:20:07.04,Default,,0,0,0,,一名LAMBDA演算黑客了
Dialogue: 0,1:20:08.84,1:20:10.17,Default,,0,0,0,,这是我们的徽章
Dialogue: 0,1:20:10.82,1:20:12.54,Default,,0,0,0,,因为你已经理解了
Dialogue: 0,1:20:13.40,1:20:15.20,Default,,0,0,0,,它上面的那句话
Dialogue: 0,1:20:16.89,1:20:18.41,Default,,0,0,0,,(Y F) = (F (Y F))
Dialogue: 0,1:20:21.04,1:20:21.66,Default,,0,0,0,,这节课讲完了
Dialogue: 0,1:20:21.85,1:20:22.75,Default,,0,0,0,,有什么问题吗？
Dialogue: 0,1:20:24.71,1:20:25.15,Default,,0,0,0,,Lev 请说
Dialogue: 0,1:20:25.37,1:20:27.39,Default,,0,0,0,,学生：目前的状况来看
Dialogue: 0,1:20:27.40,1:20:30.22,Default,,0,0,0,,正如你指出的那样 我们不再需要DEFINE
Dialogue: 0,1:20:30.24,1:20:32.70,Default,,0,0,0,,不需要先存储一个值 以后再用
Dialogue: 0,1:20:32.99,1:20:33.32,Default,,0,0,0,,教授：对
Dialogue: 0,1:20:33.50,1:20:36.44,Default,,0,0,0,,学生：DEFINE在语言中好像有一些副作用
Dialogue: 0,1:20:36.49,1:20:38.52,Default,,0,0,0,,（听不清）并且依赖于时序
Dialogue: 0,1:20:39.30,1:20:42.06,Default,,0,0,0,,不用DEFINE 是否消除了副作用？
Dialogue: 0,1:20:42.28,1:20:44.68,Default,,0,0,0,,教授： 实际上
Dialogue: 0,1:20:44.88,1:20:46.44,Default,,0,0,0,,解释器并不是像这样实现的
Dialogue: 0,1:20:47.52,1:20:47.93,Default,,0,0,0,,明白了吧？
Dialogue: 0,1:20:48.92,1:20:53.15,Default,,0,0,0,,在实际的实现中 DEFINE这个运算
Dialogue: 0,1:20:53.18,1:20:55.53,Default,,0,0,0,,确实修改了环境
Dialogue: 0,1:20:57.95,1:21:02.33,Default,,0,0,0,,改变了执行DEFINE的那个框架
Dialogue: 0,1:21:03.69,1:21:06.51,Default,,0,0,0,,这样做是有很多原因的
Dialogue: 0,1:21:07.39,1:21:08.64,Default,,0,0,0,,其中之一就是
Dialogue: 0,1:21:08.67,1:21:10.09,Default,,0,0,0,,方便交互式系统
Dialogue: 0,1:21:11.34,1:21:14.12,Default,,0,0,0,,就是说 如果你构造了一个系统
Dialogue: 0,1:21:14.35,1:21:15.20,Default,,0,0,0,,而且你知道
Dialogue: 0,1:21:15.42,1:21:16.60,Default,,0,0,0,,你不打算进行调试
Dialogue: 0,1:21:16.60,1:21:17.55,Default,,0,0,0,,或之类的事儿
Dialogue: 0,1:21:17.84,1:21:20.72,Default,,0,0,0,,你想立马知道所有的东西
Dialogue: 0,1:21:20.75,1:21:21.24,Default,,0,0,0,,你想知道的是
Dialogue: 0,1:21:21.26,1:21:23.12,Default,,0,0,0,,方程组的最终解是什么？
Dialogue: 0,1:21:24.09,1:21:25.26,Default,,0,0,0,,然后系统返回你相应的值
Dialogue: 0,1:21:25.79,1:21:27.45,Default,,0,0,0,,但如果想要让系统变成交互式的
Dialogue: 0,1:21:27.45,1:21:28.75,Default,,0,0,0,,这样你可以在不影响其它部分的情况下
Dialogue: 0,1:21:28.76,1:21:31.68,Default,,0,0,0,,增量式地修改某一部分
Dialogue: 0,1:21:32.33,1:21:35.04,Default,,0,0,0,,没有DEFINE的话 就不能这么做了
Dialogue: 0,1:21:40.99,1:21:41.24,Default,,0,0,0,,你说
Dialogue: 0,1:21:42.30,1:21:44.25,Default,,0,0,0,,学生：就是那张“危险”的幻灯片
Dialogue: 0,1:21:44.65,1:21:47.13,Default,,0,0,0,,好像你举的两个例子
Dialogue: 0,1:21:47.16,1:21:49.07,Default,,0,0,0,,与其收敛与否有关系？
Dialogue: 0,1:21:49.18,1:21:49.56,Default,,0,0,0,,教授：是的
Dialogue: 0,1:21:50.30,1:21:52.62,Default,,0,0,0,,学生：函数理论中是否有
Dialogue: 0,1:21:52.76,1:21:54.68,Default,,0,0,0,,像线性系统
Dialogue: 0,1:21:54.72,1:21:56.60,Default,,0,0,0,,或者非线性系统中的
Dialogue: 0,1:21:57.74,1:21:59.00,Default,,0,0,0,,那种思考方式
Dialogue: 0,1:21:59.34,1:22:01.76,Default,,0,0,0,,函数的收敛性能否先验地知道
Dialogue: 0,1:22:02.35,1:22:05.53,Default,,0,0,0,,哪些属性可能被违反？
Dialogue: 0,1:22:05.79,1:22:06.57,Default,,0,0,0,,教授：我不知道
Dialogue: 0,1:22:07.68,1:22:10.09,Default,,0,0,0,,我也不知道它需要什么条件
Dialogue: 0,1:22:10.61,1:22:12.04,Default,,0,0,0,,我不知道怎么在一节课内
Dialogue: 0,1:22:12.52,1:22:14.73,Default,,0,0,0,,就给你们讲清楚
Dialogue: 0,1:22:16.91,1:22:18.48,Default,,0,0,0,,有什么条件来判别它们
Dialogue: 0,1:22:18.86,1:22:20.76,Default,,0,0,0,,是否收敛？
Dialogue: 0,1:22:22.86,1:22:23.31,Default,,0,0,0,,确实
Dialogue: 0,1:22:23.32,1:22:26.35,Default,,0,0,0,,这些都是为了告诉你 基于收敛的论证
Dialogue: 0,1:22:28.24,1:22:29.47,Default,,0,0,0,,都不可靠
Dialogue: 0,1:22:29.66,1:22:31.58,Default,,0,0,0,,如果你事先不知道收敛性的话
Dialogue: 0,1:22:32.81,1:22:34.20,Default,,0,0,0,,你可能做出错误的论证
Dialogue: 0,1:22:34.44,1:22:37.31,Default,,0,0,0,,你可以先假设知道了答案 然后进行演绎
Dialogue: 0,1:22:37.39,1:22:39.93,Default,,0,0,0,,看它会不会产生什么明显的矛盾
Dialogue: 0,1:22:40.97,1:22:42.28,Default,,0,0,0,,学生：我们是否可以说
Dialogue: 0,1:22:42.33,1:22:44.88,Default,,0,0,0,,如果数学表达式F收敛
Dialogue: 0,1:22:45.00,1:22:47.36,Default,,0,0,0,,那么它的递归性质就--
Dialogue: 0,1:22:47.58,1:22:51.29,Default,,0,0,0,,教授：我认为 在技术上有一类F
Dialogue: 0,1:22:52.12,1:22:54.22,Default,,0,0,0,,通过一些技术准则
Dialogue: 0,1:22:54.24,1:22:55.90,Default,,0,0,0,,我们可以找到这样的F
Dialogue: 0,1:22:55.98,1:23:01.31,Default,,0,0,0,,当你像这样迭代地应用它们时
Dialogue: 0,1:23:01.52,1:23:02.25,Default,,0,0,0,,它一定会收敛
Dialogue: 0,1:23:03.02,1:23:06.51,Default,,0,0,0,,这类准则包括：单调、连续
Dialogue: 0,1:23:07.32,1:23:07.95,Default,,0,0,0,,我想想
Dialogue: 0,1:23:08.38,1:23:09.37,Default,,0,0,0,,我把其它的准则忘了
Dialogue: 0,1:23:09.37,1:23:11.13,Default,,0,0,0,,还有一些列像这样的
Dialogue: 0,1:23:11.68,1:23:12.99,Default,,0,0,0,,判别准则
Dialogue: 0,1:23:13.43,1:23:16.00,Default,,0,0,0,,现在的难点是 给定F然后进行推理
Dialogue: 0,1:23:16.92,1:23:17.88,Default,,0,0,0,,这是F的定义
Dialogue: 0,1:23:18.17,1:23:19.66,Default,,0,0,0,,它满足这些准则吗？
Dialogue: 0,1:23:20.27,1:23:21.32,Default,,0,0,0,,这很难判断
Dialogue: 0,1:23:22.01,1:23:24.00,Default,,0,0,0,,那些准则都很简单得可以写下来
Dialogue: 0,1:23:24.58,1:23:26.32,Default,,0,0,0,,你可以看Joe Stoy写的一本书
Dialogue: 0,1:23:26.67,1:23:29.58,Default,,0,0,0,,那本书非常不错
Dialogue: 0,1:23:32.22,1:23:34.06,Default,,0,0,0,,叫做The Scott-Strachey
Dialogue: 0,1:23:34.49,1:23:38.46,Default,,0,0,0,,《指称语义：基于Scott-Strachey方法》
Dialogue: 0,1:23:39.55,1:23:40.76,Default,,0,0,0,,作者是Joe Stoy
Dialogue: 0,1:23:40.80,1:23:41.76,Default,,0,0,0,,由MIT出版社出版
Dialogue: 0,1:23:48.06,1:23:49.88,Default,,0,0,0,,他把这一方面讲得非常详细
Dialogue: 0,1:23:50.20,1:23:51.37,Default,,0,0,0,,绝对会让你吓一大跳
Dialogue: 0,1:23:55.05,1:23:56.19,Default,,0,0,0,,但是这本书仍然值得一读
Dialogue: 0,1:24:09.15,1:24:10.08,Default,,0,0,0,,好吧 谢谢大家
Dialogue: 0,1:24:11.49,1:24:12.99,Default,,0,0,0,,这节课到此为止
Dialogue: 0,1:24:14.17,1:24:34.60,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:24:14.17,1:24:34.49,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
