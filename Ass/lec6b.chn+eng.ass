[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Video Position: 629

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:20.97,0:00:24.08,EN,,0,0,0,,PROFESSOR: OK, well, we've been looking at streams,
Dialogue: 0,0:00:24.08,0:00:27.82,EN,,0,0,0,,this signal processing way of putting systems together.
Dialogue: 0,0:00:28.87,0:00:31.42,EN,,0,0,0,,And remember, the key idea is that
Dialogue: 0,0:00:31.90,0:00:32.96,EN,,0,0,0,,we decouple
Dialogue: 0,0:00:34.20,0:00:37.31,EN,,0,0,0,,the apparent order of events in our programs
Dialogue: 0,0:00:37.58,0:00:40.17,EN,,0,0,0,,from the actual order of events in the computer.
Dialogue: 0,0:00:41.07,0:00:42.28,EN,,0,0,0,,And that means that we can start
Dialogue: 0,0:00:42.57,0:00:44.14,EN,,0,0,0,,dealing with very long streams
Dialogue: 0,0:00:44.89,0:00:47.39,EN,,0,0,0,,and only having to generate the elements on demand.
Dialogue: 0,0:00:47.53,0:00:49.39,EN,,0,0,0,,That sort of on-demand computation
Dialogue: 0,0:00:49.52,0:00:51.40,EN,,0,0,0,,is built into the stream's data structure.
Dialogue: 0,0:00:54.11,0:00:55.64,EN,,0,0,0,,So if we have a very long stream,
Dialogue: 0,0:00:55.66,0:00:57.08,EN,,0,0,0,,we only compute what we need.
Dialogue: 0,0:00:58.04,0:01:00.75,EN,,0,0,0,,The things only get computed when we actually ask for them.
Dialogue: 0,0:01:00.75,0:01:01.74,EN,,0,0,0,,Well, what are examples?
Dialogue: 0,0:01:02.11,0:01:03.60,EN,,0,0,0,,Are they actually asking for them?
Dialogue: 0,0:01:05.02,0:01:06.01,EN,,0,0,0,,For instance, we might
Dialogue: 0,0:01:09.21,0:01:11.37,EN,,0,0,0,,might ask for the n-th element of a stream.
Dialogue: 0,0:01:15.36,0:01:18.92,EN,,0,0,0,,Here's a procedure that computes the n-th element of a stream.
Dialogue: 0,0:01:20.09,0:01:21.23,EN,,0,0,0,,An integer n,
Dialogue: 0,0:01:21.24,0:01:22.84,EN,,0,0,0,,the n-th element of some stream s,
Dialogue: 0,0:01:23.40,0:01:25.42,EN,,0,0,0,,and we just recursively walk down the stream.
Dialogue: 0,0:01:25.57,0:01:27.39,EN,,0,0,0,,And if n is 0, we compute the head.
Dialogue: 0,0:01:27.96,0:01:30.99,EN,,0,0,0,,Otherwise, it's the n-th the minus 1 element
Dialogue: 0,0:01:31.74,0:01:32.80,EN,,0,0,0,,of the stream.
Dialogue: 0,0:01:34.31,0:01:36.43,EN,,0,0,0,,Those two are just like for Lisp, but the difference
Dialogue: 0,0:01:36.62,0:01:38.76,EN,,0,0,0,,is those elements aren't going to get computed
Dialogue: 0,0:01:38.86,0:01:40.99,EN,,0,0,0,,until we walk down, taking successive n-ths.
Dialogue: 0,0:01:41.52,0:01:44.78,EN,,0,0,0,,So that's one way that the stream elements might get forced.
Dialogue: 0,0:01:45.77,0:01:46.64,EN,,0,0,0,,And another way,
Dialogue: 0,0:01:47.18,0:01:48.92,EN,,0,0,0,,here's a little procedure that prints a stream.
Dialogue: 0,0:01:49.30,0:01:50.38,EN,,0,0,0,,We say print a stream,
Dialogue: 0,0:01:51.90,0:01:53.28,EN,,0,0,0,,so to print a stream s.
Dialogue: 0,0:01:54.15,0:01:55.12,EN,,0,0,0,,Well, what do we do? We'll
Dialogue: 0,0:01:55.74,0:01:56.86,EN,,0,0,0,,We print the head of the stream,
Dialogue: 0,0:01:57.74,0:01:59.32,EN,,0,0,0,,and that will cause the head to be computed.
Dialogue: 0,0:01:59.72,0:02:02.84,EN,,0,0,0,,And then we recursively print stream the tail of the stream.
Dialogue: 0,0:02:04.99,0:02:06.03,EN,,0,0,0,,And if we're already done,
Dialogue: 0,0:02:06.04,0:02:08.57,EN,,0,0,0,,maybe we have to return something about the message done.
Dialogue: 0,0:02:09.66,0:02:11.39,EN,,0,0,0,,OK, and then so if you make a stream,
Dialogue: 0,0:02:11.64,0:02:13.64,EN,,0,0,0,,you could say here's the stream, this very long stream.
Dialogue: 0,0:02:14.31,0:02:16.33,EN,,0,0,0,,And then you say print the stream,
Dialogue: 0,0:02:16.41,0:02:19.77,EN,,0,0,0,,and the elements of the stream will get computed successively
Dialogue: 0,0:02:19.87,0:02:21.12,EN,,0,0,0,,as that print calls them.
Dialogue: 0,0:02:21.32,0:02:22.81,EN,,0,0,0,,They won't get all computed initially.
Dialogue: 0,0:02:24.30,0:02:25.66,EN,,0,0,0,,So in this way, we can
Dialogue: 0,0:02:27.50,0:02:29.61,EN,,0,0,0,,So in this way, we can deal with some very long streams.
Dialogue: 0,0:02:30.19,0:02:31.92,EN,,0,0,0,,Well, how long can a stream be?
Dialogue: 0,0:02:33.74,0:02:35.12,EN,,0,0,0,,Well, it can be infinitely long.
Dialogue: 0,0:02:35.90,0:02:38.04,EN,,0,0,0,,Let's look at an example here on the computer.
Dialogue: 0,0:02:38.92,0:02:41.96,EN,,0,0,0,,I could walk up to this computer, and I could say--
Dialogue: 0,0:02:43.48,0:02:53.31,EN,,0,0,0,,how about we'll define the stream of integers starting with some number N,
Dialogue: 0,0:02:54.24,0:02:57.13,EN,,0,0,0,,the stream of positive integers starting with some number n.
Dialogue: 0,0:03:00.36,0:03:19.16,EN,,0,0,0,,And that's cons-stream of n onto the integers from one more.
Dialogue: 0,0:03:24.41,0:03:25.61,EN,,0,0,0,,So there are the integers.
Dialogue: 0,0:03:28.99,0:03:31.50,EN,,0,0,0,,Then I could say let's get all the integers.
Dialogue: 0,0:03:34.57,0:03:44.33,EN,,0,0,0,,define the stream of integers to be the integers starting with 1.
Dialogue: 0,0:03:48.84,0:03:50.94,EN,,0,0,0,,And now if I say something like
Dialogue: 0,0:03:54.41,0:03:55.80,EN,,0,0,0,,what's the what's the 20th integer.
Dialogue: 0,0:04:03.42,0:04:05.53,EN,,0,0,0,,So it's 21 because we start counting at 0.
Dialogue: 0,0:04:06.84,0:04:08.88,EN,,0,0,0,,Or I can do more complicated things.
Dialogue: 0,0:04:09.45,0:04:10.84,EN,,0,0,0,,Let me to define a little predicate here.
Dialogue: 0,0:04:11.77,0:04:18.51,EN,,0,0,0,,How about define no-seven.
Dialogue: 0,0:04:19.58,0:04:20.75,EN,,0,0,0,,It's going to test an integer,
Dialogue: 0,0:04:21.79,0:04:23.16,EN,,0,0,0,,and it's going to say it's not.
Dialogue: 0,0:04:28.82,0:04:33.96,EN,,0,0,0,,I take the remainder of x by 7,
Dialogue: 0,0:04:36.62,0:04:38.35,EN,,0,0,0,,I don't get 0.
Dialogue: 0,0:04:43.80,0:04:49.77,EN,,0,0,0,,And then I could say define the integers with no sevens
Dialogue: 0,0:04:50.22,0:04:59.12,EN,,0,0,0,,take all the integers and filter them to have no sevens.
Dialogue: 0,0:05:11.57,0:05:13.34,EN,,0,0,0,,So now I've got the stream of all the integers
Dialogue: 0,0:05:13.63,0:05:15.05,EN,,0,0,0,,that are not divisible by seven.
Dialogue: 0,0:05:16.49,0:05:23.44,EN,,0,0,0,,So if I say what's the 100th integer
Dialogue: 0,0:05:24.70,0:05:26.48,EN,,0,0,0,,and the list not divisible by seven,
Dialogue: 0,0:05:26.86,0:05:28.11,EN,,0,0,0,,I get 117.
Dialogue: 0,0:05:28.32,0:05:30.67,EN,,0,0,0,,Or if I'd like to say well, I could say ah.
Dialogue: 0,0:05:32.30,0:05:34.38,EN,,0,0,0,,well, gee, what are all of them?
Dialogue: 0,0:05:35.27,0:05:40.35,EN,,0,0,0,,So I could say print stream all these integers with no seven,
Dialogue: 0,0:05:40.83,0:05:41.79,EN,,0,0,0,,it goes off printing.
Dialogue: 0,0:05:45.10,0:05:47.07,EN,,0,0,0,,You may have to wait a very long time to see them all.
Dialogue: 0,0:05:52.67,0:05:53.84,EN,,0,0,0,,Well, you can start asking, gee,
Dialogue: 0,0:05:54.81,0:05:57.00,EN,,0,0,0,,you know, is it really true that this data structure
Dialogue: 0,0:05:58.28,0:06:00.65,EN,,0,0,0,,with the integers is really all the integers?
Dialogue: 0,0:06:01.10,0:06:04.05,EN,,0,0,0,,And let me draw a picture of that program I just wrote.
Dialogue: 0,0:06:04.96,0:06:10.57,EN,,0,0,0,,Here's the, right, here's the definition of the integers again that I just typed in,
Dialogue: 0,0:06:12.33,0:06:15.98,EN,,0,0,0,,Right it's a cons of the first integer under the integer starting with the rest.
Dialogue: 0,0:06:17.61,0:06:19.77,EN,,0,0,0,,Now, we can make a picture of that and see what it looks like.
Dialogue: 0,0:06:22.72,0:06:24.32,EN,,0,0,0,,Conceptually, what I have is a box
Dialogue: 0,0:06:25.53,0:06:27.18,EN,,0,0,0,,that's the integer starting with n.
Dialogue: 0,0:06:27.42,0:06:29.08,EN,,0,0,0,,It takes in some number n,
Dialogue: 0,0:06:31.42,0:06:32.97,EN,,0,0,0,,and it's going to return a stream of--
Dialogue: 0,0:06:35.02,0:06:37.36,EN,,0,0,0,,this infinite stream of all integers starting with n.
Dialogue: 0,0:06:38.08,0:06:38.73,EN,,0,0,0,,And what do I do?
Dialogue: 0,0:06:38.75,0:06:42.38,EN,,0,0,0,,Well, this is an integers-from box.
Dialogue: 0,0:06:45.07,0:06:45.80,EN,,0,0,0,,What's it got in it?
Dialogue: 0,0:06:45.80,0:06:48.60,EN,,0,0,0,,Well, it takes in this n,
Dialogue: 0,0:06:52.27,0:06:53.92,EN,,0,0,0,,and it increments it.
Dialogue: 0,0:06:57.95,0:07:03.15,EN,,0,0,0,,And then it puts the result into recursively another integer's from box.
Dialogue: 0,0:07:06.87,0:07:09.60,EN,,0,0,0,,It takes the result of that and the original n
Dialogue: 0,0:07:10.24,0:07:12.78,EN,,0,0,0,,and puts those together with a cons
Dialogue: 0,0:07:13.39,0:07:14.36,EN,,0,0,0,,and forms a stream.
Dialogue: 0,0:07:14.57,0:07:17.26,EN,,0,0,0,,So that's a picture of that program I wrote. And this is a ...
Dialogue: 0,0:07:18.52,0:07:20.32,EN,,0,0,0,,Let's see. These kind of diagrams we first saw
Dialogue: 0,0:07:20.78,0:07:21.74,EN,,0,0,0,,drawn by Peter Henderson,
Dialogue: 0,0:07:21.76,0:07:23.32,EN,,0,0,0,,the same guy who did the Escher language.
Dialogue: 0,0:07:23.32,0:07:24.75,EN,,0,0,0,,We call them Henderson diagrams.
Dialogue: 0,0:07:25.37,0:07:27.90,EN,,0,0,0,,And the convention here is that you put these things together.
Dialogue: 0,0:07:28.53,0:07:32.51,EN,,0,0,0,,And the solid lines are things coming out are streams,
Dialogue: 0,0:07:33.02,0:07:36.20,EN,,0,0,0,,and dotted lines are initial values going in.
Dialogue: 0,0:07:37.27,0:07:39.02,EN,,0,0,0,,So this one has the shape of--
Dialogue: 0,0:07:39.40,0:07:41.60,EN,,0,0,0,,it takes in some integer, some initial value,
Dialogue: 0,0:07:41.80,0:07:42.91,EN,,0,0,0,,and outputs a stream.
Dialogue: 0,0:07:46.35,0:07:48.22,EN,,0,0,0,,Again, you can ask. You know it's really
Dialogue: 0,0:07:48.38,0:07:50.88,EN,,0,0,0,,Is that data structure integers really all the integers?
Dialogue: 0,0:07:52.09,0:07:54.91,EN,,0,0,0,,Alright? Or is it is something that's cleverly arranged
Dialogue: 0,0:07:54.94,0:07:56.43,EN,,0,0,0,,so that whenever you look for an integer
Dialogue: 0,0:07:56.44,0:07:57.24,EN,,0,0,0,,you find it there?
Dialogue: 0,0:07:57.95,0:07:59.74,EN,,0,0,0,,That's sort of a philosophical question, right?
Dialogue: 0,0:07:59.78,0:08:01.69,EN,,0,0,0,,If something is there
Dialogue: 0,0:08:02.14,0:08:03.96,EN,,0,0,0,,whenever you look, is it really there or not?
Dialogue: 0,0:08:04.45,0:08:07.34,EN,,0,0,0,,It's sort of the same sense in which
Dialogue: 0,0:08:07.36,0:08:09.42,EN,,0,0,0,,the money in your savings account is in the bank.
Dialogue: 0,0:08:12.38,0:08:12.64,EN,,0,0,0,,Well
Dialogue: 0,0:08:16.35,0:08:17.48,EN,,0,0,0,,let me do another example.
Dialogue: 0,0:08:18.68,0:08:20.70,EN,,0,0,0,,Umm, Gee, we started the course
Dialogue: 0,0:08:20.72,0:08:22.72,EN,,0,0,0,,with an algorithm from Alexandria,
Dialogue: 0,0:08:23.29,0:08:25.80,EN,,0,0,0,,which was Heron of Alexandria's algorithm
Dialogue: 0,0:08:25.82,0:08:26.94,EN,,0,0,0,,for computing the square root.
Dialogue: 0,0:08:28.47,0:08:32.03,EN,,0,0,0,,Let's take a look at another Alexandrian algorithm.
Dialogue: 0,0:08:32.03,0:08:35.08,EN,,0,0,0,,This one is Eratosthenes method for
Dialogue: 0,0:08:36.19,0:08:38.44,EN,,0,0,0,,for computing all of the primes.
Dialogue: 0,0:08:41.16,0:08:42.83,EN,,0,0,0,,It is called the Sieve of Eratosthenes.
Dialogue: 0,0:08:42.83,0:08:49.72,EN,,0,0,0,,And what you do is you start out,
Dialogue: 0,0:08:50.99,0:08:52.28,EN,,0,0,0,,and you list all the integers,
Dialogue: 0,0:08:52.60,0:08:53.53,EN,,0,0,0,,say, starting with 2.
Dialogue: 0,0:08:53.88,0:08:55.04,EN,,0,0,0,,And then you take the first integer, and you say,
Dialogue: 0,0:08:55.08,0:08:56.67,EN,,0,0,0,,and you say, oh, that's prime.
Dialogue: 0,0:08:57.31,0:08:58.35,EN,,0,0,0,,And then you go look at the rest,
Dialogue: 0,0:08:58.68,0:09:00.88,EN,,0,0,0,,and you cross out all the things divisible by 2.
Dialogue: 0,0:09:01.52,0:09:04.73,EN,,0,0,0,,So I cross out this and this and this.
Dialogue: 0,0:09:05.25,0:09:06.35,EN,,0,0,0,,This takes a long time
Dialogue: 0,0:09:06.36,0:09:08.91,EN,,0,0,0,,because I have to do it for all of the integers.
Dialogue: 0,0:09:11.16,0:09:15.39,EN,,0,0,0,,So I go through the entire list of integers,
Dialogue: 0,0:09:18.27,0:09:20.94,EN,,0,0,0,,crossing the ones divisible by 2.
Dialogue: 0,0:09:22.11,0:09:24.38,EN,,0,0,0,,And now when I finish with all of the integers,
Dialogue: 0,0:09:24.78,0:09:26.72,EN,,0,0,0,,I go back and look and say what am I left with?
Dialogue: 0,0:09:27.04,0:09:28.80,EN,,0,0,0,,Well, the first thing that starts there is 3.
Dialogue: 0,0:09:29.33,0:09:30.33,EN,,0,0,0,,So 3 is a prime.
Dialogue: 0,0:09:30.77,0:09:33.05,EN,,0,0,0,,And now I go back through what I'm left with,
Dialogue: 0,0:09:33.36,0:09:35.07,EN,,0,0,0,,and I cross out all the things divisible by 3.
Dialogue: 0,0:09:35.08,0:09:43.80,EN,,0,0,0,,So let's see, 9 and 15 and 21 and 27 and 33 and so on.
Dialogue: 0,0:09:44.33,0:09:45.12,EN,,0,0,0,,I won't finish.
Dialogue: 0,0:09:45.35,0:09:46.52,EN,,0,0,0,,Then I see what I'm left with.
Dialogue: 0,0:09:47.25,0:09:49.84,EN,,0,0,0,,And the next one I have is 5.
Dialogue: 0,0:09:50.49,0:09:52.04,EN,,0,0,0,,Now I can through the rest,
Dialogue: 0,0:09:52.43,0:09:54.51,EN,,0,0,0,,and I find the first one that's divisible by 5.
Dialogue: 0,0:09:54.54,0:09:57.61,EN,,0,0,0,,I cross out from the remainder all the ones that are divisible by 5.
Dialogue: 0,0:09:58.35,0:09:59.24,EN,,0,0,0,,And I did that,
Dialogue: 0,0:09:59.82,0:10:01.89,EN,,0,0,0,,and then I go through and find 7.
Dialogue: 0,0:10:01.89,0:10:02.72,EN,,0,0,0,,Go through all the rest,
Dialogue: 0,0:10:02.76,0:10:03.95,EN,,0,0,0,,cross out things divisible 7,
Dialogue: 0,0:10:03.98,0:10:05.47,EN,,0,0,0,,and I keep doing that forever.
Dialogue: 0,0:10:06.81,0:10:07.40,EN,,0,0,0,,And when I'm done,
Dialogue: 0,0:10:07.40,0:10:09.10,EN,,0,0,0,,what I'm left with is a list of all the primes.
Dialogue: 0,0:10:09.90,0:10:13.31,EN,,0,0,0,,So that's the Sieve of Eratosthenes.
Dialogue: 0,0:10:15.43,0:10:17.69,EN,,0,0,0,,Let's look at it as a computer program.
Dialogue: 0,0:10:17.93,0:10:19.85,EN,,0,0,0,,It's a procedure called sieve.
Dialogue: 0,0:10:27.91,0:10:29.40,EN,,0,0,0,,Now, I just write what I did.
Dialogue: 0,0:10:30.33,0:10:34.48,EN,,0,0,0,,I'll say to sieve some stream s.
Dialogue: 0,0:10:38.77,0:10:39.93,EN,,0,0,0,,I'm going to build a stream
Dialogue: 0,0:10:40.27,0:10:41.84,EN,,0,0,0,,whose first element is the head of this.
Dialogue: 0,0:10:41.87,0:10:44.43,EN,,0,0,0,,Remember, I always found the first thing I was left with,
Dialogue: 0,0:10:44.91,0:10:48.75,EN,,0,0,0,,and the rest of it is the result of taking the tail of S,
Dialogue: 0,0:10:51.08,0:10:53.72,EN,,0,0,0,,filtering it to throw away all the things
Dialogue: 0,0:10:53.74,0:10:55.32,EN,,0,0,0,,that are divisible by the head of S,
Dialogue: 0,0:10:56.41,0:10:57.56,EN,,0,0,0,,and now sieving the result.
Dialogue: 0,0:10:59.02,0:11:00.09,EN,,0,0,0,,That's just what I did.
Dialogue: 0,0:11:01.98,0:11:04.68,EN,,0,0,0,,And now to get the infinite stream of times,
Dialogue: 0,0:11:05.02,0:11:06.90,EN,,0,0,0,,we just sieve all the integers starting from 2.
Dialogue: 0,0:11:14.92,0:11:15.56,EN,,0,0,0,,Let's try that.
Dialogue: 0,0:11:16.30,0:11:18.30,EN,,0,0,0,,We can actually do it.
Dialogue: 0,0:11:19.76,0:11:22.12,EN,,0,0,0,,I typed in the definition of sieve before, I hope,
Dialogue: 0,0:11:22.86,0:11:24.06,EN,,0,0,0,,so I can say something like
Dialogue: 0,0:11:24.92,0:11:33.45,EN,,0,0,0,,define the primes to be
Dialogue: 0,0:11:34.64,0:11:41.45,EN,,0,0,0,,the result of sieving the integers starting with 2.
Dialogue: 0,0:11:46.76,0:11:48.10,EN,,0,0,0,,So now I've got this list of primes.
Dialogue: 0,0:11:48.10,0:11:50.99,EN,,0,0,0,,That's all of the primes, right?
Dialogue: 0,0:11:50.99,0:11:53.52,EN,,0,0,0,,So, if for example, what's the 20th prime in that list?
Dialogue: 0,0:12:00.73,0:12:01.68,EN,,0,0,0,,73.
Dialogue: 0,0:12:02.54,0:12:03.34,EN,,0,0,0,,See, and that little pause,
Dialogue: 0,0:12:03.36,0:12:04.92,EN,,0,0,0,,it was only at the point
Dialogue: 0,0:12:04.94,0:12:06.43,EN,,0,0,0,,when I started asking for the 20th prime
Dialogue: 0,0:12:06.46,0:12:07.68,EN,,0,0,0,,is that it started computing.
Dialogue: 0,0:12:10.37,0:12:11.29,EN,,0,0,0,,Or I can say here
Dialogue: 0,0:12:13.80,0:12:14.88,EN,,0,0,0,,Or I can say here let's look at all of the primes.
Dialogue: 0,0:12:22.64,0:12:24.40,EN,,0,0,0,,And there it goes computing all of the primes.
Dialogue: 0,0:12:25.35,0:12:26.28,EN,,0,0,0,,Of course, it will take a while
Dialogue: 0,0:12:26.28,0:12:27.61,EN,,0,0,0,,again if I want to look at all of them,
Dialogue: 0,0:12:27.79,0:12:28.57,EN,,0,0,0,,so let's stop it.
Dialogue: 0,0:12:32.03,0:12:33.13,EN,,0,0,0,,Let me draw you a picture of that.
Dialogue: 0,0:12:33.13,0:12:34.17,EN,,0,0,0,,Well, I've got a picture of that.
Dialogue: 0,0:12:34.89,0:12:36.19,EN,,0,0,0,,What's that program really look like?
Dialogue: 0,0:12:37.90,0:12:39.77,EN,,0,0,0,,Again, some practice with these diagrams,
Dialogue: 0,0:12:39.82,0:12:40.54,EN,,0,0,0,,I have a sieve box.
Dialogue: 0,0:12:42.61,0:12:43.56,EN,,0,0,0,,How does sieve work?
Dialogue: 0,0:12:43.56,0:12:44.81,EN,,0,0,0,,It takes in a stream.
Dialogue: 0,0:12:48.85,0:12:50.59,EN,,0,0,0,,It splits off the head from the tail.
Dialogue: 0,0:12:50.87,0:12:53.26,EN,,0,0,0,,And the first thing that's going to come out of the sieve
Dialogue: 0,0:12:53.48,0:12:54.97,EN,,0,0,0,,is the head of the original stream.
Dialogue: 0,0:12:58.20,0:13:00.92,EN,,0,0,0,,Then it also takes the head and uses that.
Dialogue: 0,0:13:02.55,0:13:05.10,EN,,0,0,0,,It takes the stream. It filters the tail
Dialogue: 0,0:13:05.55,0:13:08.33,EN,,0,0,0,,It filters the tail and uses the head to filter for nondivisibility.
Dialogue: 0,0:13:09.53,0:13:11.18,EN,,0,0,0,,It takes the result of nondivisibility
Dialogue: 0,0:13:11.24,0:13:13.12,EN,,0,0,0,,and puts it through another sieve box
Dialogue: 0,0:13:13.90,0:13:15.13,EN,,0,0,0,,and puts the result together.
Dialogue: 0,0:13:15.13,0:13:16.89,EN,,0,0,0,,So you can think of this sieve a filter,
Dialogue: 0,0:13:17.20,0:13:19.23,EN,,0,0,0,,but notice that it's an infinitely recursive filter.
Dialogue: 0,0:13:19.65,0:13:20.88,EN,,0,0,0,,Because inside the sieve box
Dialogue: 0,0:13:21.52,0:13:22.60,EN,,0,0,0,,is another sieve box,
Dialogue: 0,0:13:23.37,0:13:25.85,EN,,0,0,0,,and inside that is another sieve box and another sieve box.
Dialogue: 0,0:13:27.13,0:13:28.96,EN,,0,0,0,,So you see we start getting some very powerful things.
Dialogue: 0,0:13:28.96,0:13:32.84,EN,,0,0,0,,We're starting to mix this signal processing view of the world
Dialogue: 0,0:13:33.90,0:13:36.41,EN,,0,0,0,,with things like recursion that come from computation.
Dialogue: 0,0:13:37.42,0:13:39.82,EN,,0,0,0,,And there are all sorts of interesting things you can do that are like this.
Dialogue: 0,0:13:40.97,0:13:42.09,EN,,0,0,0,,All right, any questions?
Dialogue: 0,0:13:48.19,0:13:49.16,EN,,0,0,0,,OK, let's take a break.
Dialogue: 0,0:14:28.65,0:14:30.36,EN,,0,0,0,,Well, we've been looking at a couple
Dialogue: 0,0:14:30.36,0:14:32.09,EN,,0,0,0,,of examples of stream programming.
Dialogue: 0,0:14:34.79,0:14:39.21,EN,,0,0,0,,All the stream procedures that we've looked at so far
Dialogue: 0,0:14:39.72,0:14:41.32,EN,,0,0,0,,have the same kind of character.
Dialogue: 0,0:14:41.49,0:14:43.63,EN,,0,0,0,,We've been writing these recursive procedures
Dialogue: 0,0:14:44.16,0:14:46.49,EN,,0,0,0,,that kind of generate these stream elements one at a time
Dialogue: 0,0:14:46.51,0:14:48.72,EN,,0,0,0,,and put them together in cons-streams.
Dialogue: 0,0:14:49.15,0:14:50.86,EN,,0,0,0,,So we've been thinking a lot about generators.
Dialogue: 0,0:14:50.92,0:14:53.63,EN,,0,0,0,,There's another way to think about stream processing,
Dialogue: 0,0:14:53.79,0:14:56.96,EN,,0,0,0,,and that's to focus not on programs that sort of
Dialogue: 0,0:14:57.36,0:14:59.93,EN,,0,0,0,,process these elements as you walk down the stream,
Dialogue: 0,0:15:00.25,0:15:05.68,EN,,0,0,0,,but on things that kind of process the streams all at once.
Dialogue: 0,0:15:07.18,0:15:09.16,EN,,0,0,0,,To show you what I mean, let me start by defining
Dialogue: 0,0:15:09.23,0:15:11.50,EN,,0,0,0,,two procedures that will come in handy.
Dialogue: 0,0:15:12.41,0:15:13.60,EN,,0,0,0,,The first one's called add streams.
Dialogue: 0,0:15:15.36,0:15:18.25,EN,,0,0,0,,Add streams takes two streams:
Dialogue: 0,0:15:18.81,0:15:20.88,EN,,0,0,0,,s1 and s2.
Dialogue: 0,0:15:22.30,0:15:24.67,EN,,0,0,0,,And it's going to produce a stream
Dialogue: 0,0:15:24.99,0:15:28.17,EN,,0,0,0,,whose elements are the are the corresponding sums
Dialogue: 0,0:15:30.22,0:15:31.88,EN,,0,0,0,,We just sort of add them element-wise.
Dialogue: 0,0:15:32.97,0:15:33.95,EN,,0,0,0,,If either stream is empty,
Dialogue: 0,0:15:33.96,0:15:35.39,EN,,0,0,0,,we just return the other one.
Dialogue: 0,0:15:36.81,0:15:38.96,EN,,0,0,0,,Otherwise, we're going to make a new stream
Dialogue: 0,0:15:39.90,0:15:42.96,EN,,0,0,0,,whose head is the sum of the two heads
Dialogue: 0,0:15:44.00,0:15:44.88,EN,,0,0,0,,whose tail
Dialogue: 0,0:15:46.00,0:15:48.62,EN,,0,0,0,,is the result of recursively adding the tails.
Dialogue: 0,0:15:50.09,0:15:52.73,EN,,0,0,0,,So that will produce the element-wise sum of two streams.
Dialogue: 0,0:15:53.15,0:15:57.04,EN,,0,0,0,,And then another useful thing to have around is scale stream.
Dialogue: 0,0:15:57.50,0:16:01.66,EN,,0,0,0,,Scale stream takes some constant number in a stream s
Dialogue: 0,0:16:04.11,0:16:06.62,EN,,0,0,0,,and is going to produce the stream
Dialogue: 0,0:16:07.18,0:16:09.50,EN,,0,0,0,,of elements of s multiplied by this constant.
Dialogue: 0,0:16:09.71,0:16:11.21,EN,,0,0,0,,And that's easy, that's just a map
Dialogue: 0,0:16:12.20,0:16:16.22,EN,,0,0,0,,of the function of an element that multiplies it by the constant,
Dialogue: 0,0:16:16.35,0:16:17.80,EN,,0,0,0,,and we map that down the stream.
Dialogue: 0,0:16:20.06,0:16:21.47,EN,,0,0,0,,So given those two,
Dialogue: 0,0:16:22.64,0:16:24.36,EN,,0,0,0,,let me show you what I mean by programs that
Dialogue: 0,0:16:24.70,0:16:27.00,EN,,0,0,0,,that operate on streams all at once.
Dialogue: 0,0:16:28.12,0:16:28.73,EN,,0,0,0,,Let's look at this.
Dialogue: 0,0:16:30.20,0:16:30.92,EN,,0,0,0,,Suppose I write this.
Dialogue: 0,0:16:31.68,0:16:52.35,EN,,0,0,0,,I say define--  I'll call it ones-- to be cons-stream of 1 onto ones.
Dialogue: 0,0:16:54.86,0:16:55.52,EN,,0,0,0,,What's that?
Dialogue: 0,0:16:56.95,0:16:58.94,EN,,0,0,0,,That's going to be an infinite stream of ones
Dialogue: 0,0:16:59.96,0:17:01.44,EN,,0,0,0,,because the first thing is 1.
Dialogue: 0,0:17:03.33,0:17:05.15,EN,,0,0,0,,And the tail of it is a thing
Dialogue: 0,0:17:05.55,0:17:06.83,EN,,0,0,0,,whose first thing is 1
Dialogue: 0,0:17:07.63,0:17:09.02,EN,,0,0,0,,whose tail is a thing
Dialogue: 0,0:17:09.12,0:17:10.24,EN,,0,0,0,,whose first thing is 1
Dialogue: 0,0:17:10.52,0:17:11.78,EN,,0,0,0,,and so on and so on.
Dialogue: 0,0:17:11.78,0:17:13.32,EN,,0,0,0,,So that's an infinite stream of ones.
Dialogue: 0,0:17:15.13,0:17:15.93,EN,,0,0,0,,And now using that,
Dialogue: 0,0:17:16.12,0:17:18.03,EN,,0,0,0,,let me give you another definition of the integers.
Dialogue: 0,0:17:19.47,0:17:27.36,EN,,0,0,0,,We can define the integers to be--
Dialogue: 0,0:17:28.24,0:17:30.76,EN,,0,0,0,,well, the first integer we'll take to be 1,
Dialogue: 0,0:17:32.75,0:17:38.57,EN,,0,0,0,,his cons-stream of 1 onto the element-wise sum
Dialogue: 0,0:17:40.22,0:17:48.27,EN,,0,0,0,,onto add streams of the integers to ones.
Dialogue: 0,0:17:55.10,0:17:56.35,EN,,0,0,0,,The integers are a thing
Dialogue: 0,0:17:57.24,0:17:59.98,EN,,0,0,0,,whose first element is 1,
Dialogue: 0,0:18:00.88,0:18:02.32,EN,,0,0,0,,and the rest of them you get
Dialogue: 0,0:18:03.12,0:18:06.14,EN,,0,0,0,,by taking those integers and incrementing each one by one.
Dialogue: 0,0:18:06.64,0:18:08.19,EN,,0,0,0,,So the second element of the integers
Dialogue: 0,0:18:08.51,0:18:11.96,EN,,0,0,0,,is the first element of the integers incremented by one.
Dialogue: 0,0:18:13.92,0:18:15.18,EN,,0,0,0,,And the rest of that is the next one,
Dialogue: 0,0:18:15.20,0:18:16.48,EN,,0,0,0,,and the third element of that
Dialogue: 0,0:18:16.62,0:18:20.41,EN,,0,0,0,,is the same as the first element of the tail of the integers
Dialogue: 0,0:18:20.84,0:18:21.96,EN,,0,0,0,,incremented by one,
Dialogue: 0,0:18:22.51,0:18:23.76,EN,,0,0,0,,which is the same as the
Dialogue: 0,0:18:25.08,0:18:28.65,EN,,0,0,0,,first element of the original integers incremented by one
Dialogue: 0,0:18:28.86,0:18:31.25,EN,,0,0,0,,and incremented by one again and so on.
Dialogue: 0,0:18:35.24,0:18:36.31,EN,,0,0,0,,That looks pretty suspicious.
Dialogue: 0,0:18:36.31,0:18:37.47,EN,,0,0,0,,See, notice that it works
Dialogue: 0,0:18:38.12,0:18:38.99,EN,,0,0,0,,because of delay.
Dialogue: 0,0:18:40.15,0:18:43.32,EN,,0,0,0,,See, this looks like-- let's take a look at ones.
Dialogue: 0,0:18:43.87,0:18:45.92,EN,,0,0,0,,This looks like it couldn't even be processed
Dialogue: 0,0:18:46.25,0:18:47.63,EN,,0,0,0,,because it's suddenly saying
Dialogue: 0,0:18:47.79,0:18:48.96,EN,,0,0,0,,in order to know what ones is,
Dialogue: 0,0:18:49.00,0:18:50.91,EN,,0,0,0,,I say it's cons-stream of something onto ones.
Dialogue: 0,0:18:51.13,0:18:52.08,EN,,0,0,0,,The reason that works
Dialogue: 0,0:18:52.09,0:18:54.04,EN,,0,0,0,,because of that very sneaky hidden delay in there.
Dialogue: 0,0:18:55.25,0:18:56.56,EN,,0,0,0,,Because what this really is,
Dialogue: 0,0:18:57.79,0:18:59.69,EN,,0,0,0,,remember, cons-stream is just an abbreviation.
Dialogue: 0,0:19:00.29,0:19:01.15,EN,,0,0,0,,This really is
Dialogue: 0,0:19:01.85,0:19:08.99,EN,,0,0,0,,cons of 1 onto delay of ones.
Dialogue: 0,0:19:12.14,0:19:13.21,EN,,0,0,0,,So how does that work?
Dialogue: 0,0:19:15.50,0:19:16.88,EN,,0,0,0,,You say I'm going to define ones.
Dialogue: 0,0:19:18.02,0:19:20.24,EN,,0,0,0,,First I see what ones is supposed to be defined as.
Dialogue: 0,0:19:20.70,0:19:23.40,EN,,0,0,0,,Well, ones is supposed to be defined as
Dialogue: 0,0:19:24.89,0:19:28.11,EN,,0,0,0,,a cons whose first part is 1
Dialogue: 0,0:19:28.32,0:19:29.45,EN,,0,0,0,,and the second part is,
Dialogue: 0,0:19:29.45,0:19:30.73,EN,,0,0,0,,well, it's a promise to compute something
Dialogue: 0,0:19:30.75,0:19:31.69,EN,,0,0,0,,that I don't worry about yet.
Dialogue: 0,0:19:32.71,0:19:34.25,EN,,0,0,0,,So it doesn't bother me that at the point
Dialogue: 0,0:19:34.28,0:19:36.30,EN,,0,0,0,,I do this definition, ones isn't defined.
Dialogue: 0,0:19:37.27,0:19:39.45,EN,,0,0,0,,Having run the definition, now ones is defined.
Dialogue: 0,0:19:40.67,0:19:42.83,EN,,0,0,0,,So that when I go and look at the tail of it, it's defined.
Dialogue: 0,0:19:44.92,0:19:46.06,EN,,0,0,0,,It's very sneaky.
Dialogue: 0,0:19:46.59,0:19:47.90,EN,,0,0,0,,And an integer is the same way.
Dialogue: 0,0:19:48.47,0:19:50.46,EN,,0,0,0,,I can refer to integers here because
Dialogue: 0,0:19:51.13,0:19:53.21,EN,,0,0,0,,hidden way down-- because of this cons-stream.
Dialogue: 0,0:19:53.85,0:19:55.24,EN,,0,0,0,,It's the cons-stream of 1
Dialogue: 0,0:19:55.37,0:19:57.05,EN,,0,0,0,,onto something that I don't worry that yet.
Dialogue: 0,0:19:57.05,0:19:59.60,EN,,0,0,0,,So I don't look at it, and I don't notice that integers isn't defined
Dialogue: 0,0:20:00.22,0:20:01.90,EN,,0,0,0,,at the point where I try and run the definition.
Dialogue: 0,0:20:06.32,0:20:08.27,EN,,0,0,0,,OK, let me draw a picture of that integers thing
Dialogue: 0,0:20:08.44,0:20:11.50,EN,,0,0,0,,because it still maybe seems a little bit shaky.
Dialogue: 0,0:20:12.43,0:20:14.72,EN,,0,0,0,,What do I do? Uh...
Dialogue: 0,0:20:15.02,0:20:16.30,EN,,0,0,0,,I've got the stream of ones,
Dialogue: 0,0:20:20.51,0:20:21.88,EN,,0,0,0,,and that sort of comes in
Dialogue: 0,0:20:23.26,0:20:24.92,EN,,0,0,0,,comes in and goes into an adder
Dialogue: 0,0:20:24.96,0:20:26.59,EN,,0,0,0,,that's going to be this add streams thing.
Dialogue: 0,0:20:29.31,0:20:35.87,EN,,0,0,0,,And that goes in-- that's going to put out the integers.
Dialogue: 0,0:20:40.76,0:20:42.70,EN,,0,0,0,,And the other thing that goes into the adder here
Dialogue: 0,0:20:44.94,0:20:46.97,EN,,0,0,0,,is the integer, so there's a little feedback loop.
Dialogue: 0,0:20:48.06,0:20:49.42,EN,,0,0,0,,And all I need to start it off
Dialogue: 0,0:20:50.09,0:20:52.88,EN,,0,0,0,,is someplace I've got a stick that initial 1.
Dialogue: 0,0:20:57.10,0:20:58.64,EN,,0,0,0,,In a real signal processing thing,
Dialogue: 0,0:20:58.72,0:21:02.48,EN,,0,0,0,,this might be a delay element with that was initialized to 1.
Dialogue: 0,0:21:02.91,0:21:05.90,EN,,0,0,0,,But there's a picture of that ones program.
Dialogue: 0,0:21:07.86,0:21:09.63,EN,,0,0,0,,And in fact, that looks a lot like--
Dialogue: 0,0:21:09.80,0:21:13.77,EN,,0,0,0,,if you've seen real signal block diagram things,
Dialogue: 0,0:21:13.77,0:21:16.30,EN,,0,0,0,,that looks a lot like accumulators,
Dialogue: 0,0:21:16.35,0:21:17.48,EN,,0,0,0,,finite state accumulators.
Dialogue: 0,0:21:17.98,0:21:20.06,EN,,0,0,0,,And in fact, we can modify this a little bit
Dialogue: 0,0:21:21.18,0:21:23.96,EN,,0,0,0,,to change this into something that integrates a stream
Dialogue: 0,0:21:25.37,0:21:26.97,EN,,0,0,0,,or a finite state accumulator,
Dialogue: 0,0:21:27.00,0:21:28.04,EN,,0,0,0,,however you like to think about it.
Dialogue: 0,0:21:28.44,0:21:30.86,EN,,0,0,0,,So instead of the ones coming in and getting out the integers,
Dialogue: 0,0:21:31.68,0:21:32.38,EN,,0,0,0,,what we'll do is
Dialogue: 0,0:21:32.91,0:21:34.83,EN,,0,0,0,,say there's a stream s coming in,
Dialogue: 0,0:21:35.76,0:21:40.56,EN,,0,0,0,,and we're going to get out the integral of this.
Dialogue: 0,0:21:42.60,0:21:44.09,EN,,0,0,0,,successive values of that,
Dialogue: 0,0:21:44.44,0:21:45.63,EN,,0,0,0,,and it looks almost the same.
Dialogue: 0,0:21:45.66,0:21:46.84,EN,,0,0,0,,The only thing we're going to do is
Dialogue: 0,0:21:47.02,0:21:48.08,EN,,0,0,0,,when s comes in here,
Dialogue: 0,0:21:49.21,0:21:50.64,EN,,0,0,0,,before we just add it in
Dialogue: 0,0:21:50.91,0:21:54.26,EN,,0,0,0,,we're going to multiply it by some number dt.
Dialogue: 0,0:21:57.68,0:22:00.00,EN,,0,0,0,,And now what we have here, this is exactly the same thing.
Dialogue: 0,0:22:00.00,0:22:00.91,EN,,0,0,0,,We have a box,
Dialogue: 0,0:22:03.36,0:22:04.56,EN,,0,0,0,,which is an integrator.
Dialogue: 0,0:22:09.79,0:22:11.26,EN,,0,0,0,,And it takes in a stream s,
Dialogue: 0,0:22:11.90,0:22:14.51,EN,,0,0,0,,and instead of 1 here,
Dialogue: 0,0:22:14.94,0:22:18.35,EN,,0,0,0,,we can put the additional value for the integral.
Dialogue: 0,0:22:19.98,0:22:21.60,EN,,0,0,0,,And that one looks very much like a
Dialogue: 0,0:22:22.35,0:22:24.86,EN,,0,0,0,,a signal processing block diagram program.
Dialogue: 0,0:22:25.27,0:22:28.11,EN,,0,0,0,,In fact, here's the procedure that looks exactly like that.
Dialogue: 0,0:22:31.49,0:22:33.61,EN,,0,0,0,,Find the integral of a stream.
Dialogue: 0,0:22:34.01,0:22:35.48,EN,,0,0,0,,So an integral's going to take a stream
Dialogue: 0,0:22:35.68,0:22:36.86,EN,,0,0,0,,Sand produce a new stream,
Dialogue: 0,0:22:37.53,0:22:40.67,EN,,0,0,0,,and it takes in an initial value and some time constant.
Dialogue: 0,0:22:42.23,0:22:42.97,EN,,0,0,0,,And what do we do?
Dialogue: 0,0:22:43.04,0:22:45.05,EN,,0,0,0,,Well, we internally define this thing int,
Dialogue: 0,0:22:45.20,0:22:46.32,EN,,0,0,0,,and we make this internal name
Dialogue: 0,0:22:46.33,0:22:48.86,EN,,0,0,0,,so we can feed it back, loop it around itself.
Dialogue: 0,0:22:49.40,0:22:50.80,EN,,0,0,0,,And int is defined to be
Dialogue: 0,0:22:51.10,0:22:53.32,EN,,0,0,0,,something that starts out at the initial value,
Dialogue: 0,0:22:54.97,0:23:00.14,EN,,0,0,0,,and the rest of it is gotten by adding together.
Dialogue: 0,0:23:01.28,0:23:03.61,EN,,0,0,0,,We take our input stream, scale it by dt,
Dialogue: 0,0:23:03.87,0:23:04.92,EN,,0,0,0,,and add that to int.
Dialogue: 0,0:23:06.88,0:23:09.66,EN,,0,0,0,,And now we'll return from all that the value of integral is this thing int.
Dialogue: 0,0:23:10.69,0:23:12.94,EN,,0,0,0,,And we use this internal definition syntax so we could
Dialogue: 0,0:23:13.34,0:23:15.66,EN,,0,0,0,,write a little internal definition that refers to itself.
Dialogue: 0,0:23:21.88,0:23:23.71,EN,,0,0,0,,Well, there are all sorts of things we can do.
Dialogue: 0,0:23:23.71,0:23:24.51,EN,,0,0,0,,Let's try this one.
Dialogue: 0,0:23:25.63,0:23:26.89,EN,,0,0,0,,how about the Fibonacci numbers.
Dialogue: 0,0:23:26.89,0:23:32.62,EN,,0,0,0,,You can say define fibs.
Dialogue: 0,0:23:36.35,0:23:37.63,EN,,0,0,0,,Well, what are the Fibonacci numbers?
Dialogue: 0,0:23:37.98,0:23:46.54,EN,,0,0,0,,They're something that starts out with 0,
Dialogue: 0,0:23:48.65,0:23:50.09,EN,,0,0,0,,and the next one is 1.
Dialogue: 0,0:23:56.26,0:23:59.16,EN,,0,0,0,,And the rest of the Fibonacci numbers are gotten by
Dialogue: 0,0:23:59.87,0:24:11.00,EN,,0,0,0,,adding the Fibonacci numbers to their own tail.
Dialogue: 0,0:24:17.57,0:24:19.28,EN,,0,0,0,,There's a definition of the Fibonacci numbers.
Dialogue: 0,0:24:20.58,0:24:21.43,EN,,0,0,0,,How does that work?
Dialogue: 0,0:24:21.43,0:24:24.19,EN,,0,0,0,,Well, we start off,
Dialogue: 0,0:24:24.20,0:24:26.49,EN,,0,0,0,,and someone says compute for us the Fibonacci numbers,
Dialogue: 0,0:24:29.64,0:24:31.92,EN,,0,0,0,,and we're going to tell you it starts out with 0 and 1.
Dialogue: 0,0:24:35.79,0:24:38.22,EN,,0,0,0,,And everything after the 0 and 1
Dialogue: 0,0:24:39.18,0:24:40.86,EN,,0,0,0,,is gotten by summing two streams.
Dialogue: 0,0:24:41.12,0:24:42.59,EN,,0,0,0,,One is the fibs themselves,
Dialogue: 0,0:24:44.06,0:24:45.69,EN,,0,0,0,,and the other one is the tail of the fibs.
Dialogue: 0,0:24:49.12,0:24:51.16,EN,,0,0,0,,So if I know that these start out with 0 and 1,
Dialogue: 0,0:24:51.79,0:24:55.42,EN,,0,0,0,,I know that the fibs now start out with 0 and 1,
Dialogue: 0,0:24:55.74,0:24:57.40,EN,,0,0,0,,and the tail of the fibs start out with 1.
Dialogue: 0,0:24:58.36,0:24:59.45,EN,,0,0,0,,So as soon as I know that,
Dialogue: 0,0:24:59.66,0:25:02.11,EN,,0,0,0,,I know that the next one here is 0 plus 1 is 1,
Dialogue: 0,0:25:02.96,0:25:04.60,EN,,0,0,0,,and that tells me that the next one here is 1
Dialogue: 0,0:25:04.62,0:25:05.72,EN,,0,0,0,,and the next one here is 1.
Dialogue: 0,0:25:06.30,0:25:07.28,EN,,0,0,0,,And as soon as I know that,
Dialogue: 0,0:25:07.29,0:25:08.76,EN,,0,0,0,,I know that the next one is 2.
Dialogue: 0,0:25:09.39,0:25:11.70,EN,,0,0,0,,So the next one here is 2 and the next one here is 2.
Dialogue: 0,0:25:11.70,0:25:12.56,EN,,0,0,0,,And this is 3.
Dialogue: 0,0:25:14.72,0:25:15.79,EN,,0,0,0,,This one goes to 3,
Dialogue: 0,0:25:16.19,0:25:17.13,EN,,0,0,0,,and this is 5.
Dialogue: 0,0:25:18.67,0:25:19.96,EN,,0,0,0,,So it's a perfectly sensible definition.
Dialogue: 0,0:25:21.50,0:25:22.78,EN,,0,0,0,,It's a one-line definition.
Dialogue: 0,0:25:22.83,0:25:25.00,EN,,0,0,0,,And again, I could walk over to the computer
Dialogue: 0,0:25:25.00,0:25:26.62,EN,,0,0,0,,and type that in, exactly that,
Dialogue: 0,0:25:27.04,0:25:28.94,EN,,0,0,0,,and then say print stream the Fibonacci numbers,
Dialogue: 0,0:25:28.94,0:25:30.15,EN,,0,0,0,,and they all come flying out.
Dialogue: 0,0:25:32.79,0:25:35.20,EN,,0,0,0,,See, this is a lot like learning about recursion again.
Dialogue: 0,0:25:36.81,0:25:39.79,EN,,0,0,0,,Instead of thinking that recursive procedures,
Dialogue: 0,0:25:40.99,0:25:43.50,EN,,0,0,0,,we have recursively defined data objects.
Dialogue: 0,0:25:45.16,0:25:46.92,EN,,0,0,0,,But that shouldn't surprise you at all,
Dialogue: 0,0:25:47.12,0:25:49.50,EN,,0,0,0,,because by now, you should be coming to really believe
Dialogue: 0,0:25:49.52,0:25:53.05,EN,,0,0,0,,that there's no difference really between procedures and data.
Dialogue: 0,0:25:53.09,0:25:53.92,EN,,0,0,0,,In fact, in some sense,
Dialogue: 0,0:25:53.93,0:25:56.41,EN,,0,0,0,,the underlying streams are procedures sitting there,
Dialogue: 0,0:25:56.43,0:25:57.79,EN,,0,0,0,,although we don't think of them that way.
Dialogue: 0,0:25:58.21,0:26:00.38,EN,,0,0,0,,So the fact that we have recursive procedures,
Dialogue: 0,0:26:00.70,0:26:03.63,EN,,0,0,0,,well, then it should be natural that we have recursive data, too.
Dialogue: 0,0:26:07.72,0:26:09.69,EN,,0,0,0,,OK, well, this is all pretty neat.
Dialogue: 0,0:26:09.72,0:26:13.92,EN,,0,0,0,,Unfortunately, there are problems that streams aren't going to solve.
Dialogue: 0,0:26:14.99,0:26:16.48,EN,,0,0,0,,Let me show you one of them.
Dialogue: 0,0:26:17.58,0:26:20.35,EN,,0,0,0,,See, in the same way, let's imagine that we're
Dialogue: 0,0:26:20.76,0:26:23.61,EN,,0,0,0,,building an analog computer to solve some differential equation
Dialogue: 0,0:26:25.20,0:26:34.30,EN,,0,0,0,,like, say, we want to solve the equation y prime dy dt is y squared,
Dialogue: 0,0:26:34.76,0:26:36.16,EN,,0,0,0,,and I'm going to give you some initial value.
Dialogue: 0,0:26:36.39,0:26:38.03,EN,,0,0,0,,I'll tell you y of 0 equals 1.
Dialogue: 0,0:26:41.48,0:26:44.06,EN,,0,0,0,,Let's say dt is equal to something.
Dialogue: 0,0:26:46.77,0:26:47.53,EN,,0,0,0,,Now, in the old days,
Dialogue: 0,0:26:48.00,0:26:50.65,EN,,0,0,0,,people built analog computers to solve these kinds of things.
Dialogue: 0,0:26:51.36,0:26:53.02,EN,,0,0,0,,And the way you do that is really simple.
Dialogue: 0,0:26:53.02,0:26:54.41,EN,,0,0,0,,You get yourself an integrator,
Dialogue: 0,0:27:00.04,0:27:01.69,EN,,0,0,0,,like that one, an integrator box.
Dialogue: 0,0:27:03.05,0:27:06.48,EN,,0,0,0,,And we put in the initial value y of 0 is 1.
Dialogue: 0,0:27:08.53,0:27:10.92,EN,,0,0,0,,And now if we feed something in and get something out,
Dialogue: 0,0:27:10.96,0:27:13.16,EN,,0,0,0,,we'll say, gee, what we're getting out is the answer.
Dialogue: 0,0:27:14.25,0:27:16.96,EN,,0,0,0,,And what we're going to feed in is the derivative,
Dialogue: 0,0:27:17.52,0:27:20.52,EN,,0,0,0,,and the derivative is supposed to be the square of the answer.
Dialogue: 0,0:27:21.49,0:27:27.07,EN,,0,0,0,,So if we take these values and map using square,
Dialogue: 0,0:27:30.73,0:27:32.09,EN,,0,0,0,,and if I feed this around,
Dialogue: 0,0:27:36.28,0:27:38.48,EN,,0,0,0,,that's how I build a block diagram
Dialogue: 0,0:27:38.57,0:27:41.08,EN,,0,0,0,,for an analog computer that solves this differential equation.
Dialogue: 0,0:27:42.91,0:27:44.80,EN,,0,0,0,,Now, what we'd like to do is write a stream
Dialogue: 0,0:27:44.80,0:27:46.78,EN,,0,0,0,,program that looks exactly like that.
Dialogue: 0,0:27:47.23,0:27:48.72,EN,,0,0,0,,And what do I mean exactly like that?
Dialogue: 0,0:27:49.39,0:27:58.30,EN,,0,0,0,,Well, I'd say define y to be the integral
Dialogue: 0,0:28:04.28,0:28:11.68,EN,,0,0,0,,of dy starting at 1 with 0.001 as a time step.
Dialogue: 0,0:28:13.79,0:28:15.45,EN,,0,0,0,,And I'd like to say that says this.
Dialogue: 0,0:28:16.80,0:28:20.85,EN,,0,0,0,,And then I'd like to say, well, dy is gotten by mapping the square along y.
Dialogue: 0,0:28:20.85,0:28:32.81,EN,,0,0,0,,So define dy to be map square along y.
Dialogue: 0,0:28:33.51,0:28:36.80,EN,,0,0,0,,So there's a stream description of this analog computer,
Dialogue: 0,0:28:38.62,0:28:40.32,EN,,0,0,0,,and unfortunately, it doesn't work.
Dialogue: 0,0:28:41.41,0:28:42.67,EN,,0,0,0,,And you can see why it doesn't work
Dialogue: 0,0:28:42.97,0:28:44.99,EN,,0,0,0,,because when I come in and say define y
Dialogue: 0,0:28:46.43,0:28:47.85,EN,,0,0,0,,to be the integral of dy
Dialogue: 0,0:28:49.04,0:28:50.65,EN,,0,0,0,,it says, oh, the integral of what-- huh?
Dialogue: 0,0:28:51.19,0:28:52.12,EN,,0,0,0,,Oh, that's undefined.
Dialogue: 0,0:28:53.71,0:28:57.63,EN,,0,0,0,,So I can't write this definition before I've written this one.
Dialogue: 0,0:28:58.77,0:29:00.51,EN,,0,0,0,,On the other hand, if I try and write this one first,
Dialogue: 0,0:29:00.51,0:29:03.02,EN,,0,0,0,,it says, oh, I define y to be the map of square along what?
Dialogue: 0,0:29:03.58,0:29:04.64,EN,,0,0,0,,Oh, that's not defined yet.
Dialogue: 0,0:29:05.77,0:29:08.17,EN,,0,0,0,,So I can't write this one first, and I can't write that one first.
Dialogue: 0,0:29:09.08,0:29:11.58,EN,,0,0,0,,So I can't quite play this game.
Dialogue: 0,0:29:17.56,0:29:18.51,EN,,0,0,0,,Well, is there a way out?
Dialogue: 0,0:29:20.60,0:29:21.84,EN,,0,0,0,,See, we can do that with ones.
Dialogue: 0,0:29:22.20,0:29:25.82,EN,,0,0,0,,See, over here, we did this thing ones,
Dialogue: 0,0:29:27.24,0:29:29.90,EN,,0,0,0,,and we were able to define ones in terms of ones because
Dialogue: 0,0:29:30.40,0:29:32.03,EN,,0,0,0,,of this delay that was built inside
Dialogue: 0,0:29:32.43,0:29:34.12,EN,,0,0,0,,because cons-stream had a delay.
Dialogue: 0,0:29:34.77,0:29:35.79,EN,,0,0,0,,Now, why's it sensible?
Dialogue: 0,0:29:35.92,0:29:38.51,EN,,0,0,0,,Why's it sensible for cons-stream to be built with this delay?
Dialogue: 0,0:29:40.73,0:29:43.13,EN,,0,0,0,,The reason is that cons-stream can do a useful thing
Dialogue: 0,0:29:43.48,0:29:44.88,EN,,0,0,0,,without looking at its tail.
Dialogue: 0,0:29:45.95,0:29:46.84,EN,,0,0,0,,See, if I say
Dialogue: 0,0:29:47.48,0:29:49.64,EN,,0,0,0,,this is cons-stream of 1 onto something
Dialogue: 0,0:29:49.92,0:29:51.69,EN,,0,0,0,,without knowing anything about something,
Dialogue: 0,0:29:52.16,0:29:54.03,EN,,0,0,0,,I know that the stream starts off with 1.
Dialogue: 0,0:29:54.87,0:29:57.29,EN,,0,0,0,,That's why it was sensible to build something like cons-stream.
Dialogue: 0,0:29:59.96,0:30:01.24,EN,,0,0,0,,So we put a delay in there,
Dialogue: 0,0:30:01.42,0:30:04.65,EN,,0,0,0,,and that allows us to have this sort of self-referential definition.
Dialogue: 0,0:30:06.32,0:30:07.95,EN,,0,0,0,,Well, integral is a little bit the same way.
Dialogue: 0,0:30:08.19,0:30:12.52,EN,,0,0,0,,See, notice for an integral, I can--
Dialogue: 0,0:30:14.60,0:30:16.08,EN,,0,0,0,,let's go back and look at integral for a second.
Dialogue: 0,0:30:17.58,0:30:18.56,EN,,0,0,0,,See, notice integral,
Dialogue: 0,0:30:21.39,0:30:25.00,EN,,0,0,0,,it makes sense to say what's the first thing in the integral
Dialogue: 0,0:30:26.04,0:30:27.87,EN,,0,0,0,,without knowing the stream that you're integrating.
Dialogue: 0,0:30:28.97,0:30:30.17,EN,,0,0,0,,Because the first thing in the integral
Dialogue: 0,0:30:30.20,0:30:32.16,EN,,0,0,0,,is always going to be the initial value that you're handed.
Dialogue: 0,0:30:33.14,0:30:36.11,EN,,0,0,0,,So integral could be a procedure like cons-stream.
Dialogue: 0,0:30:37.09,0:30:37.98,EN,,0,0,0,,You could define it,
Dialogue: 0,0:30:38.25,0:30:40.88,EN,,0,0,0,,and then even before it knows what it's supposed to be integrating,
Dialogue: 0,0:30:42.84,0:30:45.18,EN,,0,0,0,,it knows enough to say what its initial value is.
Dialogue: 0,0:30:46.71,0:30:48.17,EN,,0,0,0,,So we can make a smarter integral,
Dialogue: 0,0:30:48.41,0:30:50.68,EN,,0,0,0,,which is aha, you're going to give me a stream to integrate
Dialogue: 0,0:30:50.83,0:30:51.92,EN,,0,0,0,,and an initial value,
Dialogue: 0,0:30:52.11,0:30:54.99,EN,,0,0,0,,but I really don't have to look at that stream that I'm supposed to integrate
Dialogue: 0,0:30:55.21,0:30:56.97,EN,,0,0,0,,until you ask me to work down the stream.
Dialogue: 0,0:30:58.43,0:31:00.51,EN,,0,0,0,,In other words, integral can be like cons-stream,
Dialogue: 0,0:31:00.57,0:31:03.74,EN,,0,0,0,,and you can expect that there's going to be a delay around its integrand.
Dialogue: 0,0:31:03.76,0:31:04.86,EN,,0,0,0,,And we can write that.
Dialogue: 0,0:31:05.61,0:31:07.02,EN,,0,0,0,,Here's a procedure that does that.
Dialogue: 0,0:31:07.65,0:31:08.75,EN,,0,0,0,,Another version of integral,
Dialogue: 0,0:31:08.89,0:31:10.54,EN,,0,0,0,,and this is almost like the previous one,
Dialogue: 0,0:31:11.10,0:31:13.34,EN,,0,0,0,,except the stream it's going to get in
Dialogue: 0,0:31:13.77,0:31:15.69,EN,,0,0,0,,is going to expect to be a delayed object.
Dialogue: 0,0:31:17.11,0:31:18.43,EN,,0,0,0,,And how does this integral work?
Dialogue: 0,0:31:18.85,0:31:21.79,EN,,0,0,0,,Well, the little thing it's going to define inside of itself
Dialogue: 0,0:31:22.14,0:31:24.19,EN,,0,0,0,,says on the cons-stream,
Dialogue: 0,0:31:24.73,0:31:26.44,EN,,0,0,0,,the initial value is the initial value,
Dialogue: 0,0:31:27.16,0:31:29.68,EN,,0,0,0,,but only inside of that cons-stream,
Dialogue: 0,0:31:29.74,0:31:32.30,EN,,0,0,0,,and remember, there's going to be a hidden delay inside here.
Dialogue: 0,0:31:34.95,0:31:39.07,EN,,0,0,0,,Only inside of that cons-stream will I start looking at
Dialogue: 0,0:31:39.82,0:31:42.11,EN,,0,0,0,,what the actual delayed object is.
Dialogue: 0,0:31:43.18,0:31:45.79,EN,,0,0,0,,So my answer is the first thing's the initial value.
Dialogue: 0,0:31:45.97,0:31:47.90,EN,,0,0,0,,If anybody now asks me for my tail,
Dialogue: 0,0:31:48.40,0:31:49.42,EN,,0,0,0,,at that point,
Dialogue: 0,0:31:50.00,0:31:51.72,EN,,0,0,0,,I'm going to force that delayed object--
Dialogue: 0,0:31:52.62,0:31:53.60,EN,,0,0,0,,and I'll call that s--
Dialogue: 0,0:31:54.44,0:31:55.60,EN,,0,0,0,,and I do the add streams.
Dialogue: 0,0:31:56.36,0:31:59.26,EN,,0,0,0,,So this is an integral which is sort of like cons-stream.
Dialogue: 0,0:31:59.26,0:32:02.59,EN,,0,0,0,,It's not going to actually try and see what you handed it
Dialogue: 0,0:32:03.88,0:32:07.13,EN,,0,0,0,,as the thing to integrate until you look past the first element.
Dialogue: 0,0:32:10.12,0:32:11.02,EN,,0,0,0,,And if we do that
Dialogue: 0,0:32:11.52,0:32:12.83,EN,,0,0,0,,and we can make this work,
Dialogue: 0,0:32:13.36,0:32:15.20,EN,,0,0,0,,all we have to do here is
Dialogue: 0,0:32:16.00,0:32:25.31,EN,,0,0,0,,define y to the integral of delay of y, of delay of dy.
Dialogue: 0,0:32:27.09,0:32:28.22,EN,,0,0,0,,So y is going to be
Dialogue: 0,0:32:28.40,0:32:34.36,EN,,0,0,0,,the integral of delay of dy starting at 1,
Dialogue: 0,0:32:34.38,0:32:35.13,EN,,0,0,0,,and now this will work.
Dialogue: 0,0:32:35.28,0:32:37.44,EN,,0,0,0,,Because I type in the definition of y,
Dialogue: 0,0:32:38.00,0:32:39.68,EN,,0,0,0,,and that says, oh, I'm supposed to use the integral of
Dialogue: 0,0:32:40.20,0:32:42.68,EN,,0,0,0,,something I don't care about right now because it's a delay.
Dialogue: 0,0:32:44.60,0:32:46.32,EN,,0,0,0,,And these things, now you define dy.
Dialogue: 0,0:32:46.32,0:32:47.37,EN,,0,0,0,,Now, y is defined.
Dialogue: 0,0:32:47.55,0:32:48.89,EN,,0,0,0,,So when I define dy,
Dialogue: 0,0:32:49.13,0:32:50.67,EN,,0,0,0,,it can see that definition for y.
Dialogue: 0,0:32:51.70,0:32:52.84,EN,,0,0,0,,Everything is now started up.
Dialogue: 0,0:32:52.84,0:32:54.33,EN,,0,0,0,,Both streams have their first element.
Dialogue: 0,0:32:54.92,0:32:56.25,EN,,0,0,0,,And then when I start mapping down,
Dialogue: 0,0:32:56.27,0:32:57.31,EN,,0,0,0,,looking at successive elements,
Dialogue: 0,0:32:57.37,0:32:58.88,EN,,0,0,0,,both y and dy are defined.
Dialogue: 0,0:33:00.59,0:33:04.24,EN,,0,0,0,,So there's a little game you can play that goes a little bit beyond
Dialogue: 0,0:33:04.67,0:33:07.13,EN,,0,0,0,,just using the delay that's hidden inside streams.
Dialogue: 0,0:33:08.36,0:33:08.97,EN,,0,0,0,,Questions?
Dialogue: 0,0:33:13.52,0:33:14.27,EN,,0,0,0,,OK, let's take a break.
Dialogue: 0,0:34:07.30,0:34:10.04,EN,,0,0,0,,Well, just before the break, um..
Dialogue: 0,0:34:10.89,0:34:11.80,EN,,0,0,0,,I'm not sure if you noticed it,
Dialogue: 0,0:34:11.82,0:34:13.55,EN,,0,0,0,,but something nasty started to happen.
Dialogue: 0,0:34:14.83,0:34:18.40,EN,,0,0,0,,We've been going along with the streams
Dialogue: 0,0:34:19.16,0:34:22.68,EN,,0,0,0,,and divorcing time in the programs from time in the computers,
Dialogue: 0,0:34:22.86,0:34:26.28,EN,,0,0,0,,and all that divorcing got hidden inside the streams.
Dialogue: 0,0:34:27.28,0:34:29.50,EN,,0,0,0,,And then at the very end, we saw that sometimes
Dialogue: 0,0:34:29.71,0:34:32.19,EN,,0,0,0,,in order to really take advantage of this method,
Dialogue: 0,0:34:32.22,0:34:34.38,EN,,0,0,0,,you have to pull out other delays.
Dialogue: 0,0:34:34.38,0:34:35.85,EN,,0,0,0,,You have to write some explicit delays
Dialogue: 0,0:34:36.09,0:34:37.95,EN,,0,0,0,,that are not hidden inside that cons-stream.
Dialogue: 0,0:34:39.03,0:34:41.88,EN,,0,0,0,,And I did a very simple example with differential equations,
Dialogue: 0,0:34:42.35,0:34:44.08,EN,,0,0,0,,but if you have some very complicated system
Dialogue: 0,0:34:44.12,0:34:45.40,EN,,0,0,0,,with all kinds of self-loops,
Dialogue: 0,0:34:45.95,0:34:47.84,EN,,0,0,0,,it becomes very, very difficult to
Dialogue: 0,0:34:47.90,0:34:49.31,EN,,0,0,0,,see where you need those delays.
Dialogue: 0,0:34:49.92,0:34:51.18,EN,,0,0,0,,And if you leave them out by mistake,
Dialogue: 0,0:34:51.45,0:34:54.36,EN,,0,0,0,,it becomes very, very difficult to see why the thing maybe isn't working.
Dialogue: 0,0:34:55.55,0:34:57.15,EN,,0,0,0,,So that's kind of mess,
Dialogue: 0,0:34:57.79,0:35:01.71,EN,,0,0,0,,that by getting this power and allowing us to use delay,
Dialogue: 0,0:35:02.08,0:35:04.70,EN,,0,0,0,,we end up with some very complicated programming sometimes,
Dialogue: 0,0:35:04.72,0:35:06.80,EN,,0,0,0,,because it can't all be hidden inside the streams.
Dialogue: 0,0:35:08.51,0:35:09.79,EN,,0,0,0,,Well, is there a way out of that?
Dialogue: 0,0:35:11.13,0:35:12.67,EN,,0,0,0,,Yeah, there is a way out of that.
Dialogue: 0,0:35:13.48,0:35:16.08,EN,,0,0,0,,We could change the language so that
Dialogue: 0,0:35:16.14,0:35:18.19,EN,,0,0,0,,all procedures acted like cons-stream,
Dialogue: 0,0:35:19.10,0:35:21.48,EN,,0,0,0,,so that every procedure automatically
Dialogue: 0,0:35:22.32,0:35:25.45,EN,,0,0,0,,has an implicit delay around its arguments.
Dialogue: 0,0:35:25.45,0:35:26.43,EN,,0,0,0,,And what would that mean?
Dialogue: 0,0:35:27.52,0:35:29.53,EN,,0,0,0,,That would mean when you call a procedure,
Dialogue: 0,0:35:30.16,0:35:31.88,EN,,0,0,0,,the arguments wouldn't get evaluated.
Dialogue: 0,0:35:32.21,0:35:34.70,EN,,0,0,0,,Instead, they'd only be evaluated when you need them,
Dialogue: 0,0:35:34.89,0:35:36.72,EN,,0,0,0,,so they might be passed off to some other procedure,
Dialogue: 0,0:35:36.76,0:35:38.12,EN,,0,0,0,,which wouldn't evaluate them either.
Dialogue: 0,0:35:39.26,0:35:41.90,EN,,0,0,0,,So all these procedures would be passing promises around.
Dialogue: 0,0:35:42.15,0:35:44.46,EN,,0,0,0,,And then finally maybe when you finally got down
Dialogue: 0,0:35:44.65,0:35:47.34,EN,,0,0,0,,to having to look at the value of something
Dialogue: 0,0:35:47.36,0:35:48.99,EN,,0,0,0,,that was handed to a primitive operator
Dialogue: 0,0:35:49.37,0:35:51.48,EN,,0,0,0,,which you actually start calling in all those promises.
Dialogue: 0,0:35:52.38,0:35:53.16,EN,,0,0,0,,If we did that,
Dialogue: 0,0:35:53.36,0:35:55.37,EN,,0,0,0,,since everything would have a uniform delay,
Dialogue: 0,0:35:57.16,0:35:59.00,EN,,0,0,0,,then you wouldn't have to write any explicit delays,
Dialogue: 0,0:35:59.04,0:36:01.55,EN,,0,0,0,,because it would be automatically built into the way the language works.
Dialogue: 0,0:36:03.24,0:36:04.38,EN,,0,0,0,,Or another way to say that,
Dialogue: 0,0:36:05.10,0:36:08.14,EN,,0,0,0,,technically what I'm describing is what's called
Dialogue: 0,0:36:09.02,0:36:10.76,EN,,0,0,0,,if we did that, our language would be
Dialogue: 0,0:36:12.19,0:36:16.57,EN,,0,0,0,,so-called normal-order evaluation language
Dialogue: 0,0:36:20.20,0:36:23.47,EN,,0,0,0,,versus what we've actually been working with,
Dialogue: 0,0:36:23.87,0:36:33.79,EN,,0,0,0,,which is called applicative order--  versus applicative-order evaluation.
Dialogue: 0,0:36:34.56,0:36:36.83,EN,,0,0,0,,And remember the substitution model for applicative order.
Dialogue: 0,0:36:36.83,0:36:40.49,EN,,0,0,0,,It says when you go and evaluate a combination,
Dialogue: 0,0:36:40.51,0:36:42.11,EN,,0,0,0,,you find the values of all the pieces.
Dialogue: 0,0:36:43.59,0:36:45.40,EN,,0,0,0,,You evaluate the arguments and then you
Dialogue: 0,0:36:45.72,0:36:47.42,EN,,0,0,0,,substitute them in the body of the procedure.
Dialogue: 0,0:36:47.60,0:36:49.55,EN,,0,0,0,,Normal order says no, don't do that.
Dialogue: 0,0:36:49.89,0:36:51.90,EN,,0,0,0,,What you do is effectively
Dialogue: 0,0:36:52.76,0:36:54.41,EN,,0,0,0,,substitute in the body of the procedure,
Dialogue: 0,0:36:54.44,0:36:56.19,EN,,0,0,0,,but instead of evaluating the arguments,
Dialogue: 0,0:36:56.54,0:36:58.08,EN,,0,0,0,,you just put a promise to compute them there.
Dialogue: 0,0:36:58.81,0:36:59.90,EN,,0,0,0,,Or another way to say that
Dialogue: 0,0:36:59.92,0:37:02.09,EN,,0,0,0,,you take the expressions for the arguments, if you like,
Dialogue: 0,0:37:02.28,0:37:04.84,EN,,0,0,0,,and substitute them in the body of the procedure and go on,
Dialogue: 0,0:37:05.16,0:37:06.88,EN,,0,0,0,,and never really simplify anything
Dialogue: 0,0:37:07.16,0:37:08.76,EN,,0,0,0,,until you get down to a primitive operator.
Dialogue: 0,0:37:09.47,0:37:10.99,EN,,0,0,0,,So that would be a normal-order language.
Dialogue: 0,0:37:12.17,0:37:13.12,EN,,0,0,0,,Well, why don't we do that?
Dialogue: 0,0:37:13.82,0:37:14.60,EN,,0,0,0,,Because if we did,
Dialogue: 0,0:37:15.00,0:37:17.34,EN,,0,0,0,,we'd get all the advantages of delayed evaluation
Dialogue: 0,0:37:17.90,0:37:18.80,EN,,0,0,0,,with none of the mess.
Dialogue: 0,0:37:18.94,0:37:20.19,EN,,0,0,0,,In fact, if we did that
Dialogue: 0,0:37:20.43,0:37:22.67,EN,,0,0,0,,and cons was just a delayed procedure,
Dialogue: 0,0:37:22.68,0:37:24.57,EN,,0,0,0,,that would make cons the same as cons-stream.
Dialogue: 0,0:37:24.71,0:37:25.82,EN,,0,0,0,,We wouldn't need streams at all
Dialogue: 0,0:37:26.36,0:37:28.54,EN,,0,0,0,,because lists would automatically be streams.
Dialogue: 0,0:37:29.55,0:37:30.70,EN,,0,0,0,,That's how lists would behave,
Dialogue: 0,0:37:30.75,0:37:32.35,EN,,0,0,0,,all data structures would behave that way.
Dialogue: 0,0:37:32.35,0:37:33.64,EN,,0,0,0,,Everything would behave that way.
Dialogue: 0,0:37:35.07,0:37:37.63,EN,,0,0,0,,Right, You'd never really do any computation
Dialogue: 0,0:37:37.66,0:37:39.42,EN,,0,0,0,,until you actually needed the answer.
Dialogue: 0,0:37:40.80,0:37:43.58,EN,,0,0,0,,You wouldn't have to worry about all these explicit annoying delays.
Dialogue: 0,0:37:44.79,0:37:46.16,EN,,0,0,0,,Well, why don't we do that?
Dialogue: 0,0:37:47.16,0:37:48.81,EN,,0,0,0,,First of all, I should say people do do that.
Dialogue: 0,0:37:49.23,0:37:51.85,EN,,0,0,0,,There's some very beautiful languages.
Dialogue: 0,0:37:51.85,0:37:55.21,EN,,0,0,0,,One of the very nicest is a language called Miranda,
Dialogue: 0,0:37:55.77,0:37:56.76,EN,,0,0,0,,which is, um..
Dialogue: 0,0:37:57.44,0:37:59.80,EN,,0,0,0,,developed by David Turner at the University of Kent.
Dialogue: 0,0:38:00.71,0:38:01.93,EN,,0,0,0,,And that's how this language works.
Dialogue: 0,0:38:01.93,0:38:03.34,EN,,0,0,0,,It's a normal-order language
Dialogue: 0,0:38:04.27,0:38:05.55,EN,,0,0,0,,and its data structures,
Dialogue: 0,0:38:06.16,0:38:08.41,EN,,0,0,0,,which look like lists, are actually streams.
Dialogue: 0,0:38:08.96,0:38:10.91,EN,,0,0,0,,And you write ordinary procedures in Miranda,
Dialogue: 0,0:38:11.28,0:38:13.28,EN,,0,0,0,,and they do these prime things and eight queens things,
Dialogue: 0,0:38:13.32,0:38:14.97,EN,,0,0,0,,just without anything special.
Dialogue: 0,0:38:14.97,0:38:16.35,EN,,0,0,0,,It's all built in there.
Dialogue: 0,0:38:17.93,0:38:18.91,EN,,0,0,0,,But there's a price.
Dialogue: 0,0:38:21.19,0:38:22.36,EN,,0,0,0,,Remember how we got here.
Dialogue: 0,0:38:23.17,0:38:27.48,EN,,0,0,0,,We're decoupling time in the programs from time in the machines.
Dialogue: 0,0:38:27.96,0:38:28.88,EN,,0,0,0,,And if we put delay,
Dialogue: 0,0:38:29.04,0:38:30.33,EN,,0,0,0,,that sort of decouples it everywhere,
Dialogue: 0,0:38:30.40,0:38:31.42,EN,,0,0,0,,not just in streams.
Dialogue: 0,0:38:32.19,0:38:33.14,EN,,0,0,0,,Remember what we're trying to do.
Dialogue: 0,0:38:33.14,0:38:38.11,EN,,0,0,0,,We're trying to think about programming as a way to specify processes.
Dialogue: 0,0:38:39.30,0:38:40.62,EN,,0,0,0,,And if we give up too much time,
Dialogue: 0,0:38:40.65,0:38:42.41,EN,,0,0,0,,our language becomes more elegant,
Dialogue: 0,0:38:43.74,0:38:45.87,EN,,0,0,0,,but it becomes a little bit less expressive.
Dialogue: 0,0:38:47.03,0:38:49.84,EN,,0,0,0,,There are certain distinctions that we can't draw.
Dialogue: 0,0:38:51.48,0:38:53.15,EN,,0,0,0,,One of them, for instance, is iteration.
Dialogue: 0,0:38:53.98,0:38:56.44,EN,,0,0,0,,Remember this old procedure,
Dialogue: 0,0:38:56.96,0:38:58.28,EN,,0,0,0,,iterative factorial,
Dialogue: 0,0:38:58.44,0:39:00.48,EN,,0,0,0,,that we looked at quite a long time ago.
Dialogue: 0,0:39:01.23,0:39:02.97,EN,,0,0,0,,Iterative factorial had a thing,
Dialogue: 0,0:39:03.04,0:39:04.91,EN,,0,0,0,,and it said there was an internal procedure,
Dialogue: 0,0:39:05.18,0:39:07.50,EN,,0,0,0,,and there was a state which was a product and a counter,
Dialogue: 0,0:39:08.70,0:39:10.96,EN,,0,0,0,,and we iterate that going around the loop.
Dialogue: 0,0:39:12.12,0:39:13.68,EN,,0,0,0,,And we said that was an iterative procedure
Dialogue: 0,0:39:13.71,0:39:14.83,EN,,0,0,0,,because it didn't build up state.
Dialogue: 0,0:39:15.73,0:39:17.45,EN,,0,0,0,,And the reason it didn't build up state is
Dialogue: 0,0:39:17.47,0:39:20.25,EN,,0,0,0,,because this iter that's called
Dialogue: 0,0:39:20.30,0:39:22.86,EN,,0,0,0,,is just passing these things around to itself.
Dialogue: 0,0:39:23.90,0:39:25.39,EN,,0,0,0,,Or in the substitution model that,
Dialogue: 0,0:39:25.55,0:39:27.79,EN,,0,0,0,,you could see in the substitution model that Jerry did,
Dialogue: 0,0:39:28.72,0:39:30.01,EN,,0,0,0,,that in an iterative procedure,
Dialogue: 0,0:39:30.03,0:39:31.44,EN,,0,0,0,,that state doesn't have to grow.
Dialogue: 0,0:39:31.82,0:39:34.22,EN,,0,0,0,,And in fact, we said it doesn't, so this is an iteration.
Dialogue: 0,0:39:34.99,0:39:37.47,EN,,0,0,0,,But now think about this exact same text
Dialogue: 0,0:39:37.47,0:39:39.10,EN,,0,0,0,,if we had a normal-order language.
Dialogue: 0,0:39:41.15,0:39:42.17,EN,,0,0,0,,What would happen is
Dialogue: 0,0:39:42.88,0:39:44.96,EN,,0,0,0,,this would no longer be an iterative procedure
Dialogue: 0,0:39:45.65,0:39:48.67,EN,,0,0,0,,And if you really think about the details of the substitution model,
Dialogue: 0,0:39:48.67,0:39:49.90,EN,,0,0,0,,which I'm not going to do here,
Dialogue: 0,0:39:51.20,0:39:52.35,EN,,0,0,0,,this expression would grow.
Dialogue: 0,0:39:52.36,0:39:53.18,EN,,0,0,0,,Why would it grow?
Dialogue: 0,0:39:53.28,0:39:55.20,EN,,0,0,0,,It's because when iter calls itself,
Dialogue: 0,0:39:55.85,0:39:57.31,EN,,0,0,0,,it calls itself with this product.
Dialogue: 0,0:39:58.08,0:39:59.36,EN,,0,0,0,,If it's a normal-order language,
Dialogue: 0,0:39:59.39,0:40:01.16,EN,,0,0,0,,that multiplication is not going to get done.
Dialogue: 0,0:40:02.51,0:40:03.82,EN,,0,0,0,,That's going to say I'm to call myself
Dialogue: 0,0:40:03.93,0:40:05.68,EN,,0,0,0,,with a promise to compute this product.
Dialogue: 0,0:40:06.67,0:40:08.03,EN,,0,0,0,,And now iter goes around again.
Dialogue: 0,0:40:09.76,0:40:11.55,EN,,0,0,0,,And I'm going to call myself
Dialogue: 0,0:40:11.84,0:40:14.04,EN,,0,0,0,,with a promise to compute this product
Dialogue: 0,0:40:14.04,0:40:17.82,EN,,0,0,0,,where now one of the one factors is a promise.
Dialogue: 0,0:40:18.40,0:40:19.43,EN,,0,0,0,,And I call myself again.
Dialogue: 0,0:40:19.43,0:40:21.13,EN,,0,0,0,,And if you write out the substitution model
Dialogue: 0,0:40:21.98,0:40:23.60,EN,,0,0,0,,for that iterative process,
Dialogue: 0,0:40:23.77,0:40:26.83,EN,,0,0,0,,you'll see exactly the same growth in state,
Dialogue: 0,0:40:27.16,0:40:28.96,EN,,0,0,0,,all those promises that are getting remembered
Dialogue: 0,0:40:28.97,0:40:30.76,EN,,0,0,0,,that have to get called in at the very end.
Dialogue: 0,0:40:31.79,0:40:35.02,EN,,0,0,0,,So one of the disadvantages
Dialogue: 0,0:40:35.05,0:40:36.86,EN,,0,0,0,,is that you can't really express iteration.
Dialogue: 0,0:40:36.98,0:40:39.60,EN,,0,0,0,,Maybe that's a little theoretical reason why not,
Dialogue: 0,0:40:39.61,0:40:43.90,EN,,0,0,0,,but in fact, people who are trying to write real operating systems
Dialogue: 0,0:40:44.27,0:40:47.56,EN,,0,0,0,,in these languages are running into exactly these types of problems.
Dialogue: 0,0:40:48.20,0:40:50.75,EN,,0,0,0,,Like it's perfectly possible to
Dialogue: 0,0:40:51.64,0:40:54.38,EN,,0,0,0,,implement a text editor in languages like these.
Dialogue: 0,0:40:54.61,0:40:56.08,EN,,0,0,0,,But after you work a while,
Dialogue: 0,0:40:56.72,0:40:59.39,EN,,0,0,0,,you suddenly have 3 megabytes of stuff,
Dialogue: 0,0:40:59.44,0:41:02.04,EN,,0,0,0,,which is-- I guess they call them
Dialogue: 0,0:41:02.16,0:41:05.60,EN,,0,0,0,,the dragging tail problem who are looking at these,
Dialogue: 0,0:41:05.82,0:41:08.20,EN,,0,0,0,,of stuff of promises that sort of haven't been called in
Dialogue: 0,0:41:08.24,0:41:10.46,EN,,0,0,0,,because you couldn't quite express an iteration.
Dialogue: 0,0:41:10.72,0:41:14.81,EN,,0,0,0,,And one of the research questions in these kinds of languages
Dialogue: 0,0:41:14.83,0:41:17.48,EN,,0,0,0,,are figuring out the right compiler technology
Dialogue: 0,0:41:17.82,0:41:19.85,EN,,0,0,0,,to get rid of the so-called dragging tails.
Dialogue: 0,0:41:20.17,0:41:21.61,EN,,0,0,0,,It's not simple.
Dialogue: 0,0:41:23.94,0:41:27.31,EN,,0,0,0,,But there's another kind of more striking issue
Dialogue: 0,0:41:27.96,0:41:31.04,EN,,0,0,0,,about why you just don't go ahead and make your language normal order.
Dialogue: 0,0:41:32.51,0:41:33.29,EN,,0,0,0,,And the reason is
Dialogue: 0,0:41:35.05,0:41:38.09,EN,,0,0,0,,that normal-order evaluation and side effects
Dialogue: 0,0:41:38.89,0:41:40.19,EN,,0,0,0,,just don't mix.
Dialogue: 0,0:41:42.00,0:41:43.96,EN,,0,0,0,,They just don't go together very well.
Dialogue: 0,0:41:45.44,0:41:46.65,EN,,0,0,0,,Somehow, you can't-
Dialogue: 0,0:41:48.28,0:41:50.80,EN,,0,0,0,,it's sort of you can't simultaneously
Dialogue: 0,0:41:51.00,0:41:54.33,EN,,0,0,0,,go around trying to model objects with local state and change
Dialogue: 0,0:41:55.72,0:41:56.96,EN,,0,0,0,,at the same time
Dialogue: 0,0:41:57.18,0:41:59.55,EN,,0,0,0,,do these normal-order tricks of de-coupling time.
Dialogue: 0,0:42:00.40,0:42:03.55,EN,,0,0,0,,Let me just show you a really simple example, very, very simple.
Dialogue: 0,0:42:03.79,0:42:05.50,EN,,0,0,0,,Suppose we had a normal-order language.
Dialogue: 0,0:42:07.52,0:42:09.55,EN,,0,0,0,,And I'm going to start out in this language.
Dialogue: 0,0:42:09.55,0:42:10.52,EN,,0,0,0,,This is now normal order.
Dialogue: 0,0:42:10.52,0:42:12.22,EN,,0,0,0,,I'm going to define x to be 0.
Dialogue: 0,0:42:13.57,0:42:15.56,EN,,0,0,0,,It's just some variable I'll initialize.
Dialogue: 0,0:42:15.75,0:42:17.69,EN,,0,0,0,,And now I'm going to define this little funny function,
Dialogue: 0,0:42:18.57,0:42:20.44,EN,,0,0,0,,which is an identity function.
Dialogue: 0,0:42:22.64,0:42:23.90,EN,,0,0,0,,And what it does,
Dialogue: 0,0:42:24.11,0:42:26.60,EN,,0,0,0,,it keeps track of the last time you called it using x.
Dialogue: 0,0:42:31.40,0:42:34.16,EN,,0,0,0,,Right? So the identity of n just returns n,
Dialogue: 0,0:42:34.17,0:42:35.39,EN,,0,0,0,,but it sets x to be n.
Dialogue: 0,0:42:36.76,0:42:38.54,EN,,0,0,0,,And now I'll define a little increment function,
Dialogue: 0,0:42:39.55,0:42:42.30,EN,,0,0,0,,which is a very little, simple scenario.
Dialogue: 0,0:42:42.58,0:42:45.34,EN,,0,0,0,,Now, imagine I'm interacting with this in the normal-order language,
Dialogue: 0,0:42:46.27,0:42:47.23,EN,,0,0,0,,and I type the following.
Dialogue: 0,0:42:47.23,0:42:52.83,EN,,0,0,0,,I say define y to be increment the identity function of 3,
Dialogue: 0,0:42:52.83,0:42:53.96,EN,,0,0,0,,so y is going to be 4.
Dialogue: 0,0:42:57.41,0:42:58.35,EN,,0,0,0,,Now, I say what's x?
Dialogue: 0,0:42:59.52,0:43:02.16,EN,,0,0,0,,Well, x should have been the value that was remembered last
Dialogue: 0,0:43:02.64,0:43:04.01,EN,,0,0,0,,when I called the identity function.
Dialogue: 0,0:43:04.71,0:43:06.73,EN,,0,0,0,,So you'd expect to say, well, x is 3 at this point,
Dialogue: 0,0:43:06.91,0:43:07.52,EN,,0,0,0,,but it's not.
Dialogue: 0,0:43:08.53,0:43:11.15,EN,,0,0,0,,Because when I defined here, y here,
Dialogue: 0,0:43:11.79,0:43:13.45,EN,,0,0,0,,what I really defined y to be
Dialogue: 0,0:43:13.47,0:43:15.71,EN,,0,0,0,,increment of a promise to do this thing.
Dialogue: 0,0:43:17.00,0:43:18.17,EN,,0,0,0,,So I didn't look at y,
Dialogue: 0,0:43:18.36,0:43:20.25,EN,,0,0,0,,so that identity function didn't get run.
Dialogue: 0,0:43:21.56,0:43:23.20,EN,,0,0,0,,So if I type in this definition
Dialogue: 0,0:43:23.31,0:43:24.80,EN,,0,0,0,,and look at x, I'm going to get 0.
Dialogue: 0,0:43:28.36,0:43:31.20,EN,,0,0,0,,Now, if I go look at y and say what's y,
Dialogue: 0,0:43:31.52,0:43:32.43,EN,,0,0,0,,say y is 4,
Dialogue: 0,0:43:32.67,0:43:35.16,EN,,0,0,0,,looking at y, that very active looking at y
Dialogue: 0,0:43:35.29,0:43:37.42,EN,,0,0,0,,caused the identity function to be run.
Dialogue: 0,0:43:38.72,0:43:40.48,EN,,0,0,0,,And now x will get remembered as 3.
Dialogue: 0,0:43:40.74,0:43:41.87,EN,,0,0,0,,So here x will be 0.
Dialogue: 0,0:43:41.93,0:43:42.96,EN,,0,0,0,,Here, x will be 3.
Dialogue: 0,0:43:43.28,0:43:46.16,EN,,0,0,0,,That's a tiny, little, simple scenario,
Dialogue: 0,0:43:46.30,0:43:49.28,EN,,0,0,0,,but you can see what kind of a mess that's going to make
Dialogue: 0,0:43:50.36,0:43:53.34,EN,,0,0,0,,for debugging interactive programs
Dialogue: 0,0:43:54.12,0:43:55.88,EN,,0,0,0,,when you have normal-order evaluation.
Dialogue: 0,0:43:57.10,0:43:58.12,EN,,0,0,0,,It's very confusing.
Dialogue: 0,0:43:59.69,0:44:02.04,EN,,0,0,0,,But it's very confusing for a very deep reason,
Dialogue: 0,0:44:02.80,0:44:06.41,EN,,0,0,0,,which is that the whole idea of putting in delays
Dialogue: 0,0:44:06.92,0:44:08.43,EN,,0,0,0,,is that you throw away time.
Dialogue: 0,0:44:09.78,0:44:11.75,EN,,0,0,0,,That's why we can have these infinite processes.
Dialogue: 0,0:44:11.75,0:44:12.97,EN,,0,0,0,,Since we've thrown away time,
Dialogue: 0,0:44:12.99,0:44:14.27,EN,,0,0,0,,we don't have to wait for them to run,
Dialogue: 0,0:44:17.55,0:44:20.44,EN,,0,0,0,,Right? We decouple the order of events in the computer
Dialogue: 0,0:44:20.83,0:44:22.11,EN,,0,0,0,,from what we write in our programs.
Dialogue: 0,0:44:22.35,0:44:25.28,EN,,0,0,0,,But when we talk about state and set and change,
Dialogue: 0,0:44:25.48,0:44:27.42,EN,,0,0,0,,that's exactly what we do want control of.
Dialogue: 0,0:44:28.76,0:44:33.82,EN,,0,0,0,,So it's almost as if there's this fundamental contradiction in what you want.
Dialogue: 0,0:44:34.57,0:44:39.12,EN,,0,0,0,,And that brings us back to these sort of philosophical mutterings
Dialogue: 0,0:44:39.13,0:44:40.75,EN,,0,0,0,,what is it that you're trying to model
Dialogue: 0,0:44:40.78,0:44:41.77,EN,,0,0,0,,and how do you look at the world.
Dialogue: 0,0:44:42.41,0:44:44.30,EN,,0,0,0,,Or sometimes this is called the
Dialogue: 0,0:44:44.76,0:44:46.60,EN,,0,0,0,,the debate over functional programming.
Dialogue: 0,0:44:54.19,0:44:56.60,EN,,0,0,0,,A so-called purely functional language
Dialogue: 0,0:44:57.07,0:44:59.20,EN,,0,0,0,,is one that just doesn't have any side effects.
Dialogue: 0,0:45:00.44,0:45:01.63,EN,,0,0,0,,Since you have no side effects,
Dialogue: 0,0:45:01.64,0:45:03.02,EN,,0,0,0,,there's no assignment operator,
Dialogue: 0,0:45:03.34,0:45:05.72,EN,,0,0,0,,so there are no terrible consequences of it.
Dialogue: 0,0:45:06.36,0:45:07.93,EN,,0,0,0,,You can use a substitution-like thing.
Dialogue: 0,0:45:07.93,0:45:10.48,EN,,0,0,0,,Programs really are like mathematics and not like
Dialogue: 0,0:45:10.76,0:45:13.82,EN,,0,0,0,,not like models in the real world, not like objects in the real world.
Dialogue: 0,0:45:15.05,0:45:17.17,EN,,0,0,0,,There are a lot of wonderful things about functional languages.
Dialogue: 0,0:45:17.17,0:45:19.63,EN,,0,0,0,,Since there's no time, you never have any synchronization problems.
Dialogue: 0,0:45:20.64,0:45:23.72,EN,,0,0,0,,And if you want to put something into a parallel algorithm,
Dialogue: 0,0:45:24.72,0:45:28.20,EN,,0,0,0,,you can run the pieces of that parallel processing any way you want.
Dialogue: 0,0:45:29.40,0:45:31.44,EN,,0,0,0,,There's just never any synchronization to worry that,
Dialogue: 0,0:45:31.50,0:45:33.34,EN,,0,0,0,,and it's a very congenial environment for doing this.
Dialogue: 0,0:45:33.64,0:45:35.71,EN,,0,0,0,,The price is you give up assignment.
Dialogue: 0,0:45:39.10,0:45:41.32,EN,,0,0,0,,So an advocate of a functional language would say,
Dialogue: 0,0:45:41.34,0:45:43.04,EN,,0,0,0,,gee, that's just a tiny price to pay.
Dialogue: 0,0:45:44.52,0:45:46.51,EN,,0,0,0,,You probably shouldn't use assignment most of the time anyway.
Dialogue: 0,0:45:46.88,0:45:48.27,EN,,0,0,0,,And if you just give up assignment,
Dialogue: 0,0:45:48.43,0:45:51.40,EN,,0,0,0,,you can be in this much, much nicer world
Dialogue: 0,0:45:51.96,0:45:53.24,EN,,0,0,0,,than this place with objects.
Dialogue: 0,0:45:54.19,0:45:56.30,EN,,0,0,0,,Well, what's the rejoinder to that?
Dialogue: 0,0:45:56.30,0:45:58.59,EN,,0,0,0,,Remember how we got into this mess.
Dialogue: 0,0:46:00.06,0:46:03.79,EN,,0,0,0,,We started trying to model things that had local state.
Dialogue: 0,0:46:04.44,0:46:06.49,EN,,0,0,0,,So remember Gerry's random number generator.
Dialogue: 0,0:46:07.16,0:46:08.67,EN,,0,0,0,,There was this random number generator
Dialogue: 0,0:46:09.28,0:46:10.62,EN,,0,0,0,,that had some little state in it
Dialogue: 0,0:46:10.83,0:46:12.08,EN,,0,0,0,,to compute the next random number
Dialogue: 0,0:46:12.12,0:46:14.08,EN,,0,0,0,,and the next random number and the next random number.
Dialogue: 0,0:46:14.28,0:46:16.14,EN,,0,0,0,,And we wanted to hide that state away from the
Dialogue: 0,0:46:16.43,0:46:18.96,EN,,0,0,0,,the Cesaro compute pi process,
Dialogue: 0,0:46:19.84,0:46:20.92,EN,,0,0,0,,and that's why we needed set!
Dialogue: 0,0:46:20.97,0:46:22.91,EN,,0,0,0,,We wanted to package that stated modularly.
Dialogue: 0,0:46:24.07,0:46:26.36,EN,,0,0,0,,Well, a functional programming person would say,
Dialogue: 0,0:46:26.38,0:46:27.56,EN,,0,0,0,,well, you're just all wet.
Dialogue: 0,0:46:27.56,0:46:29.84,EN,,0,0,0,,I mean, you can write a perfectly good modular program.
Dialogue: 0,0:46:29.84,0:46:32.46,EN,,0,0,0,,It's just you're thinking about modularity wrong.
Dialogue: 0,0:46:33.08,0:46:35.02,EN,,0,0,0,,You're hung up in this next random number
Dialogue: 0,0:46:35.07,0:46:36.88,EN,,0,0,0,,and the next random number and the next random number.
Dialogue: 0,0:46:36.88,0:46:39.42,EN,,0,0,0,,Why don't you just say let's write a program.
Dialogue: 0,0:46:40.09,0:46:41.29,EN,,0,0,0,,Let's write an enumerator
Dialogue: 0,0:46:41.95,0:46:44.48,EN,,0,0,0,,which just generates an infinite stream of random numbers.
Dialogue: 0,0:46:49.01,0:46:50.91,EN,,0,0,0,,We can sort of have that stream all at once,
Dialogue: 0,0:46:52.64,0:46:54.54,EN,,0,0,0,,and that's going to be our source of random numbers.
Dialogue: 0,0:46:54.54,0:46:55.24,EN,,0,0,0,,And then if you like,
Dialogue: 0,0:46:55.53,0:46:57.47,EN,,0,0,0,,you can put that through some sort of processor,
Dialogue: 0,0:46:57.77,0:47:01.16,EN,,0,0,0,,which is-- I don't know-- a Cesaro test,
Dialogue: 0,0:47:04.94,0:47:06.22,EN,,0,0,0,,and that can do what it wants.
Dialogue: 0,0:47:06.88,0:47:08.56,EN,,0,0,0,,And what would come out of there
Dialogue: 0,0:47:08.72,0:47:27.45,EN,,0,0,0,,would be a stream of successive approximations to pi.
Dialogue: 0,0:47:28.14,0:47:30.65,EN,,0,0,0,,So as we looked further down this stream,
Dialogue: 0,0:47:30.76,0:47:32.38,EN,,0,0,0,,we'd tug on this Cesaro thing,
Dialogue: 0,0:47:33.12,0:47:35.36,EN,,0,0,0,,and it would pull out more and more random numbers.
Dialogue: 0,0:47:35.54,0:47:37.21,EN,,0,0,0,,And the further and further we look down the stream,
Dialogue: 0,0:47:37.23,0:47:38.96,EN,,0,0,0,,the better an approximation we'd get to pi.
Dialogue: 0,0:47:39.72,0:47:41.66,EN,,0,0,0,,And it would do exactly the same as the other computation,
Dialogue: 0,0:47:41.66,0:47:43.79,EN,,0,0,0,,except we're thinking about the modularity different.
Dialogue: 0,0:47:43.89,0:47:45.55,EN,,0,0,0,,We're saying imagine we had all that
Dialogue: 0,0:47:45.56,0:47:47.47,EN,,0,0,0,,infinite streams of random numbers all at once.
Dialogue: 0,0:47:49.28,0:47:52.24,EN,,0,0,0,,You can see the details of this procedure in the book.
Dialogue: 0,0:47:53.61,0:47:57.85,EN,,0,0,0,,But similarly, there are other things that we tend to get locked into
Dialogue: 0,0:47:58.27,0:48:01.20,EN,,0,0,0,,on this one and that one and the next one and the next one,
Dialogue: 0,0:48:01.37,0:48:02.81,EN,,0,0,0,,which don't have to be that way.
Dialogue: 0,0:48:03.28,0:48:06.54,EN,,0,0,0,,Like you might think about like a banking system,
Dialogue: 0,0:48:07.68,0:48:08.90,EN,,0,0,0,,which is a very simple idea.
Dialogue: 0,0:48:08.90,0:48:12.21,EN,,0,0,0,,Imagine we have a program that sort of represents a bank account.
Dialogue: 0,0:48:18.81,0:48:20.84,EN,,0,0,0,,The bank account might have in it--
Dialogue: 0,0:48:22.78,0:48:26.22,EN,,0,0,0,,if we looked at this in a sort of message-passing view of the world,
Dialogue: 0,0:48:26.44,0:48:28.12,EN,,0,0,0,,we'd say a bank account is an object
Dialogue: 0,0:48:28.59,0:48:31.51,EN,,0,0,0,,that has some local state in there, which is the balance, say.
Dialogue: 0,0:48:34.11,0:48:36.00,EN,,0,0,0,,And a user using this system comes
Dialogue: 0,0:48:36.44,0:48:38.14,EN,,0,0,0,,and sends a transaction request.
Dialogue: 0,0:48:39.31,0:48:41.05,EN,,0,0,0,,So the user sends a transaction request,
Dialogue: 0,0:48:41.07,0:48:42.20,EN,,0,0,0,,like deposit some money,
Dialogue: 0,0:48:42.28,0:48:43.53,EN,,0,0,0,,and the bank account maybe--
Dialogue: 0,0:48:43.92,0:48:46.78,EN,,0,0,0,,let's say the bank account always responds with what the current balance is.
Dialogue: 0,0:48:48.22,0:48:50.04,EN,,0,0,0,,The user says let's deposits some money,
Dialogue: 0,0:48:50.06,0:48:53.21,EN,,0,0,0,,and the bank account sends back a message which is the balance.
Dialogue: 0,0:48:54.35,0:48:57.42,EN,,0,0,0,,And the user says deposit some more,
Dialogue: 0,0:48:57.45,0:48:58.81,EN,,0,0,0,,and the bank account sends back a message.
Dialogue: 0,0:48:59.15,0:49:00.75,EN,,0,0,0,,And just like the random number generating
Dialogue: 0,0:49:00.78,0:49:02.12,EN,,0,0,0,,you'd say, gee, we would like to use set.
Dialogue: 0,0:49:03.20,0:49:06.88,EN,,0,0,0,,We'd like to have balance be a piece of local state inside this bank account
Dialogue: 0,0:49:06.88,0:49:08.40,EN,,0,0,0,,because we want to separate the state of the user
Dialogue: 0,0:49:08.41,0:49:09.57,EN,,0,0,0,,from the state of the bank account.
Dialogue: 0,0:49:13.28,0:49:16.42,EN,,0,0,0,,Well, that's the message-processing view.
Dialogue: 0,0:49:16.42,0:49:18.20,EN,,0,0,0,,There's a stream view with that thing,
Dialogue: 0,0:49:19.48,0:49:22.19,EN,,0,0,0,,which does the same thing without any set or side effects.
Dialogue: 0,0:49:22.74,0:49:26.73,EN,,0,0,0,,And the idea is again
Dialogue: 0,0:49:27.37,0:49:30.25,EN,,0,0,0,,we don't think about anything having local state.
Dialogue: 0,0:49:31.18,0:49:33.08,EN,,0,0,0,,We think about the bank account as something
Dialogue: 0,0:49:33.40,0:49:37.71,EN,,0,0,0,,that's going to process a stream of transaction requests.
Dialogue: 0,0:49:38.64,0:49:40.16,EN,,0,0,0,,So think about this bank account not
Dialogue: 0,0:49:40.22,0:49:42.00,EN,,0,0,0,,as something that goes message by message,
Dialogue: 0,0:49:42.44,0:49:45.85,EN,,0,0,0,,but something that takes in a stream of transaction requests
Dialogue: 0,0:49:45.87,0:49:48.49,EN,,0,0,0,,like maybe successive deposit announced.
Dialogue: 0,0:49:49.49,0:49:54.94,EN,,0,0,0,,1, 2, 2, 4, those might be successive amounts to deposit.
Dialogue: 0,0:49:55.94,0:50:02.44,EN,,0,0,0,,And then coming out of it is the successive balances 1, 3, 5, 9.
Dialogue: 0,0:50:03.77,0:50:06.14,EN,,0,0,0,,So we think of the bank account not as something that has state,
Dialogue: 0,0:50:06.40,0:50:07.26,EN,,0,0,0,,but something that acts
Dialogue: 0,0:50:08.92,0:50:10.82,EN,,0,0,0,,sort of on the infinite stream of requests.
Dialogue: 0,0:50:10.82,0:50:12.30,EN,,0,0,0,,But remember, we've thrown away time.
Dialogue: 0,0:50:12.37,0:50:14.27,EN,,0,0,0,,So what we can do is if the user's here,
Dialogue: 0,0:50:16.12,0:50:19.13,EN,,0,0,0,,we can have this infinite stream of requests
Dialogue: 0,0:50:19.18,0:50:22.54,EN,,0,0,0,,being generated one at a time coming from the user
Dialogue: 0,0:50:24.06,0:50:26.57,EN,,0,0,0,,and this transaction stream
Dialogue: 0,0:50:26.57,0:50:28.80,EN,,0,0,0,,coming back on a printer being printed one at a time.
Dialogue: 0,0:50:30.01,0:50:31.37,EN,,0,0,0,,And if we drew a little line here,
Dialogue: 0,0:50:32.56,0:50:33.08,EN,,0,0,0,,right there to the user,
Dialogue: 0,0:50:33.28,0:50:34.91,EN,,0,0,0,,the user couldn't tell that this system doesn't have state.
Dialogue: 0,0:50:36.19,0:50:37.71,EN,,0,0,0,,that this system doesn't have state.
Dialogue: 0,0:50:39.56,0:50:41.13,EN,,0,0,0,,It looks just like the other one,
Dialogue: 0,0:50:41.29,0:50:42.46,EN,,0,0,0,,but there's no state in there.
Dialogue: 0,0:50:42.84,0:50:45.87,EN,,0,0,0,,And by the way,
Dialogue: 0,0:50:46.72,0:50:49.47,EN,,0,0,0,,just to show you, here's an actual implementation
Dialogue: 0,0:50:50.52,0:50:52.30,EN,,0,0,0,,of this-- we'll call it make deposit account
Dialogue: 0,0:50:52.32,0:50:53.32,EN,,0,0,0,,because you can only deposit.
Dialogue: 0,0:50:54.17,0:50:55.77,EN,,0,0,0,,It takes an initial balance
Dialogue: 0,0:50:56.09,0:50:58.09,EN,,0,0,0,,and then a stream of deposits you might make.
Dialogue: 0,0:51:00.02,0:51:00.82,EN,,0,0,0,,And what is it?
Dialogue: 0,0:51:00.82,0:51:02.54,EN,,0,0,0,,Well, it's just cons-stream of the balance
Dialogue: 0,0:51:03.23,0:51:05.31,EN,,0,0,0,,onto make a new account stream
Dialogue: 0,0:51:06.24,0:51:07.32,EN,,0,0,0,,whose initial balance
Dialogue: 0,0:51:07.48,0:51:10.27,EN,,0,0,0,,is the old balance plus the first thing in the deposit stream
Dialogue: 0,0:51:10.86,0:51:13.40,EN,,0,0,0,,whose rest, right and,
Dialogue: 0,0:51:13.76,0:51:17.37,EN,,0,0,0,,make deposit account works on the rest of which is the tail of the deposit stream.
Dialogue: 0,0:51:18.30,0:51:23.84,EN,,0,0,0,,So there's sort of a very typical message-passing,
Dialogue: 0,0:51:23.95,0:51:27.55,EN,,0,0,0,,message-passing, object-oriented thing that's done without side effects at all.
Dialogue: 0,0:51:29.05,0:51:30.76,EN,,0,0,0,,There are very many things you can do this way.
Dialogue: 0,0:51:32.25,0:51:35.23,EN,,0,0,0,,Well, can you do everything without assignment?
Dialogue: 0,0:51:36.40,0:51:39.00,EN,,0,0,0,,Can everybody go over to purely functional languages?
Dialogue: 0,0:51:40.05,0:51:42.04,EN,,0,0,0,,Well, we don't know,
Dialogue: 0,0:51:42.27,0:51:43.44,EN,,0,0,0,,but there seem to be places
Dialogue: 0,0:51:43.92,0:51:46.03,EN,,0,0,0,,where purely functional programming breaks down.
Dialogue: 0,0:51:48.10,0:51:50.27,EN,,0,0,0,,Where it starts hurting is when you have things like this,
Dialogue: 0,0:51:50.43,0:51:52.32,EN,,0,0,0,,but you also mix it up with
Dialogue: 0,0:51:52.60,0:51:54.27,EN,,0,0,0,,the other things that we had to worry that,
Dialogue: 0,0:51:54.30,0:51:55.64,EN,,0,0,0,,which are objects and sharing
Dialogue: 0,0:51:55.90,0:51:58.52,EN,,0,0,0,,and two independent agents being the same.
Dialogue: 0,0:51:58.85,0:51:59.93,EN,,0,0,0,,So under a typical one,
Dialogue: 0,0:51:59.96,0:52:01.63,EN,,0,0,0,,suppose you want to extend this bank account.
Dialogue: 0,0:52:03.24,0:52:04.27,EN,,0,0,0,,So here's a bank account.
Dialogue: 0,0:52:12.22,0:52:14.75,EN,,0,0,0,,Bank accounts take in a stream of transaction requests
Dialogue: 0,0:52:15.20,0:52:18.44,EN,,0,0,0,,and put out streams of, say, balances or responses to that.
Dialogue: 0,0:52:18.78,0:52:20.16,EN,,0,0,0,,But suppose you want to model the fact
Dialogue: 0,0:52:20.17,0:52:24.36,EN,,0,0,0,,that this is a joint bank account between two independent people.
Dialogue: 0,0:52:25.68,0:52:28.65,EN,,0,0,0,,Right? I don't know. So suppose there are two people,
Dialogue: 0,0:52:28.97,0:52:30.96,EN,,0,0,0,,say, Bill and Dave,
Dialogue: 0,0:52:31.77,0:52:33.14,EN,,0,0,0,,who have a joint bank account.
Dialogue: 0,0:52:35.96,0:52:36.85,EN,,0,0,0,,How would you model this?
Dialogue: 0,0:52:36.88,0:52:39.80,EN,,0,0,0,,Well, you might, Bill puts out a stream of transaction requests,
Dialogue: 0,0:52:40.24,0:52:42.25,EN,,0,0,0,,and Dave puts out a stream of transaction requests,
Dialogue: 0,0:52:42.25,0:52:45.16,EN,,0,0,0,,and somehow, they have to merge into this bank account.
Dialogue: 0,0:52:45.88,0:52:47.85,EN,,0,0,0,,So what you might do is write a little stream
Dialogue: 0,0:52:47.90,0:52:50.65,EN,,0,0,0,,processing thing called merge,
Dialogue: 0,0:52:57.23,0:52:59.13,EN,,0,0,0,,which sort of takes these, merges them together,
Dialogue: 0,0:52:59.34,0:53:01.19,EN,,0,0,0,,produces a single stream for the bank account.
Dialogue: 0,0:53:01.19,0:53:02.99,EN,,0,0,0,,Now they're both talking to the same bank account.
Dialogue: 0,0:53:03.61,0:53:05.48,EN,,0,0,0,,That's all great, but how do you write merge?
Dialogue: 0,0:53:05.93,0:53:08.24,EN,,0,0,0,,What, What's this procedure merge?
Dialogue: 0,0:53:09.73,0:53:11.42,EN,,0,0,0,,You want to do something that's reasonable.
Dialogue: 0,0:53:12.38,0:53:13.80,EN,,0,0,0,,Your first guess might be to say,
Dialogue: 0,0:53:13.80,0:53:16.68,EN,,0,0,0,,well, we'll take alternate requests from Bill and Dave.
Dialogue: 0,0:53:18.19,0:53:20.97,EN,,0,0,0,,But what happens if But what happens if suddenly in the middle thing
Dialogue: 0,0:53:21.18,0:53:23.08,EN,,0,0,0,,Dave goes away on vacation for two years?
Dialogue: 0,0:53:24.15,0:53:25.40,EN,,0,0,0,,Then Bill's sort of stuck.
Dialogue: 0,0:53:27.69,0:53:29.75,EN,,0,0,0,,So what you want to do is-- well, it's hard to describe.
Dialogue: 0,0:53:29.75,0:53:33.64,EN,,0,0,0,,What you want to do is what people call fair merge.
Dialogue: 0,0:53:38.41,0:53:40.17,EN,,0,0,0,,The idea of fair merge is
Dialogue: 0,0:53:40.73,0:53:42.46,EN,,0,0,0,,is it sort of should do them alternately,
Dialogue: 0,0:53:42.49,0:53:43.92,EN,,0,0,0,,but if there's nothing waiting here,
Dialogue: 0,0:53:43.96,0:53:44.91,EN,,0,0,0,,it should take one twice.
Dialogue: 0,0:53:46.01,0:53:48.45,EN,,0,0,0,,Notice I can't even say that without talking about time.
Dialogue: 0,0:53:51.30,0:53:56.41,EN,,0,0,0,,So one of the other active researcher areas in functional languages
Dialogue: 0,0:53:56.43,0:53:59.48,EN,,0,0,0,,is inventing little things like fair merge
Dialogue: 0,0:54:00.35,0:54:01.31,EN,,0,0,0,,maybe some others,
Dialogue: 0,0:54:01.56,0:54:06.25,EN,,0,0,0,,which will take the places where I used to need side effects and objects
Dialogue: 0,0:54:06.80,0:54:10.52,EN,,0,0,0,,and sort of hide them away in some very well-defined modules of the system
Dialogue: 0,0:54:10.86,0:54:13.50,EN,,0,0,0,,so that all the problems of assignment
Dialogue: 0,0:54:13.52,0:54:15.34,EN,,0,0,0,,don't sort of leak out all over the system but
Dialogue: 0,0:54:15.40,0:54:17.88,EN,,0,0,0,,are captured in some fairly well-understood things.
Dialogue: 0,0:54:20.78,0:54:22.70,EN,,0,0,0,,More generally, I think what you're seeing
Dialogue: 0,0:54:23.12,0:54:24.06,EN,,0,0,0,,is that we're running across
Dialogue: 0,0:54:24.08,0:54:26.67,EN,,0,0,0,,what I think is a very basic problem in computer science,
Dialogue: 0,0:54:26.97,0:54:27.82,EN,,0,0,0,,which is how to
Dialogue: 0,0:54:28.24,0:54:32.03,EN,,0,0,0,,how to define languages that somehow can talk about delayed evaluation
Dialogue: 0,0:54:34.14,0:54:35.08,EN,,0,0,0,,But also
Dialogue: 0,0:54:35.87,0:54:38.25,EN,,0,0,0,,be able to reflect this view that there are objects in the world.
Dialogue: 0,0:54:38.36,0:54:40.36,EN,,0,0,0,,How do we somehow get both?
Dialogue: 0,0:54:41.23,0:54:43.04,EN,,0,0,0,,And I think that's a very hard problem.
Dialogue: 0,0:54:43.04,0:54:45.52,EN,,0,0,0,,And it may be that it's a very hard problem
Dialogue: 0,0:54:45.85,0:54:48.17,EN,,0,0,0,,that has almost nothing to do with computer science,
Dialogue: 0,0:54:48.59,0:54:50.24,EN,,0,0,0,,that it really is a problem having to do with
Dialogue: 0,0:54:50.27,0:54:52.73,EN,,0,0,0,,two very incompatible ways of looking at the world.
Dialogue: 0,0:54:54.14,0:54:54.72,EN,,0,0,0,,OK, questions?
Dialogue: 0,0:55:17.55,0:55:19.20,EN,,0,0,0,,AUDIENCE: You mentioned earlier that
Dialogue: 0,0:55:20.11,0:55:21.32,EN,,0,0,0,,once you introduce assignment,
Dialogue: 0,0:55:21.32,0:55:25.89,EN,,0,0,0,,the general rule for using the substitution model is you can't.
Dialogue: 0,0:55:25.89,0:55:27.57,EN,,0,0,0,,Unless you're very careful, you can't.
Dialogue: 0,0:55:27.57,0:55:27.96,EN,,0,0,0,,PROFESSOR: Right.
Dialogue: 0,0:55:28.26,0:55:33.28,EN,,0,0,0,,AUDIENCE: Is there a set of techniques or a set of guidelines
Dialogue: 0,0:55:33.42,0:55:35.92,EN,,0,0,0,,for localizing the effects of assignment
Dialogue: 0,0:55:36.52,0:55:40.30,EN,,0,0,0,,so that the very careful becomes defined?
Dialogue: 0,0:55:40.30,0:55:42.60,EN,,0,0,0,,PROFESSOR: I don't know. Um...
Dialogue: 0,0:55:42.89,0:55:43.58,EN,,0,0,0,,Let me think.
Dialogue: 0,0:55:45.43,0:55:48.94,EN,,0,0,0,,Well, certainly, there was an assignment inside memo proc,
Dialogue: 0,0:55:50.12,0:55:51.48,EN,,0,0,0,,but that was sort of hidden away.
Dialogue: 0,0:55:51.48,0:55:53.00,EN,,0,0,0,,It ended up not making any difference.
Dialogue: 0,0:55:53.48,0:55:56.44,EN,,0,0,0,,Part of the reason for that is once this thing triggered
Dialogue: 0,0:55:57.15,0:55:58.83,EN,,0,0,0,,that it had run and gotten an answer,
Dialogue: 0,0:55:58.83,0:56:00.06,EN,,0,0,0,,that answer will never change.
Dialogue: 0,0:56:00.60,0:56:02.33,EN,,0,0,0,,So that was sort of a one-time assignment.
Dialogue: 0,0:56:02.35,0:56:03.85,EN,,0,0,0,,So one very general thing you can do
Dialogue: 0,0:56:04.30,0:56:06.35,EN,,0,0,0,,is if you only do what's called a one-time assignment
Dialogue: 0,0:56:08.04,0:56:09.24,EN,,0,0,0,,and never change anything,
Dialogue: 0,0:56:09.63,0:56:10.54,EN,,0,0,0,,then you can do better.
Dialogue: 0,0:56:11.25,0:56:14.12,EN,,0,0,0,,One of the problems in this merge thing, people have--
Dialogue: 0,0:56:14.67,0:56:18.32,EN,,0,0,0,,people have-- let me see if this is right.
Dialogue: 0,0:56:18.49,0:56:21.55,EN,,0,0,0,,I think it's true that with fair merge,
Dialogue: 0,0:56:22.25,0:56:26.09,EN,,0,0,0,,with just fair merge, you can begin effectively simulating
Dialogue: 0,0:56:27.02,0:56:28.89,EN,,0,0,0,,assignment in the rest of the language.
Dialogue: 0,0:56:30.82,0:56:33.29,EN,,0,0,0,,It seems like anything you do to go outside--
Dialogue: 0,0:56:33.50,0:56:35.50,EN,,0,0,0,,I'm not quite sure that's true for fair merge,
Dialogue: 0,0:56:35.53,0:56:39.31,EN,,0,0,0,,but it's true of a little bit more general things that people have been doing.
Dialogue: 0,0:56:39.52,0:56:41.34,EN,,0,0,0,,So it might be that any little bit you put in,
Dialogue: 0,0:56:41.61,0:56:44.14,EN,,0,0,0,,suddenly if they allow you to build arbitrary stuff,
Dialogue: 0,0:56:44.16,0:56:46.51,EN,,0,0,0,,it's almost as bad as having assignment altogether.
Dialogue: 0,0:56:47.97,0:56:50.67,EN,,0,0,0,,But that's an area that people are thinking about now.
Dialogue: 0,0:56:51.59,0:56:54.30,EN,,0,0,0,,AUDIENCE: I guess I don't see the problem here with merge
Dialogue: 0,0:56:54.83,0:56:59.20,EN,,0,0,0,,if, you know the sense, I call Bill, if Bill is a procedure,
Dialogue: 0,0:56:59.21,0:57:02.41,EN,,0,0,0,,then Bill is going to increment the bank account
Dialogue: 0,0:57:02.44,0:57:04.73,EN,,0,0,0,,or build the list that 's going to put in the next element.
Dialogue: 0,0:57:04.73,0:57:06.84,EN,,0,0,0,,If I call Dave twice in a row, that will do that.
Dialogue: 0,0:57:07.17,0:57:09.35,EN,,0,0,0,,I'm not sure where fair merge has to be involved.
Dialogue: 0,0:57:09.35,0:57:11.20,EN,,0,0,0,,PROFESSOR: The problem is imagine these really as people.
Dialogue: 0,0:57:11.20,0:57:14.20,EN,,0,0,0,,See, here I have the user who's interacting with this bank account.
Dialogue: 0,0:57:14.85,0:57:17.07,EN,,0,0,0,,Put in a request, get an answer. Put in a request, get an answer.
Dialogue: 0,0:57:17.20,0:57:17.56,EN,,0,0,0,,AUDIENCE: Right.
Dialogue: 0,0:57:18.20,0:57:20.62,EN,,0,0,0,,PROFESSOR: But if the only way I can process request
Dialogue: 0,0:57:20.65,0:57:22.25,EN,,0,0,0,,is to alternate them from two people--
Dialogue: 0,0:57:22.91,0:57:24.22,EN,,0,0,0,,AUDIENCE: Well, why would you alternate them?
Dialogue: 0,0:57:24.22,0:57:25.23,EN,,0,0,0,,PROFESSOR: Why don't I?
Dialogue: 0,0:57:25.45,0:57:25.80,EN,,0,0,0,,AUDIENCE: Yes. Why do you?
Dialogue: 0,0:57:26.60,0:57:27.72,EN,,0,0,0,,PROFESSOR: Think of them as real people, right?
Dialogue: 0,0:57:27.76,0:57:28.97,EN,,0,0,0,,This guy might go away for a year.
Dialogue: 0,0:57:29.28,0:57:31.74,EN,,0,0,0,,And you're sitting here at the bank account window,
Dialogue: 0,0:57:32.43,0:57:33.72,EN,,0,0,0,,and you can't put in two requests
Dialogue: 0,0:57:33.74,0:57:34.94,EN,,0,0,0,,because it's waiting for this guy.
Dialogue: 0,0:57:35.48,0:57:37.07,EN,,0,0,0,,AUDIENCE: Why does it have to be waiting for one?
Dialogue: 0,0:57:37.38,0:57:39.11,EN,,0,0,0,,PROFESSOR: Because it's trying to compute a function.
Dialogue: 0,0:57:39.11,0:57:40.92,EN,,0,0,0,,I have to define a function.
Dialogue: 0,0:57:41.72,0:57:42.60,EN,,0,0,0,,Another way to say that
Dialogue: 0,0:57:42.84,0:57:44.99,EN,,0,0,0,,is the answer to what comes out of this merge box
Dialogue: 0,0:57:46.24,0:57:49.48,EN,,0,0,0,,is not a function of what goes in.
Dialogue: 0,0:57:51.69,0:57:53.49,EN,,0,0,0,,Because, see, what would the function be?
Dialogue: 0,0:57:53.49,0:57:58.86,EN,,0,0,0,,Suppose he puts in 1, 1, 1, 1,
Dialogue: 0,0:57:59.82,0:58:02.78,EN,,0,0,0,,and he puts in 2, 2, 2, 2.
Dialogue: 0,0:58:03.47,0:58:04.80,EN,,0,0,0,,What's the answer supposed to be?
Dialogue: 0,0:58:05.58,0:58:08.74,EN,,0,0,0,,It's not good enough to say it's 1, 2, 1, 2, 1, 2.
Dialogue: 0,0:58:08.74,0:58:09.39,EN,,0,0,0,,AUDIENCE: I understand.
Dialogue: 0,0:58:09.39,0:58:11.56,EN,,0,0,0,,But when Bill puts in 1, 1 goes in.
Dialogue: 0,0:58:11.56,0:58:13.95,EN,,0,0,0,,When Dave puts in 2, twice 2 goes in twice.
Dialogue: 0,0:58:13.95,0:58:14.73,EN,,0,0,0,,AUDIENCE: When Bill puts in--
Dialogue: 0,0:58:14.76,0:58:15.08,EN,,0,0,0,,PROFESSOR: Right.
Dialogue: 0,0:58:15.13,0:58:18.43,EN,,0,0,0,,AUDIENCE: Why can't it be hooked to the time of the input--
Dialogue: 0,0:58:18.59,0:58:20.06,EN,,0,0,0,,the actual procedural--
Dialogue: 0,0:58:20.12,0:58:21.84,EN,,0,0,0,,PROFESSOR: Because I don't have time.
Dialogue: 0,0:58:23.98,0:58:26.90,EN,,0,0,0,,See, all I can say is I'm going to define a function.
Dialogue: 0,0:58:26.90,0:58:28.15,EN,,0,0,0,,I don't have time.
Dialogue: 0,0:58:32.00,0:58:34.19,EN,,0,0,0,,There's no concept if it's going to alternate,
Dialogue: 0,0:58:34.19,0:58:36.54,EN,,0,0,0,,except if nobody's there, it's going to wait a while for him.
Dialogue: 0,0:58:38.42,0:58:41.36,EN,,0,0,0,,It's just going to say I have the stream of requests,
Dialogue: 0,0:58:41.74,0:58:43.34,EN,,0,0,0,,the timeless infinite streams
Dialogue: 0,0:58:43.36,0:58:45.29,EN,,0,0,0,,of all the requests that Dave would have made, right?
Dialogue: 0,0:58:47.55,0:58:50.41,EN,,0,0,0,,And the timeless infinite stream of all the requests Bill would have made,
Dialogue: 0,0:58:50.54,0:58:51.69,EN,,0,0,0,,and I want to operate on them.
Dialogue: 0,0:58:51.69,0:58:53.51,EN,,0,0,0,,See, that's how this bank account is working.
Dialogue: 0,0:58:56.71,0:58:57.58,EN,,0,0,0,,And the problem is
Dialogue: 0,0:58:57.61,0:59:00.75,EN,,0,0,0,,that these poor people who are sitting at the bank account windows
Dialogue: 0,0:59:00.76,0:59:03.82,EN,,0,0,0,,have the misfortune to exist in time.
Dialogue: 0,0:59:05.29,0:59:07.13,EN,,0,0,0,,They don't see their infinite stream
Dialogue: 0,0:59:07.69,0:59:09.53,EN,,0,0,0,,of all the requests they would have ever made.
Dialogue: 0,0:59:10.07,0:59:11.55,EN,,0,0,0,,They're waiting now, and they want an answer.
Dialogue: 0,0:59:14.48,0:59:15.76,EN,,0,0,0,,So if you're sitting there--
Dialogue: 0,0:59:16.24,0:59:20.86,EN,,0,0,0,,if this is the screen operation on some time-sharing system
Dialogue: 0,0:59:21.52,0:59:22.60,EN,,0,0,0,,and it's working functionally,
Dialogue: 0,0:59:22.64,0:59:24.59,EN,,0,0,0,,you want an answer then when you talk the character.
Dialogue: 0,0:59:25.29,0:59:27.42,EN,,0,0,0,,You don't want it to have to wait for everybody in the whole system
Dialogue: 0,0:59:27.45,0:59:29.92,EN,,0,0,0,,to have typed one character before it can get around to service you.
Dialogue: 0,0:59:30.91,0:59:31.92,EN,,0,0,0,,So that's the problem.
Dialogue: 0,0:59:34.00,0:59:36.38,EN,,0,0,0,,I mean, the fact that people live in time, apparently.
Dialogue: 0,0:59:37.21,0:59:38.62,EN,,0,0,0,,If they didn't, it wouldn't be a problem.
Dialogue: 0,0:59:49.10,0:59:51.02,EN,,0,0,0,,AUDIENCE: I'm afraid I miss the point of
Dialogue: 0,0:59:51.08,0:59:54.24,EN,,0,0,0,,having no time in this banking transaction.
Dialogue: 0,0:59:54.74,0:59:56.65,EN,,0,0,0,,Isn't time very important?
Dialogue: 0,0:59:56.88,0:59:59.05,EN,,0,0,0,,For instance, the sequence of events.
Dialogue: 0,0:59:59.95,1:00:05.02,EN,,0,0,0,,As if, If Dave take out $100, and then
Dialogue: 0,1:00:06.30,1:00:08.40,EN,,0,0,0,,then the timing sequence should be important.
Dialogue: 0,1:00:08.40,1:00:10.86,EN,,0,0,0,,How do you treat transactions as streams?
Dialogue: 0,1:00:11.26,1:00:14.26,EN,,0,0,0,,PROFESSOR: Well, that's the thing I'm saying.
Dialogue: 0,1:00:14.26,1:00:15.61,EN,,0,0,0,,This is an example where you can't.
Dialogue: 0,1:00:17.51,1:00:18.12,EN,,0,0,0,,You can't.
Dialogue: 0,1:00:18.16,1:00:20.08,EN,,0,0,0,,What goes, The point is what comes out of here
Dialogue: 0,1:00:20.24,1:00:21.88,EN,,0,0,0,,is simply not a function of the stream going in here
Dialogue: 0,1:00:21.92,1:00:23.60,EN,,0,0,0,,going in here and the stream going in here.
Dialogue: 0,1:00:24.17,1:00:25.98,EN,,0,0,0,,It's a function of the stream going in here
Dialogue: 0,1:00:26.19,1:00:27.26,EN,,0,0,0,,and the stream going in here
Dialogue: 0,1:00:27.36,1:00:29.07,EN,,0,0,0,,and some kind of information about time,
Dialogue: 0,1:00:29.37,1:00:32.36,EN,,0,0,0,,which is precisely what a normal-order language won't let you say.
Dialogue: 0,1:00:34.81,1:00:37.95,EN,,0,0,0,,AUDIENCE: In order to brings this back into a more functional perspective,
Dialogue: 0,1:00:38.54,1:00:42.04,EN,,0,0,0,,could we just explicitly time stamp all the inputs from Bill and Dave
Dialogue: 0,1:00:42.54,1:00:46.40,EN,,0,0,0,,and define fair merge to just be the sort on those time stamps?
Dialogue: 0,1:00:48.41,1:00:49.55,EN,,0,0,0,,PROFESSOR: Yeah, you can do that.
Dialogue: 0,1:00:49.55,1:00:50.60,EN,,0,0,0,,You can do that sort of thing.
Dialogue: 0,1:00:50.60,1:00:52.56,EN,,0,0,0,,Another thing you could say is imagine
Dialogue: 0,1:00:52.76,1:00:54.44,EN,,0,0,0,,that really what this function is,
Dialogue: 0,1:00:54.78,1:00:56.88,EN,,0,0,0,,is that it does a read every microsecond,
Dialogue: 0,1:00:58.86,1:00:59.93,EN,,0,0,0,,and then if there's none there,
Dialogue: 0,1:00:59.93,1:01:00.97,EN,,0,0,0,,that's considered an empty one.
Dialogue: 0,1:01:00.97,1:01:03.39,EN,,0,0,0,,That's about equivalent to what you said.
Dialogue: 0,1:01:03.61,1:01:06.08,EN,,0,0,0,,And yes, you can do that, but that's a glitch.
Dialogue: 0,1:01:07.11,1:01:10.14,EN,,0,0,0,,So it's not quite only implementation we're worried about.
Dialogue: 0,1:01:10.76,1:01:12.73,EN,,0,0,0,,We're worried about expressive power in the language,
Dialogue: 0,1:01:12.75,1:01:14.67,EN,,0,0,0,,and what we're running across is a real mismatch
Dialogue: 0,1:01:14.99,1:01:17.44,EN,,0,0,0,,between what we can say easily and what we'd like to say.
Dialogue: 0,1:01:19.88,1:01:22.01,EN,,0,0,0,,AUDIENCE: It sounds like where we're getting hung up with that
Dialogue: 0,1:01:22.06,1:01:26.09,EN,,0,0,0,,one input from both Bill and Dave at the same time.
Dialogue: 0,1:01:26.12,1:01:28.43,EN,,0,0,0,,PROFESSOR: It's not quite one, but it's anything you define.
Dialogue: 0,1:01:28.53,1:01:30.57,EN,,0,0,0,,So you can say Dave can go twice as often,
Dialogue: 0,1:01:30.72,1:01:32.32,EN,,0,0,0,,but if anything you predefine,
Dialogue: 0,1:01:32.68,1:01:33.87,EN,,0,0,0,,it's not the right thing.
Dialogue: 0,1:01:36.11,1:01:40.70,EN,,0,0,0,,You can't decide at some particular function of their input requests.
Dialogue: 0,1:01:41.93,1:01:43.37,EN,,0,0,0,,Worse yet, I mean, worse yet,
Dialogue: 0,1:01:44.12,1:01:45.72,EN,,0,0,0,,there are things that even merge can't do.
Dialogue: 0,1:01:47.29,1:01:49.69,EN,,0,0,0,,One thing you might want to do that's even more general is suddenly
Dialogue: 0,1:01:50.24,1:01:52.47,EN,,0,0,0,,you add somebody else to this bank account system.
Dialogue: 0,1:01:52.47,1:01:54.51,EN,,0,0,0,,You go and you add John to this bank account system.
Dialogue: 0,1:01:56.03,1:01:58.89,EN,,0,0,0,,And now there's yet another stream that's going to come into the picture
Dialogue: 0,1:01:58.91,1:02:00.70,EN,,0,0,0,,at some time which we haven't prespecified.
Dialogue: 0,1:02:02.04,1:02:04.00,EN,,0,0,0,,So that's something even fair merge can't do,
Dialogue: 0,1:02:04.00,1:02:08.25,EN,,0,0,0,,and they're things called-- I forget-- manager or something.
Dialogue: 0,1:02:08.86,1:02:11.79,EN,,0,0,0,,That's a generalization of fair merge to allow that.
Dialogue: 0,1:02:11.79,1:02:13.98,EN,,0,0,0,,There's a whole sort of research discipline saying
Dialogue: 0,1:02:14.00,1:02:16.30,EN,,0,0,0,,how far can you push this functional perspective
Dialogue: 0,1:02:16.59,1:02:18.72,EN,,0,0,0,,by adding more and more mechanism?
Dialogue: 0,1:02:19.58,1:02:21.79,EN,,0,0,0,,And how far does that go before the whole thing breaks down
Dialogue: 0,1:02:21.82,1:02:23.40,EN,,0,0,0,,and you might as well been using set anyway.
Dialogue: 0,1:02:25.98,1:02:28.00,EN,,0,0,0,,AUDIENCE: But not automatic deposit.
Dialogue: 0,1:02:39.32,1:02:40.49,EN,,0,0,0,,PROFESSOR: OK, thank you.
Dialogue: 0,0:00:00.03,0:00:03.10,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:04.09,0:00:12.08,title,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:04.09,0:00:12.08,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N张大伟\N（DreamAndDead）
Dialogue: 0,0:00:04.09,0:00:12.08,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:04.09,0:00:12.08,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:04.09,0:00:12.08,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:12.54,0:00:17.00,Declare,,0,0,0,,{\an2\fad(500,500)}流 II
Dialogue: 0,0:00:20.97,0:00:24.08,Default,,0,0,0,,教授：上节课 我们介绍了流
Dialogue: 0,0:00:24.08,0:00:27.82,Default,,0,0,0,,按照信号处理的方式来组织系统
Dialogue: 0,0:00:28.87,0:00:31.42,Default,,0,0,0,,要记住的是 关键点在于
Dialogue: 0,0:00:31.90,0:00:32.96,Default,,0,0,0,,我们分离开
Dialogue: 0,0:00:34.20,0:00:37.31,Default,,0,0,0,,程序中 事件表面上的顺序
Dialogue: 0,0:00:37.58,0:00:40.17,Default,,0,0,0,,与机器中的实际计算顺序
Dialogue: 0,0:00:41.07,0:00:42.28,Default,,0,0,0,,那就意味着 我们可以
Dialogue: 0,0:00:42.57,0:00:44.14,Default,,0,0,0,,着手处理非常长的流
Dialogue: 0,0:00:44.89,0:00:47.39,Default,,0,0,0,,并且只有在需要的时候才生成其中的元素
Dialogue: 0,0:00:47.53,0:00:49.39,Default,,0,0,0,,这种按需计算的方式
Dialogue: 0,0:00:49.52,0:00:51.40,Default,,0,0,0,,是内建在流的数据结构中的
Dialogue: 0,0:00:54.11,0:00:55.64,Default,,0,0,0,,即使这个流非常之长
Dialogue: 0,0:00:55.66,0:00:57.08,Default,,0,0,0,,我们只计算所需要的
Dialogue: 0,0:00:58.04,0:01:00.75,Default,,0,0,0,,只有当我们要求的时候 新的数据才会生成
Dialogue: 0,0:01:00.75,0:01:01.74,Default,,0,0,0,,要举个什么样的例子呢？
Dialogue: 0,0:01:02.11,0:01:03.60,Default,,0,0,0,,这个“按需”是什么个情况呢？
Dialogue: 0,0:01:05.02,0:01:06.01,Default,,0,0,0,,举个例子
Dialogue: 0,0:01:09.21,0:01:11.37,Default,,0,0,0,,我们可能会想要一个流中的第N个元素
Dialogue: 0,0:01:15.36,0:01:18.92,Default,,0,0,0,,这个过程可以用于计算流的第N个元素
Dialogue: 0,0:01:20.09,0:01:21.23,Default,,0,0,0,,一个参数为索引N
Dialogue: 0,0:01:21.24,0:01:22.84,Default,,0,0,0,,另一个参数是流S
Dialogue: 0,0:01:23.40,0:01:25.42,Default,,0,0,0,,递归遍历这个流即可求解
Dialogue: 0,0:01:25.57,0:01:27.39,Default,,0,0,0,,如果N为0 我们就计算头部分
Dialogue: 0,0:01:27.96,0:01:30.99,Default,,0,0,0,,否则 就在流的尾部分
Dialogue: 0,0:01:31.74,0:01:32.80,Default,,0,0,0,,查找第N-1个元素
Dialogue: 0,0:01:34.31,0:01:36.43,Default,,0,0,0,,看起来是Lisp中很普通的编程方式 但是不同的是
Dialogue: 0,0:01:36.62,0:01:38.76,Default,,0,0,0,,直到我们不断遍历 取得相继的N个元素
Dialogue: 0,0:01:38.86,0:01:40.99,Default,,0,0,0,,这些元素才被计算出来
Dialogue: 0,0:01:41.52,0:01:44.78,Default,,0,0,0,,这是这些流元素可能被FORCE的一种方式
Dialogue: 0,0:01:45.77,0:01:46.64,Default,,0,0,0,,另外一种方式则是
Dialogue: 0,0:01:47.18,0:01:48.92,Default,,0,0,0,,这里有个简单的过程 用来打印一个流
Dialogue: 0,0:01:49.30,0:01:50.38,Default,,0,0,0,,它的定义是
Dialogue: 0,0:01:51.90,0:01:53.28,Default,,0,0,0,,过程PRINT-STREAM的定义是
Dialogue: 0,0:01:54.15,0:01:55.12,Default,,0,0,0,,我们要怎么做呢？
Dialogue: 0,0:01:55.74,0:01:56.86,Default,,0,0,0,,先打印流的头部分
Dialogue: 0,0:01:57.74,0:01:59.32,Default,,0,0,0,,流的头部分在这时就被计算出来
Dialogue: 0,0:01:59.72,0:02:02.84,Default,,0,0,0,,然后我们再递归地打印流的尾部分
Dialogue: 0,0:02:04.99,0:02:06.03,Default,,0,0,0,,完成以后
Dialogue: 0,0:02:06.04,0:02:08.57,Default,,0,0,0,,就返回一个的表示完成的消息 “DONE”
Dialogue: 0,0:02:09.66,0:02:11.39,Default,,0,0,0,,如果你构造了一个流
Dialogue: 0,0:02:11.64,0:02:13.64,Default,,0,0,0,,这个流非常的长
Dialogue: 0,0:02:14.31,0:02:16.33,Default,,0,0,0,,当你调用这个过程
Dialogue: 0,0:02:16.41,0:02:19.77,Default,,0,0,0,,流中的元素会随着PRINT-STREAM的调用
Dialogue: 0,0:02:19.87,0:02:21.12,Default,,0,0,0,,而被依次计算出来
Dialogue: 0,0:02:21.32,0:02:22.81,Default,,0,0,0,,不会在一开始就全部计算出来
Dialogue: 0,0:02:24.30,0:02:25.66,Default,,0,0,0,,正因为如此 我们能够
Dialogue: 0,0:02:27.50,0:02:29.61,Default,,0,0,0,,我们能够处理非常长的流
Dialogue: 0,0:02:30.19,0:02:31.92,Default,,0,0,0,,多长呢？
Dialogue: 0,0:02:33.74,0:02:35.12,Default,,0,0,0,,可以是无限长
Dialogue: 0,0:02:35.90,0:02:38.04,Default,,0,0,0,,我们在计算机上实践一下
Dialogue: 0,0:02:38.92,0:02:41.96,Default,,0,0,0,,我可以在计算机前输入
Dialogue: 0,0:02:43.48,0:02:53.31,Default,,0,0,0,,我先定义一个函数 (INTEGERS-FROM N)
Dialogue: 0,0:02:54.24,0:02:57.13,Default,,0,0,0,,用于生成一个从N开始的正整数流
Dialogue: 0,0:03:00.36,0:03:19.16,Default,,0,0,0,,也就是 (CONS-STREAM N (INTEGERS-FROM (+ N 1))))
Dialogue: 0,0:03:24.41,0:03:25.61,Default,,0,0,0,,这样就我们要的全部整数
Dialogue: 0,0:03:28.99,0:03:31.50,Default,,0,0,0,,现在我来尝试得到所有的整数
Dialogue: 0,0:03:34.57,0:03:44.33,Default,,0,0,0,,(DEFINE INTEGERS (INTEGERS-FROM 1))
Dialogue: 0,0:03:48.84,0:03:50.94,Default,,0,0,0,,如果现在我执行 (NTH-STREAM 20 INTEGERS)
Dialogue: 0,0:03:54.41,0:03:55.80,Default,,0,0,0,,来查看第20个元素
Dialogue: 0,0:04:03.42,0:04:05.53,Default,,0,0,0,,得到21 因为索引是从0开始的
Dialogue: 0,0:04:06.84,0:04:08.88,Default,,0,0,0,,或者我们来点更复杂的
Dialogue: 0,0:04:09.45,0:04:10.84,Default,,0,0,0,,我再来定义一个谓词
Dialogue: 0,0:04:11.77,0:04:18.51,Default,,0,0,0,,谓词NO-SEVEN用来检测是否为7的倍数
Dialogue: 0,0:04:19.58,0:04:20.75,Default,,0,0,0,,它的判定方法是这样的：
Dialogue: 0,0:04:21.79,0:04:23.16,Default,,0,0,0,,如果整数X不是7的倍数
Dialogue: 0,0:04:28.82,0:04:33.96,Default,,0,0,0,,我取X除7的余数
Dialogue: 0,0:04:36.62,0:04:38.35,Default,,0,0,0,,余数不应该为0
Dialogue: 0,0:04:43.80,0:04:49.77,Default,,0,0,0,,这时用NO-SEVEN这个谓词
Dialogue: 0,0:04:50.22,0:04:59.12,Default,,0,0,0,,过滤全部的整数
Dialogue: 0,0:05:11.57,0:05:13.34,Default,,0,0,0,,这样我就得到了所有的
Dialogue: 0,0:05:13.63,0:05:15.05,Default,,0,0,0,,不是7的倍数的整数构成的流
Dialogue: 0,0:05:16.49,0:05:23.44,Default,,0,0,0,,如果我问 这些不是7的倍数的整数中
Dialogue: 0,0:05:24.70,0:05:26.48,Default,,0,0,0,,的第100个数是多少？
Dialogue: 0,0:05:26.86,0:05:28.11,Default,,0,0,0,,结果是117
Dialogue: 0,0:05:28.32,0:05:30.67,Default,,0,0,0,,或者我也可以问
Dialogue: 0,0:05:32.30,0:05:34.38,Default,,0,0,0,,这个流的所有元素都是些什么？
Dialogue: 0,0:05:35.27,0:05:40.35,Default,,0,0,0,,我可以用(PRINT-STREAM NS)来尝试打印这个流
Dialogue: 0,0:05:40.83,0:05:41.79,Default,,0,0,0,,它就会输出个不停
Dialogue: 0,0:05:45.10,0:05:47.07,Default,,0,0,0,,你可能需要等上很久才能得到全部结果
Dialogue: 0,0:05:52.67,0:05:53.84,Default,,0,0,0,,你可能会问了
Dialogue: 0,0:05:54.81,0:05:57.00,Default,,0,0,0,,这个数据结构
Dialogue: 0,0:05:58.28,0:06:00.65,Default,,0,0,0,,真的全部是由整数构成的吗？
Dialogue: 0,0:06:01.10,0:06:04.05,Default,,0,0,0,,现在我画一个图来演示下刚写的那个程序
Dialogue: 0,0:06:04.96,0:06:10.57,Default,,0,0,0,,这是我刚才键入的整数定义
Dialogue: 0,0:06:12.33,0:06:15.98,Default,,0,0,0,,它是一个由第一个整数和由下一个整数生成的流 所构成的序对
Dialogue: 0,0:06:17.61,0:06:19.77,Default,,0,0,0,,现在我们画个图来看看它到底是什么样
Dialogue: 0,0:06:22.72,0:06:24.32,Default,,0,0,0,,从概念上来说 这应该是一个盒子
Dialogue: 0,0:06:25.53,0:06:27.18,Default,,0,0,0,,这个盒子是(INTEGER-FROM N)
Dialogue: 0,0:06:27.42,0:06:29.08,Default,,0,0,0,,它接受一个参数N
Dialogue: 0,0:06:31.42,0:06:32.97,Default,,0,0,0,,然后返回一个流
Dialogue: 0,0:06:35.02,0:06:37.36,Default,,0,0,0,,这个无穷流表示从N开始的所有整数
Dialogue: 0,0:06:38.08,0:06:38.73,Default,,0,0,0,,我要做什么呢？
Dialogue: 0,0:06:38.75,0:06:42.38,Default,,0,0,0,,呃 这个是INT-FROM盒子
Dialogue: 0,0:06:45.07,0:06:45.80,Default,,0,0,0,,里面是什么样子呢？
Dialogue: 0,0:06:45.80,0:06:48.60,Default,,0,0,0,,取得参数N之后
Dialogue: 0,0:06:52.27,0:06:53.92,Default,,0,0,0,,将其 +1
Dialogue: 0,0:06:57.95,0:07:03.15,Default,,0,0,0,,然后把结果递归地传递给另一个INT-FROM盒子
Dialogue: 0,0:07:06.87,0:07:09.60,Default,,0,0,0,,把这个盒子的结果和最初的N
Dialogue: 0,0:07:10.24,0:07:12.78,Default,,0,0,0,,用CONS组合起来
Dialogue: 0,0:07:13.39,0:07:14.36,Default,,0,0,0,,就形成了一个流
Dialogue: 0,0:07:14.57,0:07:17.26,Default,,0,0,0,,我刚才写的那个过程 画出来就是这样子
Dialogue: 0,0:07:18.52,0:07:20.32,Default,,0,0,0,,我们看到的这类图像
Dialogue: 0,0:07:20.78,0:07:21.74,Default,,0,0,0,,首先是由Peter Henderson提出的
Dialogue: 0,0:07:21.76,0:07:23.32,Default,,0,0,0,,也就是前面课程中绘图语言的发明者
Dialogue: 0,0:07:23.32,0:07:24.75,Default,,0,0,0,,我们把这种图叫做Henderson图
Dialogue: 0,0:07:25.37,0:07:27.90,Default,,0,0,0,,画这种图需要遵守一定的约定
Dialogue: 0,0:07:28.53,0:07:32.51,Default,,0,0,0,,这些实线代表输出的流
Dialogue: 0,0:07:33.02,0:07:36.20,Default,,0,0,0,,这些虚线则是初始的输入值
Dialogue: 0,0:07:37.27,0:07:39.02,Default,,0,0,0,,而这个图描述的形状是——
Dialogue: 0,0:07:39.40,0:07:41.60,Default,,0,0,0,,它会取一个整数作为初始值
Dialogue: 0,0:07:41.80,0:07:42.91,Default,,0,0,0,,然后输出一个流
Dialogue: 0,0:07:46.35,0:07:48.22,Default,,0,0,0,,现在 你可能又要问了
Dialogue: 0,0:07:48.38,0:07:50.88,Default,,0,0,0,,那个INTEGERS的数据结构真的全部都是整数吗？
Dialogue: 0,0:07:52.09,0:07:54.91,Default,,0,0,0,,或者它只是经过了精心组织
Dialogue: 0,0:07:54.94,0:07:56.43,Default,,0,0,0,,以至于总可以在其中找到
Dialogue: 0,0:07:56.44,0:07:57.24,Default,,0,0,0,,我们需要的那个整数？
Dialogue: 0,0:07:57.95,0:07:59.74,Default,,0,0,0,,这有点像个哲学问题 不是么？
Dialogue: 0,0:07:59.78,0:08:01.69,Default,,0,0,0,,如果有一个东西
Dialogue: 0,0:08:02.14,0:08:03.96,Default,,0,0,0,,你不去观测它 能否知道它“存在”呢？
Dialogue: 0,0:08:04.45,0:08:07.34,Default,,0,0,0,,这就有点像
Dialogue: 0,0:08:07.36,0:08:09.42,Default,,0,0,0,,你在银行中的存款那样
Dialogue: 0,0:08:12.38,0:08:12.64,Default,,0,0,0,,好吧
Dialogue: 0,0:08:16.35,0:08:17.48,Default,,0,0,0,,我们再来看一个例子
Dialogue: 0,0:08:18.68,0:08:20.70,Default,,0,0,0,,这门课的第一节课
Dialogue: 0,0:08:20.72,0:08:22.72,Default,,0,0,0,,我们就讲了一个来自于亚历山大的算法
Dialogue: 0,0:08:23.29,0:08:25.80,Default,,0,0,0,,来自亚历山大的Heron提出的
Dialogue: 0,0:08:25.82,0:08:26.94,Default,,0,0,0,,一个用于计算平方根的算法
Dialogue: 0,0:08:28.47,0:08:32.03,Default,,0,0,0,,现在再来看一个 同样来自于亚力山大的算法
Dialogue: 0,0:08:32.03,0:08:35.08,Default,,0,0,0,,这个被称为Eratosthenes算法的方法
Dialogue: 0,0:08:36.19,0:08:38.44,Default,,0,0,0,,用于计算所有的质数
Dialogue: 0,0:08:41.16,0:08:42.83,Default,,0,0,0,,它被称为Eratosthenes筛法
Dialogue: 0,0:08:42.83,0:08:49.72,Default,,0,0,0,,它是这样的 一开始
Dialogue: 0,0:08:50.99,0:08:52.28,Default,,0,0,0,,先列举所有的整数
Dialogue: 0,0:08:52.60,0:08:53.53,Default,,0,0,0,,从2开始
Dialogue: 0,0:08:53.88,0:08:55.04,Default,,0,0,0,,然后取第一个整数
Dialogue: 0,0:08:55.08,0:08:56.67,Default,,0,0,0,,然后你发现 哦 2是一个质数
Dialogue: 0,0:08:57.31,0:08:58.35,Default,,0,0,0,,然后你考察剩余的整数
Dialogue: 0,0:08:58.68,0:09:00.88,Default,,0,0,0,,划掉其中可以被2整除的数
Dialogue: 0,0:09:01.52,0:09:04.73,Default,,0,0,0,,我把这个划掉 还有这个 这个
Dialogue: 0,0:09:05.25,0:09:06.35,Default,,0,0,0,,有点费时
Dialogue: 0,0:09:06.36,0:09:08.91,Default,,0,0,0,,我要对所有的整数进行这样的操作
Dialogue: 0,0:09:11.16,0:09:15.39,Default,,0,0,0,,我遍历整个整数表
Dialogue: 0,0:09:18.27,0:09:20.94,Default,,0,0,0,,划掉所有被2整除的数
Dialogue: 0,0:09:22.11,0:09:24.38,Default,,0,0,0,,所有的整数都操作完后
Dialogue: 0,0:09:24.78,0:09:26.72,Default,,0,0,0,,回过头再来看还剩些什么
Dialogue: 0,0:09:27.04,0:09:28.80,Default,,0,0,0,,好的 下一个数就是3了
Dialogue: 0,0:09:29.33,0:09:30.33,Default,,0,0,0,,3也是一个质数
Dialogue: 0,0:09:30.77,0:09:33.05,Default,,0,0,0,,现在 我会继续在剩下的数中
Dialogue: 0,0:09:33.36,0:09:35.07,Default,,0,0,0,,划掉所有被3整除的数
Dialogue: 0,0:09:35.08,0:09:43.80,Default,,0,0,0,,划掉 9、15、21、27、33 等等
Dialogue: 0,0:09:44.33,0:09:45.12,Default,,0,0,0,,我就不往下划了
Dialogue: 0,0:09:45.35,0:09:46.52,Default,,0,0,0,,然后看看我们还剩下什么
Dialogue: 0,0:09:47.25,0:09:49.84,Default,,0,0,0,,而下一个就是5了
Dialogue: 0,0:09:50.49,0:09:52.04,Default,,0,0,0,,我又遍历剩下的数
Dialogue: 0,0:09:52.43,0:09:54.51,Default,,0,0,0,,找到第一个能被5整除的数
Dialogue: 0,0:09:54.54,0:09:57.61,Default,,0,0,0,,把剩下的能被5整除的数都划掉
Dialogue: 0,0:09:58.35,0:09:59.24,Default,,0,0,0,,做完这个之后
Dialogue: 0,0:09:59.82,0:10:01.89,Default,,0,0,0,,下一个数就是7
Dialogue: 0,0:10:01.89,0:10:02.72,Default,,0,0,0,,再遍历剩下的数
Dialogue: 0,0:10:02.76,0:10:03.95,Default,,0,0,0,,划掉所有被7整除的数
Dialogue: 0,0:10:03.98,0:10:05.47,Default,,0,0,0,,然后一直这样下去
Dialogue: 0,0:10:06.81,0:10:07.40,Default,,0,0,0,,全部结束的时候
Dialogue: 0,0:10:07.40,0:10:09.10,Default,,0,0,0,,我也就得到了所有的质数
Dialogue: 0,0:10:09.90,0:10:13.31,Default,,0,0,0,,这就是Eratosthenes筛法
Dialogue: 0,0:10:15.43,0:10:17.69,Default,,0,0,0,,我们来看下实际代码
Dialogue: 0,0:10:17.93,0:10:19.85,Default,,0,0,0,,这个过程命名为SIEVE
Dialogue: 0,0:10:27.91,0:10:29.40,Default,,0,0,0,,这是对应的代码
Dialogue: 0,0:10:30.33,0:10:34.48,Default,,0,0,0,,SIEVE过程 以一个流S为参数
Dialogue: 0,0:10:38.77,0:10:39.93,Default,,0,0,0,,返回一个新的流
Dialogue: 0,0:10:40.27,0:10:41.84,Default,,0,0,0,,新的流的头部分 就是流S的头部分
Dialogue: 0,0:10:41.87,0:10:44.43,Default,,0,0,0,,回忆一下 我总是取剩下的数中的第一个
Dialogue: 0,0:10:44.91,0:10:48.75,Default,,0,0,0,,而尾部分则是把流S的尾部分
Dialogue: 0,0:10:51.08,0:10:53.72,Default,,0,0,0,,过滤掉所有
Dialogue: 0,0:10:53.74,0:10:55.32,Default,,0,0,0,,能被S头部分整除的数
Dialogue: 0,0:10:56.41,0:10:57.56,Default,,0,0,0,,然后再对结果筛选
Dialogue: 0,0:10:59.02,0:11:00.09,Default,,0,0,0,,这个代码就是这样
Dialogue: 0,0:11:01.98,0:11:04.68,Default,,0,0,0,,现在 为了得到由质数构成的无穷流
Dialogue: 0,0:11:05.02,0:11:06.90,Default,,0,0,0,,我们对从2开始的整数流进行SIEVE
Dialogue: 0,0:11:14.92,0:11:15.56,Default,,0,0,0,,我们来实践一下
Dialogue: 0,0:11:16.30,0:11:18.30,Default,,0,0,0,,实际上 我们可以在计算机中运行
Dialogue: 0,0:11:19.76,0:11:22.12,Default,,0,0,0,,我希望我已经预先输入过SIEVE的定义了
Dialogue: 0,0:11:22.86,0:11:24.06,Default,,0,0,0,,所以我可以定义
Dialogue: 0,0:11:24.92,0:11:33.45,Default,,0,0,0,,我可以把PRIMES定义为
Dialogue: 0,0:11:34.64,0:11:41.45,Default,,0,0,0,,(SIEVE (INTEGERS-FROM 2))
Dialogue: 0,0:11:46.76,0:11:48.10,Default,,0,0,0,,现在我就得到了质数构成的表
Dialogue: 0,0:11:48.10,0:11:50.99,Default,,0,0,0,,这样就得到了所有的质数 对吧？
Dialogue: 0,0:11:50.99,0:11:53.52,Default,,0,0,0,,比如我可以问 第20个质数是什么？
Dialogue: 0,0:12:00.73,0:12:01.68,Default,,0,0,0,,结果是73
Dialogue: 0,0:12:02.54,0:12:03.34,Default,,0,0,0,,那个短促的停顿
Dialogue: 0,0:12:03.36,0:12:04.92,Default,,0,0,0,,这是因为
Dialogue: 0,0:12:04.94,0:12:06.43,Default,,0,0,0,,在我询问第20个元素时
Dialogue: 0,0:12:06.46,0:12:07.68,Default,,0,0,0,,它才进行实际的计算
Dialogue: 0,0:12:10.37,0:12:11.29,Default,,0,0,0,,在这里 我也可以要求
Dialogue: 0,0:12:13.80,0:12:14.88,Default,,0,0,0,,打印所有的质数
Dialogue: 0,0:12:22.64,0:12:24.40,Default,,0,0,0,,解释器就开始计算并打印所有的质数
Dialogue: 0,0:12:25.35,0:12:26.28,Default,,0,0,0,,得花上好一会儿
Dialogue: 0,0:12:26.28,0:12:27.61,Default,,0,0,0,,才能打赢完整
Dialogue: 0,0:12:27.79,0:12:28.57,Default,,0,0,0,,所以先把它停掉
Dialogue: 0,0:12:32.03,0:12:33.13,Default,,0,0,0,,让我来画图演示一下
Dialogue: 0,0:12:33.13,0:12:34.17,Default,,0,0,0,,我已经画好了
Dialogue: 0,0:12:34.89,0:12:36.19,Default,,0,0,0,,这个过程的图形应该是什么样子呢？
Dialogue: 0,0:12:37.90,0:12:39.77,Default,,0,0,0,,用这类图形的约定来说
Dialogue: 0,0:12:39.82,0:12:40.54,Default,,0,0,0,,我有一个叫SIEVE的盒子
Dialogue: 0,0:12:42.61,0:12:43.56,Default,,0,0,0,,它是如何运作的呢？
Dialogue: 0,0:12:43.56,0:12:44.81,Default,,0,0,0,,它以一个流作为输入
Dialogue: 0,0:12:48.85,0:12:50.59,Default,,0,0,0,,分离流的头、尾部分
Dialogue: 0,0:12:50.87,0:12:53.26,Default,,0,0,0,,从SIEVE盒子出来的第一个东西
Dialogue: 0,0:12:53.48,0:12:54.97,Default,,0,0,0,,就是原来流的头部分
Dialogue: 0,0:12:58.20,0:13:00.92,Default,,0,0,0,,头部分同样也用于这个盒子
Dialogue: 0,0:13:02.55,0:13:05.10,Default,,0,0,0,,这个盒子会过滤流的尾部分
Dialogue: 0,0:13:05.55,0:13:08.33,Default,,0,0,0,,过滤的依据是 能否被头部分整除
Dialogue: 0,0:13:09.53,0:13:11.18,Default,,0,0,0,,过滤得到的不可整除的那些数
Dialogue: 0,0:13:11.24,0:13:13.12,Default,,0,0,0,,再放入另一个SIEVE盒子
Dialogue: 0,0:13:13.90,0:13:15.13,Default,,0,0,0,,然后把它们组合输出
Dialogue: 0,0:13:15.13,0:13:16.89,Default,,0,0,0,,你可以把SIEVE想象为一个过滤器
Dialogue: 0,0:13:17.20,0:13:19.23,Default,,0,0,0,,只不过它是一个无穷递归的过滤器
Dialogue: 0,0:13:19.65,0:13:20.88,Default,,0,0,0,,这是因为在SIEVE盒子中
Dialogue: 0,0:13:21.52,0:13:22.60,Default,,0,0,0,,还有另外一个SIEVE盒子
Dialogue: 0,0:13:23.37,0:13:25.85,Default,,0,0,0,,内部的盒子里面还有另外一个SIEVE盒子
Dialogue: 0,0:13:27.13,0:13:28.96,Default,,0,0,0,,我们现在逐渐有了非常厉害的能力
Dialogue: 0,0:13:28.96,0:13:32.84,Default,,0,0,0,,我们开始把 信号处理的方法
Dialogue: 0,0:13:33.90,0:13:36.41,Default,,0,0,0,,和计算中的递归结合在一起 来建模世界
Dialogue: 0,0:13:37.42,0:13:39.82,Default,,0,0,0,,还有很多像是这样的事
Dialogue: 0,0:13:40.97,0:13:42.09,Default,,0,0,0,,好的 有什么问题吗？
Dialogue: 0,0:13:48.19,0:13:49.16,Default,,0,0,0,,好吧 那我们休息一下
Dialogue: 0,0:13:49.64,0:14:04.12,Default,,0,0,0,,[音乐]
Dialogue: 0,0:14:04.46,0:14:08.12,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:14:12.08,0:14:16.38,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:14:16.44,0:14:20.22,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:14:20.35,0:14:25.05,Declare,,0,0,0,,{\an2\fad(500,500)}流 II
Dialogue: 0,0:14:28.65,0:14:30.36,Default,,0,0,0,,我们已经看了
Dialogue: 0,0:14:30.36,0:14:32.09,Default,,0,0,0,,好几个流式程序设计的例子
Dialogue: 0,0:14:34.79,0:14:39.21,Default,,0,0,0,,我们目前接触到的流过程
Dialogue: 0,0:14:39.72,0:14:41.32,Default,,0,0,0,,都有一个共同的特征
Dialogue: 0,0:14:41.49,0:14:43.63,Default,,0,0,0,,这些过程总是递归地
Dialogue: 0,0:14:44.16,0:14:46.49,Default,,0,0,0,,一次生成一个元素
Dialogue: 0,0:14:46.51,0:14:48.72,Default,,0,0,0,,再用CONS-STREAM连接起来
Dialogue: 0,0:14:49.15,0:14:50.86,Default,,0,0,0,,因此 我们一直把它当作是生成器
Dialogue: 0,0:14:50.92,0:14:53.63,Default,,0,0,0,,还有一种思考流式程序设计的方式
Dialogue: 0,0:14:53.79,0:14:56.96,Default,,0,0,0,,我们不认为程序是
Dialogue: 0,0:14:57.36,0:14:59.93,Default,,0,0,0,,沿着流逐一处理元素
Dialogue: 0,0:15:00.25,0:15:05.68,Default,,0,0,0,,而是一下子处理了整个流
Dialogue: 0,0:15:07.18,0:15:09.16,Default,,0,0,0,,我先来定义两个非常有用的过程
Dialogue: 0,0:15:09.23,0:15:11.50,Default,,0,0,0,,来帮助我说明
Dialogue: 0,0:15:12.41,0:15:13.60,Default,,0,0,0,,第一个过程是ADD-STREAMS
Dialogue: 0,0:15:15.36,0:15:18.25,Default,,0,0,0,,它接受两个流作为参数
Dialogue: 0,0:15:18.81,0:15:20.88,Default,,0,0,0,,S1和S2
Dialogue: 0,0:15:22.30,0:15:24.67,Default,,0,0,0,,它生成一个新的流
Dialogue: 0,0:15:24.99,0:15:28.17,Default,,0,0,0,,其元素是两个流相应位置元素的和
Dialogue: 0,0:15:30.22,0:15:31.88,Default,,0,0,0,,相当于是“按元素”的加
Dialogue: 0,0:15:32.97,0:15:33.95,Default,,0,0,0,,如果其中一个流是空的
Dialogue: 0,0:15:33.96,0:15:35.39,Default,,0,0,0,,我们就返回另一个
Dialogue: 0,0:15:36.81,0:15:38.96,Default,,0,0,0,,否则 我们就构建一个新的流
Dialogue: 0,0:15:39.90,0:15:42.96,Default,,0,0,0,,新流的头部分是两个流头部分之和
Dialogue: 0,0:15:44.00,0:15:44.88,Default,,0,0,0,,而新流的尾部分
Dialogue: 0,0:15:46.00,0:15:48.62,Default,,0,0,0,,则是递归地加和尾部分
Dialogue: 0,0:15:50.09,0:15:52.73,Default,,0,0,0,,这就会产生“按元素”地加的效果
Dialogue: 0,0:15:53.15,0:15:57.04,Default,,0,0,0,,另一个过程是SCALE-STREAM
Dialogue: 0,0:15:57.50,0:16:01.66,Default,,0,0,0,,SCALE-STREAM有两个参数 常数C和流S
Dialogue: 0,0:16:04.11,0:16:06.62,Default,,0,0,0,,结果生成的流
Dialogue: 0,0:16:07.18,0:16:09.50,Default,,0,0,0,,就是将流S的所有元素乘上了C
Dialogue: 0,0:16:09.71,0:16:11.21,Default,,0,0,0,,这很简单 就是一个MAP
Dialogue: 0,0:16:12.20,0:16:16.22,Default,,0,0,0,,用到的函数是 X*C
Dialogue: 0,0:16:16.35,0:16:17.80,Default,,0,0,0,,把这个函数MAP于整个流
Dialogue: 0,0:16:20.06,0:16:21.47,Default,,0,0,0,,有了这两个过程
Dialogue: 0,0:16:22.64,0:16:24.36,Default,,0,0,0,,我来给你们解释 什么叫做
Dialogue: 0,0:16:24.70,0:16:27.00,Default,,0,0,0,,“一下子处理整个流”
Dialogue: 0,0:16:28.12,0:16:28.73,Default,,0,0,0,,我们来看这个
Dialogue: 0,0:16:30.20,0:16:30.92,Default,,0,0,0,,假设这样
Dialogue: 0,0:16:31.68,0:16:52.35,Default,,0,0,0,,(DEFINE ONES (CONS-STREAM 1 ONES))
Dialogue: 0,0:16:54.86,0:16:55.52,Default,,0,0,0,,这是什么？
Dialogue: 0,0:16:56.95,0:16:58.94,Default,,0,0,0,,这是一个表示无穷个1的流
Dialogue: 0,0:16:59.96,0:17:01.44,Default,,0,0,0,,因为第一个元素是1
Dialogue: 0,0:17:03.33,0:17:05.15,Default,,0,0,0,,尾部分则是这样的
Dialogue: 0,0:17:05.55,0:17:06.83,Default,,0,0,0,,它的头部分是1
Dialogue: 0,0:17:07.63,0:17:09.02,Default,,0,0,0,,它的尾部分
Dialogue: 0,0:17:09.12,0:17:10.24,Default,,0,0,0,,的头部分又为1
Dialogue: 0,0:17:10.52,0:17:11.78,Default,,0,0,0,,以此类推
Dialogue: 0,0:17:11.78,0:17:13.32,Default,,0,0,0,,这就是无穷个1的流
Dialogue: 0,0:17:15.13,0:17:15.93,Default,,0,0,0,,现在根据ONES
Dialogue: 0,0:17:16.12,0:17:18.03,Default,,0,0,0,,我再给出另一种定义整数的方式
Dialogue: 0,0:17:19.47,0:17:27.36,Default,,0,0,0,,(DEFINE INTEGERS
Dialogue: 0,0:17:28.24,0:17:30.76,Default,,0,0,0,,当然 第一个数是1
Dialogue: 0,0:17:32.75,0:17:38.57,Default,,0,0,0,,(CONS-STREAM 1 (ADD-STREAM
Dialogue: 0,0:17:40.22,0:17:48.27,Default,,0,0,0,,INTEGERS ONES)))
Dialogue: 0,0:17:55.10,0:17:56.35,Default,,0,0,0,,整数流是这样的：
Dialogue: 0,0:17:57.24,0:17:59.98,Default,,0,0,0,,它的第一个元素是1
Dialogue: 0,0:18:00.88,0:18:02.32,Default,,0,0,0,,而其余部分则是
Dialogue: 0,0:18:03.12,0:18:06.14,Default,,0,0,0,,依次把每个整数加1
Dialogue: 0,0:18:06.64,0:18:08.19,Default,,0,0,0,,因此 整数流的第二个元素则是
Dialogue: 0,0:18:08.51,0:18:11.96,Default,,0,0,0,,整数流的第一个元素加1
Dialogue: 0,0:18:13.92,0:18:15.18,Default,,0,0,0,,下一个数又要加1
Dialogue: 0,0:18:15.20,0:18:16.48,Default,,0,0,0,,第三个元素则是
Dialogue: 0,0:18:16.62,0:18:20.41,Default,,0,0,0,,INTEGER流尾部分的第一个元素
Dialogue: 0,0:18:20.84,0:18:21.96,Default,,0,0,0,,加1
Dialogue: 0,0:18:22.51,0:18:23.76,Default,,0,0,0,,这也就相当于
Dialogue: 0,0:18:25.08,0:18:28.65,Default,,0,0,0,,最初整数流的第一个元素加1
Dialogue: 0,0:18:28.86,0:18:31.25,Default,,0,0,0,,然后再加1 以此类推
Dialogue: 0,0:18:35.24,0:18:36.31,Default,,0,0,0,,这看起来有点匪夷所思
Dialogue: 0,0:18:36.31,0:18:37.47,Default,,0,0,0,,这样的过程可以正常运行
Dialogue: 0,0:18:38.12,0:18:38.99,Default,,0,0,0,,关键在于延时求值
Dialogue: 0,0:18:40.15,0:18:43.32,Default,,0,0,0,,我们来看这个ONES
Dialogue: 0,0:18:43.87,0:18:45.92,Default,,0,0,0,,这看起来根本不可能
Dialogue: 0,0:18:46.25,0:18:47.63,Default,,0,0,0,,因为它突然说
Dialogue: 0,0:18:47.79,0:18:48.96,Default,,0,0,0,,在定义ONES的时候
Dialogue: 0,0:18:49.00,0:18:50.91,Default,,0,0,0,,发现它依赖于它本身
Dialogue: 0,0:18:51.13,0:18:52.08,Default,,0,0,0,,它之所以可以运行是因为
Dialogue: 0,0:18:52.09,0:18:54.04,Default,,0,0,0,,这里暗中隐藏着延时求值
Dialogue: 0,0:18:55.25,0:18:56.56,Default,,0,0,0,,这个代码实际上是
Dialogue: 0,0:18:57.79,0:18:59.69,Default,,0,0,0,,回忆下 CONS-STREAM是只是一个缩写
Dialogue: 0,0:19:00.29,0:19:01.15,Default,,0,0,0,,实际上则是
Dialogue: 0,0:19:01.85,0:19:08.99,Default,,0,0,0,,(CONS 1 (DELAY ONES))
Dialogue: 0,0:19:12.14,0:19:13.21,Default,,0,0,0,,它又是怎么运作的呢？
Dialogue: 0,0:19:15.50,0:19:16.88,Default,,0,0,0,,你想要定义ONES
Dialogue: 0,0:19:18.02,0:19:20.24,Default,,0,0,0,,我来看看ONES要被定义成什么样
Dialogue: 0,0:19:20.70,0:19:23.40,Default,,0,0,0,,ONES被定义为一个序对
Dialogue: 0,0:19:24.89,0:19:28.11,Default,,0,0,0,,其CAR部分为1
Dialogue: 0,0:19:28.32,0:19:29.45,Default,,0,0,0,,而CDR部分则是
Dialogue: 0,0:19:29.45,0:19:30.73,Default,,0,0,0,,是一个计算某物的PROMISE
Dialogue: 0,0:19:30.75,0:19:31.69,Default,,0,0,0,,我现在还不用关心
Dialogue: 0,0:19:32.71,0:19:34.25,Default,,0,0,0,,所以虽然这时ONES还没有定义
Dialogue: 0,0:19:34.28,0:19:36.30,Default,,0,0,0,,但对我并不造成什么影响
Dialogue: 0,0:19:37.27,0:19:39.45,Default,,0,0,0,,一旦运行了整个定义 ONES就被定义了
Dialogue: 0,0:19:40.67,0:19:42.83,Default,,0,0,0,,所以 访问它尾部的时候 它就有定义了
Dialogue: 0,0:19:44.92,0:19:46.06,Default,,0,0,0,,这一点非常隐讳
Dialogue: 0,0:19:46.59,0:19:47.90,Default,,0,0,0,,整数流的定义也是如此
Dialogue: 0,0:19:48.47,0:19:50.46,Default,,0,0,0,,我可以在这里引用INTEGERS是因为
Dialogue: 0,0:19:51.13,0:19:53.21,Default,,0,0,0,,是因为这个CONS-STREAM的缘故
Dialogue: 0,0:19:53.85,0:19:55.24,Default,,0,0,0,,用CONS-STREAM把1
Dialogue: 0,0:19:55.37,0:19:57.05,Default,,0,0,0,,和一个不立即需要的东西组合起来
Dialogue: 0,0:19:57.05,0:19:59.60,Default,,0,0,0,,所以我在运行INTEGERS的定义的时候
Dialogue: 0,0:20:00.22,0:20:01.90,Default,,0,0,0,,并不会发现INTEGER没有定义过
Dialogue: 0,0:20:06.32,0:20:08.27,Default,,0,0,0,,听上去非常玄乎
Dialogue: 0,0:20:08.44,0:20:11.50,Default,,0,0,0,,让我用图像来演示一下INTEGERS的原理
Dialogue: 0,0:20:12.43,0:20:14.72,Default,,0,0,0,,怎么画呢？
Dialogue: 0,0:20:15.02,0:20:16.30,Default,,0,0,0,,首先是ONES这个流
Dialogue: 0,0:20:20.51,0:20:21.88,Default,,0,0,0,,它作为参数输入
Dialogue: 0,0:20:23.26,0:20:24.92,Default,,0,0,0,,进入一个加法器
Dialogue: 0,0:20:24.96,0:20:26.59,Default,,0,0,0,,进行流的加法运算
Dialogue: 0,0:20:29.31,0:20:35.87,Default,,0,0,0,,输出则是整数流INTEGERS
Dialogue: 0,0:20:40.76,0:20:42.70,Default,,0,0,0,,这里 这个整数流又重新进入加法器
Dialogue: 0,0:20:44.94,0:20:46.97,Default,,0,0,0,,形成了一个小型的反馈回路
Dialogue: 0,0:20:48.06,0:20:49.42,Default,,0,0,0,,我需要在某处接入最初的ONES
Dialogue: 0,0:20:50.09,0:20:52.88,Default,,0,0,0,,才能让它生效
Dialogue: 0,0:20:57.10,0:20:58.64,Default,,0,0,0,,在真实的信号处理中
Dialogue: 0,0:20:58.72,0:21:02.48,Default,,0,0,0,,这里是一个被初始化为1的延时元件
Dialogue: 0,0:21:02.91,0:21:05.90,Default,,0,0,0,,这就是ONES程序的图示
Dialogue: 0,0:21:07.86,0:21:09.63,Default,,0,0,0,,事实上 这个非常像
Dialogue: 0,0:21:09.80,0:21:13.77,Default,,0,0,0,,如果你见过真正的信号方块图的话
Dialogue: 0,0:21:13.77,0:21:16.30,Default,,0,0,0,,这个图形非常像累加器
Dialogue: 0,0:21:16.35,0:21:17.48,Default,,0,0,0,,有穷状态累加器
Dialogue: 0,0:21:17.98,0:21:20.06,Default,,0,0,0,,事实上 我们可以稍加修改
Dialogue: 0,0:21:21.18,0:21:23.96,Default,,0,0,0,,就可以让它对一个流做积分
Dialogue: 0,0:21:25.37,0:21:26.97,Default,,0,0,0,,或者说是有穷状态累加器
Dialogue: 0,0:21:27.00,0:21:28.04,Default,,0,0,0,,你怎么认为都可以
Dialogue: 0,0:21:28.44,0:21:30.86,Default,,0,0,0,,现在 不再是输入ONES 输出INTEGERS
Dialogue: 0,0:21:31.68,0:21:32.38,Default,,0,0,0,,我们要做的是
Dialogue: 0,0:21:32.91,0:21:34.83,Default,,0,0,0,,这里有一个流S为输入
Dialogue: 0,0:21:35.76,0:21:40.56,Default,,0,0,0,,我们要计算这个流的积分
Dialogue: 0,0:21:42.60,0:21:44.09,Default,,0,0,0,,也就是累加这个流的值
Dialogue: 0,0:21:44.44,0:21:45.63,Default,,0,0,0,,这看起来几乎就是一样的
Dialogue: 0,0:21:45.66,0:21:46.84,Default,,0,0,0,,我们要做的就是
Dialogue: 0,0:21:47.02,0:21:48.08,Default,,0,0,0,,当S从这里输入时
Dialogue: 0,0:21:49.21,0:21:50.64,Default,,0,0,0,,在把它求和之前
Dialogue: 0,0:21:50.91,0:21:54.26,Default,,0,0,0,,先将其乘以dt
Dialogue: 0,0:21:57.68,0:22:00.00,Default,,0,0,0,,剩下的就不用改了
Dialogue: 0,0:22:00.00,0:22:00.91,Default,,0,0,0,,我们就得到了一个盒子
Dialogue: 0,0:22:03.36,0:22:04.56,Default,,0,0,0,,一个积分器
Dialogue: 0,0:22:09.79,0:22:11.26,Default,,0,0,0,,对一个流S进行积分
Dialogue: 0,0:22:11.90,0:22:14.51,Default,,0,0,0,,把这里的1替换为
Dialogue: 0,0:22:14.94,0:22:18.35,Default,,0,0,0,,该积分的初始值
Dialogue: 0,0:22:19.98,0:22:21.60,Default,,0,0,0,,这个看起来就非常像
Dialogue: 0,0:22:22.35,0:22:24.86,Default,,0,0,0,,信号处理中的方框图了
Dialogue: 0,0:22:25.27,0:22:28.11,Default,,0,0,0,,事实上 这个图示对应的是这样一个过程
Dialogue: 0,0:22:31.49,0:22:33.61,Default,,0,0,0,,对一个流进行积分
Dialogue: 0,0:22:34.01,0:22:35.48,Default,,0,0,0,,INTEGRAL函数接收一个流
Dialogue: 0,0:22:35.68,0:22:36.86,Default,,0,0,0,,返回一个新的流
Dialogue: 0,0:22:37.53,0:22:40.67,Default,,0,0,0,,它还接收一个初始值和某个时间常量
Dialogue: 0,0:22:42.23,0:22:42.97,Default,,0,0,0,,然后呢？
Dialogue: 0,0:22:43.04,0:22:45.05,Default,,0,0,0,,首先在内部定义一个流INT
Dialogue: 0,0:22:45.20,0:22:46.32,Default,,0,0,0,,之所以要给它一个内部名字
Dialogue: 0,0:22:46.33,0:22:48.86,Default,,0,0,0,,原因在于可以使它反馈 以形成循环
Dialogue: 0,0:22:49.40,0:22:50.80,Default,,0,0,0,,INT的定义是
Dialogue: 0,0:22:51.10,0:22:53.32,Default,,0,0,0,,一个以INITIA-VALUE开始的流
Dialogue: 0,0:22:54.97,0:23:00.14,Default,,0,0,0,,而其余的元素则是把它们加起来
Dialogue: 0,0:23:01.28,0:23:03.61,Default,,0,0,0,,我们把输入流乘以dt
Dialogue: 0,0:23:03.87,0:23:04.92,Default,,0,0,0,,然后和INT相加
Dialogue: 0,0:23:06.88,0:23:09.66,Default,,0,0,0,,整个INTEGRAL函数的结果就是这个INT
Dialogue: 0,0:23:10.69,0:23:12.94,Default,,0,0,0,,我们使用这种内部定义的语法
Dialogue: 0,0:23:13.34,0:23:15.66,Default,,0,0,0,,是为了可以在内部引用它自己
Dialogue: 0,0:23:21.88,0:23:23.71,Default,,0,0,0,,我们还可以做更多的事情
Dialogue: 0,0:23:23.71,0:23:24.51,Default,,0,0,0,,来看这个
Dialogue: 0,0:23:25.63,0:23:26.89,Default,,0,0,0,,斐波那契数
Dialogue: 0,0:23:26.89,0:23:32.62,Default,,0,0,0,,(DEFINE FIBS
Dialogue: 0,0:23:36.35,0:23:37.63,Default,,0,0,0,,斐波那契数是什么呢？
Dialogue: 0,0:23:37.98,0:23:46.54,Default,,0,0,0,,它从0开始
Dialogue: 0,0:23:48.65,0:23:50.09,Default,,0,0,0,,下一个是1
Dialogue: 0,0:23:56.26,0:23:59.16,Default,,0,0,0,,的其余的斐波那契数是通过
Dialogue: 0,0:23:59.87,0:24:11.00,Default,,0,0,0,,把它们的尾部分求和而得来
Dialogue: 0,0:24:17.57,0:24:19.28,Default,,0,0,0,,这样来定义斐波那契数
Dialogue: 0,0:24:20.58,0:24:21.43,Default,,0,0,0,,这是如何运作的呢？
Dialogue: 0,0:24:21.43,0:24:24.19,Default,,0,0,0,,我们来试试
Dialogue: 0,0:24:24.20,0:24:26.49,Default,,0,0,0,,假如开始计算斐波那契数
Dialogue: 0,0:24:29.64,0:24:31.92,Default,,0,0,0,,首先告诉你 它以0和1开始
Dialogue: 0,0:24:35.79,0:24:38.22,Default,,0,0,0,,而0和1之后的数则是
Dialogue: 0,0:24:39.18,0:24:40.86,Default,,0,0,0,,通过加和两个流而得
Dialogue: 0,0:24:41.12,0:24:42.59,Default,,0,0,0,,一个流是FIBS本身
Dialogue: 0,0:24:44.06,0:24:45.69,Default,,0,0,0,,另一个是FIBS的尾部分
Dialogue: 0,0:24:49.12,0:24:51.16,Default,,0,0,0,,如果我知道这是以0和1起始的
Dialogue: 0,0:24:51.79,0:24:55.42,Default,,0,0,0,,我就能知道 FIBS是以0和1起始的
Dialogue: 0,0:24:55.74,0:24:57.40,Default,,0,0,0,,那么 FIBS的尾部分则应该以1开始
Dialogue: 0,0:24:58.36,0:24:59.45,Default,,0,0,0,,一旦我知道了这点
Dialogue: 0,0:24:59.66,0:25:02.11,Default,,0,0,0,,我就知道 FIBS的下一个数就是0+1=1
Dialogue: 0,0:25:02.96,0:25:04.60,Default,,0,0,0,,它也同样告诉我这里是1
Dialogue: 0,0:25:04.62,0:25:05.72,Default,,0,0,0,,这里也是1
Dialogue: 0,0:25:06.30,0:25:07.28,Default,,0,0,0,,知道了这些之后
Dialogue: 0,0:25:07.29,0:25:08.76,Default,,0,0,0,,我就知道下一个是2
Dialogue: 0,0:25:09.39,0:25:11.70,Default,,0,0,0,,这里是2 这里也是2
Dialogue: 0,0:25:11.70,0:25:12.56,Default,,0,0,0,,下一个是3
Dialogue: 0,0:25:14.72,0:25:15.79,Default,,0,0,0,,这里是3
Dialogue: 0,0:25:16.19,0:25:17.13,Default,,0,0,0,,这里是5
Dialogue: 0,0:25:18.67,0:25:19.96,Default,,0,0,0,,这个定义完全说得通
Dialogue: 0,0:25:21.50,0:25:22.78,Default,,0,0,0,,这个定义只有一行
Dialogue: 0,0:25:22.83,0:25:25.00,Default,,0,0,0,,当然 我也可以在计算机中
Dialogue: 0,0:25:25.00,0:25:26.62,Default,,0,0,0,,原原本本地键入计算机中
Dialogue: 0,0:25:27.04,0:25:28.94,Default,,0,0,0,,然后要求输出斐波那契数
Dialogue: 0,0:25:28.94,0:25:30.15,Default,,0,0,0,,然后它就会不断输出
Dialogue: 0,0:25:32.79,0:25:35.20,Default,,0,0,0,,这又像是在学习递归
Dialogue: 0,0:25:36.81,0:25:39.79,Default,,0,0,0,,过程可以被递归定义
Dialogue: 0,0:25:40.99,0:25:43.50,Default,,0,0,0,,我们也可以递归地定义数据对象
Dialogue: 0,0:25:45.16,0:25:46.92,Default,,0,0,0,,但你们一点儿不应该感到吃惊
Dialogue: 0,0:25:47.12,0:25:49.50,Default,,0,0,0,,因为现在 你们应该真正相信
Dialogue: 0,0:25:49.52,0:25:53.05,Default,,0,0,0,,过程与数据之间没有区别
Dialogue: 0,0:25:53.09,0:25:53.92,Default,,0,0,0,,事实上 就某种意义上来说
Dialogue: 0,0:25:53.93,0:25:56.41,Default,,0,0,0,,流也是由过程来实现的
Dialogue: 0,0:25:56.43,0:25:57.79,Default,,0,0,0,,只不过我们不把它看做过程而已
Dialogue: 0,0:25:58.21,0:26:00.38,Default,,0,0,0,,因此既然我们有递归过程
Dialogue: 0,0:26:00.70,0:26:03.63,Default,,0,0,0,,那么 有递归数据也就不足为奇了
Dialogue: 0,0:26:07.72,0:26:09.69,Default,,0,0,0,,虽然流非常简洁
Dialogue: 0,0:26:09.72,0:26:13.92,Default,,0,0,0,,但不幸的是 有些问题流无法解决
Dialogue: 0,0:26:14.99,0:26:16.48,Default,,0,0,0,,我来举个例子
Dialogue: 0,0:26:17.58,0:26:20.35,Default,,0,0,0,,同样地 我们来想象一下
Dialogue: 0,0:26:20.76,0:26:23.61,Default,,0,0,0,,我们正在构建求解微分方程的模拟计算机
Dialogue: 0,0:26:25.20,0:26:34.30,Default,,0,0,0,,比如求解方程 y' = y^2
Dialogue: 0,0:26:34.76,0:26:36.16,Default,,0,0,0,,我会给你一个初值
Dialogue: 0,0:26:36.39,0:26:38.03,Default,,0,0,0,,y(0) = 1
Dialogue: 0,0:26:41.48,0:26:44.06,Default,,0,0,0,,dt = .0001
Dialogue: 0,0:26:46.77,0:26:47.53,Default,,0,0,0,,很久之前
Dialogue: 0,0:26:48.00,0:26:50.65,Default,,0,0,0,,就有人构建模拟计算机 来解决这类问题
Dialogue: 0,0:26:51.36,0:26:53.02,Default,,0,0,0,,原理非常简单
Dialogue: 0,0:26:53.02,0:26:54.41,Default,,0,0,0,,你首先需要一个积分器
Dialogue: 0,0:27:00.04,0:27:01.69,Default,,0,0,0,,比如这个INT盒子
Dialogue: 0,0:27:03.05,0:27:06.48,Default,,0,0,0,,我们设定初始值 y(0) = 1
Dialogue: 0,0:27:08.53,0:27:10.92,Default,,0,0,0,,现在如果我们送入一个输入 就会得到输出
Dialogue: 0,0:27:10.96,0:27:13.16,Default,,0,0,0,,输出的结果就是y
Dialogue: 0,0:27:14.25,0:27:16.96,Default,,0,0,0,,输入的是y的导数
Dialogue: 0,0:27:17.52,0:27:20.52,Default,,0,0,0,,在这里 导数 y' = y^2
Dialogue: 0,0:27:21.49,0:27:27.07,Default,,0,0,0,,如果我们用MAP把SQUARE映射在这些值上
Dialogue: 0,0:27:30.73,0:27:32.09,Default,,0,0,0,,然后把这个引过来
Dialogue: 0,0:27:36.28,0:27:38.48,Default,,0,0,0,,这个方块图
Dialogue: 0,0:27:38.57,0:27:41.08,Default,,0,0,0,,就是用于求解这个微分方程的模拟计算机
Dialogue: 0,0:27:42.91,0:27:44.80,Default,,0,0,0,,现在我们用代码
Dialogue: 0,0:27:44.80,0:27:46.78,Default,,0,0,0,,来表示下这个过程
Dialogue: 0,0:27:47.23,0:27:48.72,Default,,0,0,0,,这个图究竟表示的是什么呢？
Dialogue: 0,0:27:49.39,0:27:58.30,Default,,0,0,0,,(DEFINE Y
Dialogue: 0,0:28:04.28,0:28:11.68,Default,,0,0,0,,(INTEGRAL DY 1 .001))
Dialogue: 0,0:28:13.79,0:28:15.45,Default,,0,0,0,,接下来
Dialogue: 0,0:28:16.80,0:28:20.85,Default,,0,0,0,,通过MAP SQUARE 来表示dy
Dialogue: 0,0:28:20.85,0:28:32.81,Default,,0,0,0,,(DEFINE DY (MAP SQUARE Y))
Dialogue: 0,0:28:33.51,0:28:36.80,Default,,0,0,0,,这就是这个模拟计算机的流式描述
Dialogue: 0,0:28:38.62,0:28:40.32,Default,,0,0,0,,不幸的是 它并不起效
Dialogue: 0,0:28:41.41,0:28:42.67,Default,,0,0,0,,你也可以发现这是为什么
Dialogue: 0,0:28:42.97,0:28:44.99,Default,,0,0,0,,因为我把Y定义为
Dialogue: 0,0:28:46.43,0:28:47.85,Default,,0,0,0,,DY 的积分
Dialogue: 0,0:28:49.04,0:28:50.65,Default,,0,0,0,,它会问 对什么的积分？
Dialogue: 0,0:28:51.19,0:28:52.12,Default,,0,0,0,,没定义啊
Dialogue: 0,0:28:53.71,0:28:57.63,Default,,0,0,0,,所以这个定义必须写在这个定义的后面
Dialogue: 0,0:28:58.77,0:29:00.51,Default,,0,0,0,,另一方面 如果先定义了dy
Dialogue: 0,0:29:00.51,0:29:03.02,Default,,0,0,0,,定义为 (MAP SQUARE 某个东西)
Dialogue: 0,0:29:03.58,0:29:04.64,Default,,0,0,0,,这个也还没有定义
Dialogue: 0,0:29:05.77,0:29:08.17,Default,,0,0,0,,我既不能先写这个 又不能先写那个
Dialogue: 0,0:29:09.08,0:29:11.58,Default,,0,0,0,,这个游戏就没法玩了
Dialogue: 0,0:29:17.56,0:29:18.51,Default,,0,0,0,,怎样来解决呢？
Dialogue: 0,0:29:20.60,0:29:21.84,Default,,0,0,0,,我们可以用ONES来解决
Dialogue: 0,0:29:22.20,0:29:25.82,Default,,0,0,0,,所以 我们在这里定义的ONES
Dialogue: 0,0:29:27.24,0:29:29.90,Default,,0,0,0,,我们之所以可以使用ONES来定义ONES
Dialogue: 0,0:29:30.40,0:29:32.03,Default,,0,0,0,,这是因为其中的延时求值
Dialogue: 0,0:29:32.43,0:29:34.12,Default,,0,0,0,,CONS-STREAM是延时求值的
Dialogue: 0,0:29:34.77,0:29:35.79,Default,,0,0,0,,那么 这又为什么说得通呢？
Dialogue: 0,0:29:35.92,0:29:38.51,Default,,0,0,0,,为什么CONS-STREAM是延时求值的是合理的呢？
Dialogue: 0,0:29:40.73,0:29:43.13,Default,,0,0,0,,原因在于 CONS-STREAM不需要其尾部分
Dialogue: 0,0:29:43.48,0:29:44.88,Default,,0,0,0,,就可以完成有意义的事
Dialogue: 0,0:29:45.95,0:29:46.84,Default,,0,0,0,,比如我说
Dialogue: 0,0:29:47.48,0:29:49.64,Default,,0,0,0,,这个是1和某个东西组成的流
Dialogue: 0,0:29:49.92,0:29:51.69,Default,,0,0,0,,虽然我对它一无所知
Dialogue: 0,0:29:52.16,0:29:54.03,Default,,0,0,0,,但我却知道整个流是以1开始的
Dialogue: 0,0:29:54.87,0:29:57.29,Default,,0,0,0,,所以用CONS-STREAM来构造是有意义的
Dialogue: 0,0:29:59.96,0:30:01.24,Default,,0,0,0,,我们在这里放了一个DELAY
Dialogue: 0,0:30:01.42,0:30:04.65,Default,,0,0,0,,这就使得我们能够进行某种自引用的定义
Dialogue: 0,0:30:06.32,0:30:07.95,Default,,0,0,0,,INTEGRAL也可以用这种方式来解决
Dialogue: 0,0:30:08.19,0:30:12.52,Default,,0,0,0,,注意 对于INTEGRAL来说 我可以
Dialogue: 0,0:30:14.60,0:30:16.08,Default,,0,0,0,,让我们回过头来再看看INTEGRAL的定义
Dialogue: 0,0:30:17.58,0:30:18.56,Default,,0,0,0,,求积分的时候
Dialogue: 0,0:30:21.39,0:30:25.00,Default,,0,0,0,,知道INTEGRAL的第一个元素是合理的
Dialogue: 0,0:30:26.04,0:30:27.87,Default,,0,0,0,,尽管还不知道整个流是什么样的
Dialogue: 0,0:30:28.97,0:30:30.17,Default,,0,0,0,,这是因为INTEGRAL中第一个元素
Dialogue: 0,0:30:30.20,0:30:32.16,Default,,0,0,0,,总会是你传递过来的INITIAL-VALUE
Dialogue: 0,0:30:33.14,0:30:36.11,Default,,0,0,0,,所以INTEGRAL可以用CONS-STREAM来实现
Dialogue: 0,0:30:37.09,0:30:37.98,Default,,0,0,0,,我们可以定义它
Dialogue: 0,0:30:38.25,0:30:40.88,Default,,0,0,0,,甚至不用知道要积分的流是什么
Dialogue: 0,0:30:42.84,0:30:45.18,Default,,0,0,0,,只需要知道初始值是什么就行了
Dialogue: 0,0:30:46.71,0:30:48.17,Default,,0,0,0,,INTEGRAL还可以修改得更为智能
Dialogue: 0,0:30:48.41,0:30:50.68,Default,,0,0,0,,我们给它一个待积分的流
Dialogue: 0,0:30:50.83,0:30:51.92,Default,,0,0,0,,以及一个初值
Dialogue: 0,0:30:52.11,0:30:54.99,Default,,0,0,0,,直到你要求沿着这个流求解积分时
Dialogue: 0,0:30:55.21,0:30:56.97,Default,,0,0,0,,我才关心这个流是什么
Dialogue: 0,0:30:58.43,0:31:00.51,Default,,0,0,0,,换句话说INTEGRAL可以像CONS-STREAM一样
Dialogue: 0,0:31:00.57,0:31:03.74,Default,,0,0,0,,你可以认为INTEGRAL被放在DELAY之中
Dialogue: 0,0:31:03.76,0:31:04.86,Default,,0,0,0,,我们这样修改
Dialogue: 0,0:31:05.61,0:31:07.02,Default,,0,0,0,,这个过程是像这样的
Dialogue: 0,0:31:07.65,0:31:08.75,Default,,0,0,0,,这是另一个版本的INTEGRAL
Dialogue: 0,0:31:08.89,0:31:10.54,Default,,0,0,0,,这个跟之前的版本非常相似
Dialogue: 0,0:31:11.10,0:31:13.34,Default,,0,0,0,,只不过作为参数的流
Dialogue: 0,0:31:13.77,0:31:15.69,Default,,0,0,0,,必须要是一个延时对象
Dialogue: 0,0:31:17.11,0:31:18.43,Default,,0,0,0,,这个INTEGRAL又是如何运作的呢？
Dialogue: 0,0:31:18.85,0:31:21.79,Default,,0,0,0,,我们在内部定义的INT则是
Dialogue: 0,0:31:22.14,0:31:24.19,Default,,0,0,0,,用CONS-STREAM构造一个流
Dialogue: 0,0:31:24.73,0:31:26.44,Default,,0,0,0,,初值还是INITIAL-VALUE
Dialogue: 0,0:31:27.16,0:31:29.68,Default,,0,0,0,,但是在CONS-STREAM中
Dialogue: 0,0:31:29.74,0:31:32.30,Default,,0,0,0,,要注意 这里面有个隐藏的DELAY
Dialogue: 0,0:31:34.95,0:31:39.07,Default,,0,0,0,,只有在这个CONS-STREAM的内部
Dialogue: 0,0:31:39.82,0:31:42.11,Default,,0,0,0,,我才会查看延时对象的实际内容
Dialogue: 0,0:31:43.18,0:31:45.79,Default,,0,0,0,,所以 答案的第一个元素将会是初值
Dialogue: 0,0:31:45.97,0:31:47.90,Default,,0,0,0,,如果有人想访问我的尾部分
Dialogue: 0,0:31:48.40,0:31:49.42,Default,,0,0,0,,此时
Dialogue: 0,0:31:50.00,0:31:51.72,Default,,0,0,0,,我会FORCE该延迟对象
Dialogue: 0,0:31:52.62,0:31:53.60,Default,,0,0,0,,把结果记作S
Dialogue: 0,0:31:54.44,0:31:55.60,Default,,0,0,0,,然后再进行ADD-STREAMS
Dialogue: 0,0:31:56.36,0:31:59.26,Default,,0,0,0,,这个INTEGRAL就有点像CONS-STREAM
Dialogue: 0,0:31:59.26,0:32:02.59,Default,,0,0,0,,直到你确实需要知道第一个元素的时候
Dialogue: 0,0:32:03.88,0:32:07.13,Default,,0,0,0,,它才会去查看DELAYED-S是什么
Dialogue: 0,0:32:10.12,0:32:11.02,Default,,0,0,0,,如果这样的话
Dialogue: 0,0:32:11.52,0:32:12.83,Default,,0,0,0,,也就能求解 y' = y^2 了
Dialogue: 0,0:32:13.36,0:32:15.20,Default,,0,0,0,,这里我们只需要
Dialogue: 0,0:32:16.00,0:32:25.31,Default,,0,0,0,,把Y定义为对延时对象DY的积分
Dialogue: 0,0:32:27.09,0:32:28.22,Default,,0,0,0,,所以Y的定义就变成了
Dialogue: 0,0:32:28.40,0:32:34.36,Default,,0,0,0,,(INTEGRAL (DELAY DY) 1 .001)
Dialogue: 0,0:32:34.38,0:32:35.13,Default,,0,0,0,,这样一来就可以了
Dialogue: 0,0:32:35.28,0:32:37.44,Default,,0,0,0,,因为我输入Y的定义
Dialogue: 0,0:32:38.00,0:32:39.68,Default,,0,0,0,,它是某个东西的积分
Dialogue: 0,0:32:40.20,0:32:42.68,Default,,0,0,0,,但这是个延迟对象 我现在还不用关心
Dialogue: 0,0:32:44.60,0:32:46.32,Default,,0,0,0,,这之后 再定义DY
Dialogue: 0,0:32:46.32,0:32:47.37,Default,,0,0,0,,现在Y就有定义了
Dialogue: 0,0:32:47.55,0:32:48.89,Default,,0,0,0,,所以我在定义DY时
Dialogue: 0,0:32:49.13,0:32:50.67,Default,,0,0,0,,它可以知道Y的定义
Dialogue: 0,0:32:51.70,0:32:52.84,Default,,0,0,0,,一切都正常了
Dialogue: 0,0:32:52.84,0:32:54.33,Default,,0,0,0,,两个流都有第一个元素
Dialogue: 0,0:32:54.92,0:32:56.25,Default,,0,0,0,,当我不断取得下一个元素
Dialogue: 0,0:32:56.27,0:32:57.31,Default,,0,0,0,,沿着流做MAP运算时
Dialogue: 0,0:32:57.37,0:32:58.88,Default,,0,0,0,,Y和DY都被定义过了
Dialogue: 0,0:33:00.59,0:33:04.24,Default,,0,0,0,,所以为了继续这个游戏 我们不能仅仅
Dialogue: 0,0:33:04.67,0:33:07.13,Default,,0,0,0,,只使用隐藏在流中的DELAY
Dialogue: 0,0:33:08.36,0:33:08.97,Default,,0,0,0,,有问题么？
Dialogue: 0,0:33:13.52,0:33:14.27,Default,,0,0,0,,休息一下吧
Dialogue: 0,0:33:14.72,0:33:26.86,Default,,0,0,0,,[音乐]
Dialogue: 0,0:33:27.37,0:33:30.94,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:33:52.16,0:33:55.26,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:33:55.42,0:33:59.26,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:34:00.38,0:34:03.93,Declare,,0,0,0,,{\an2\fad(500,500)}流 II
Dialogue: 0,0:34:07.30,0:34:10.04,Default,,0,0,0,,上节课的最后
Dialogue: 0,0:34:10.89,0:34:11.80,Default,,0,0,0,,不知道你们注意到没有
Dialogue: 0,0:34:11.82,0:34:13.55,Default,,0,0,0,,事情正变得糟糕起来
Dialogue: 0,0:34:14.83,0:34:18.40,Default,,0,0,0,,我们讲了很多关于 流
Dialogue: 0,0:34:19.16,0:34:22.68,Default,,0,0,0,,以及分离程序中的时间和计算机中的时间
Dialogue: 0,0:34:22.86,0:34:26.28,Default,,0,0,0,,这些分离都被隐藏在流中了
Dialogue: 0,0:34:27.28,0:34:29.50,Default,,0,0,0,,上节课快结束时我们发现
Dialogue: 0,0:34:29.71,0:34:32.19,Default,,0,0,0,,为了真正发挥这种方法的优势
Dialogue: 0,0:34:32.22,0:34:34.38,Default,,0,0,0,,我们需要另外的DELAY
Dialogue: 0,0:34:34.38,0:34:35.85,Default,,0,0,0,,不只需要隐藏在CONS-STREAM中的DELAY
Dialogue: 0,0:34:36.09,0:34:37.95,Default,,0,0,0,,还需要显式地使用DELAY
Dialogue: 0,0:34:39.03,0:34:41.88,Default,,0,0,0,,我只是用微分方程举了一个很简单的例子
Dialogue: 0,0:34:42.35,0:34:44.08,Default,,0,0,0,,但是如果你有一个非常复杂的系统
Dialogue: 0,0:34:44.12,0:34:45.40,Default,,0,0,0,,里面充斥着各种各样的自循环
Dialogue: 0,0:34:45.95,0:34:47.84,Default,,0,0,0,,那就很难再发现
Dialogue: 0,0:34:47.90,0:34:49.31,Default,,0,0,0,,在什么地方需要额外的DELAY了
Dialogue: 0,0:34:49.92,0:34:51.18,Default,,0,0,0,,假如你一不小心漏了一个
Dialogue: 0,0:34:51.45,0:34:54.36,Default,,0,0,0,,就很难发现程序为什么不起效
Dialogue: 0,0:34:55.55,0:34:57.15,Default,,0,0,0,,这是一种混乱
Dialogue: 0,0:34:57.79,0:35:01.71,Default,,0,0,0,,让我们能够使用DELAY
Dialogue: 0,0:35:02.08,0:35:04.70,Default,,0,0,0,,有时却会让程序设计变得非常复杂
Dialogue: 0,0:35:04.72,0:35:06.80,Default,,0,0,0,,因为它们不能完全隐藏在流中
Dialogue: 0,0:35:08.51,0:35:09.79,Default,,0,0,0,,那么 有没有什么解决方案呢？
Dialogue: 0,0:35:11.13,0:35:12.67,Default,,0,0,0,,所幸的是 有
Dialogue: 0,0:35:13.48,0:35:16.08,Default,,0,0,0,,我们可以修改整个语言
Dialogue: 0,0:35:16.14,0:35:18.19,Default,,0,0,0,,使得所有的过程都表现得像CONS-STREAM一样
Dialogue: 0,0:35:19.10,0:35:21.48,Default,,0,0,0,,这样所有的过程都会
Dialogue: 0,0:35:22.32,0:35:25.45,Default,,0,0,0,,自动、隐式地为它的参数加上DELAY
Dialogue: 0,0:35:25.45,0:35:26.43,Default,,0,0,0,,这是什么意思呢？
Dialogue: 0,0:35:27.52,0:35:29.53,Default,,0,0,0,,就是说 当你调用一个过程时
Dialogue: 0,0:35:30.16,0:35:31.88,Default,,0,0,0,,参数并不会立即求值
Dialogue: 0,0:35:32.21,0:35:34.70,Default,,0,0,0,,只有在需要被求值的时候 它们才会被求值
Dialogue: 0,0:35:34.89,0:35:36.72,Default,,0,0,0,,它们也可能被传递给其它的过程
Dialogue: 0,0:35:36.76,0:35:38.12,Default,,0,0,0,,而这个过程也不会求值这些参数
Dialogue: 0,0:35:39.26,0:35:41.90,Default,,0,0,0,,因此这些过程间传递的是PROMISE
Dialogue: 0,0:35:42.15,0:35:44.46,Default,,0,0,0,,直到最后
Dialogue: 0,0:35:44.65,0:35:47.34,Default,,0,0,0,,你需要查看某个值的时候
Dialogue: 0,0:35:47.36,0:35:48.99,Default,,0,0,0,,可能是因为一个基本运算所需要
Dialogue: 0,0:35:49.37,0:35:51.48,Default,,0,0,0,,这是你才实际求值这些PROMISE
Dialogue: 0,0:35:52.38,0:35:53.16,Default,,0,0,0,,像这样修改语言之后
Dialogue: 0,0:35:53.36,0:35:55.37,Default,,0,0,0,,由于所有的东西都是统一被延时的
Dialogue: 0,0:35:57.16,0:35:59.00,Default,,0,0,0,,就不需要任何显式的DELAY了
Dialogue: 0,0:35:59.04,0:36:01.55,Default,,0,0,0,,因为它自动地内建在语言之中了
Dialogue: 0,0:36:03.24,0:36:04.38,Default,,0,0,0,,换句话来说
Dialogue: 0,0:36:05.10,0:36:08.14,Default,,0,0,0,,从技术上来说 我所描述的
Dialogue: 0,0:36:09.02,0:36:10.76,Default,,0,0,0,,如果修改后的语言被称作
Dialogue: 0,0:36:12.19,0:36:16.57,Default,,0,0,0,,所谓的“正则序求值”语言
Dialogue: 0,0:36:20.20,0:36:23.47,Default,,0,0,0,,这个跟我们一直使用的语言不同
Dialogue: 0,0:36:23.87,0:36:33.79,Default,,0,0,0,,我们所用的是“应用序求值”语言
Dialogue: 0,0:36:34.56,0:36:36.83,Default,,0,0,0,,还记得应用序求值的代换模型吧
Dialogue: 0,0:36:36.83,0:36:40.49,Default,,0,0,0,,当你求值一个组合式的时候
Dialogue: 0,0:36:40.51,0:36:42.11,Default,,0,0,0,,你需要先计算出每一个元素的值
Dialogue: 0,0:36:43.59,0:36:45.40,Default,,0,0,0,,先求值所有的参数
Dialogue: 0,0:36:45.72,0:36:47.42,Default,,0,0,0,,再把它们代换入过程的体
Dialogue: 0,0:36:47.60,0:36:49.55,Default,,0,0,0,,正则序则不是这样
Dialogue: 0,0:36:49.89,0:36:51.90,Default,,0,0,0,,你所做的则是
Dialogue: 0,0:36:52.76,0:36:54.41,Default,,0,0,0,,直接将参数代换入过程的体
Dialogue: 0,0:36:54.44,0:36:56.19,Default,,0,0,0,,而不先对参数求值
Dialogue: 0,0:36:56.54,0:36:58.08,Default,,0,0,0,,只是代换入了一个计算参数的PROMISE
Dialogue: 0,0:36:58.81,0:36:59.90,Default,,0,0,0,,换句话说就是
Dialogue: 0,0:36:59.92,0:37:02.09,Default,,0,0,0,,把作为参数的整个表达式
Dialogue: 0,0:37:02.28,0:37:04.84,Default,,0,0,0,,直接代入过程的体进行代换
Dialogue: 0,0:37:05.16,0:37:06.88,Default,,0,0,0,,在此之间从不进行任何化简
Dialogue: 0,0:37:07.16,0:37:08.76,Default,,0,0,0,,直到遇到一个基本运算符
Dialogue: 0,0:37:09.47,0:37:10.99,Default,,0,0,0,,这就是所谓的正则序求值语言
Dialogue: 0,0:37:12.17,0:37:13.12,Default,,0,0,0,,我们为什么不这样做呢？
Dialogue: 0,0:37:13.82,0:37:14.60,Default,,0,0,0,,这样做了之后
Dialogue: 0,0:37:15.00,0:37:17.34,Default,,0,0,0,,我们就获得了延时求值的所有优点
Dialogue: 0,0:37:17.90,0:37:18.80,Default,,0,0,0,,而不会一片混乱
Dialogue: 0,0:37:18.94,0:37:20.19,Default,,0,0,0,,事实上 如果我们这样做了之后
Dialogue: 0,0:37:20.43,0:37:22.67,Default,,0,0,0,,CONS也会是延时求值的
Dialogue: 0,0:37:22.68,0:37:24.57,Default,,0,0,0,,就和CONS-STREAM一样
Dialogue: 0,0:37:24.71,0:37:25.82,Default,,0,0,0,,我们就不再需要流了
Dialogue: 0,0:37:26.36,0:37:28.54,Default,,0,0,0,,因为表自动成为了流
Dialogue: 0,0:37:29.55,0:37:30.70,Default,,0,0,0,,表和流有一样的行为
Dialogue: 0,0:37:30.75,0:37:32.35,Default,,0,0,0,,所有的数据结构也会像那样
Dialogue: 0,0:37:32.35,0:37:33.64,Default,,0,0,0,,所有的都是
Dialogue: 0,0:37:35.07,0:37:37.63,Default,,0,0,0,,直到需要答案的时候
Dialogue: 0,0:37:37.66,0:37:39.42,Default,,0,0,0,,才会去实际的求值
Dialogue: 0,0:37:40.80,0:37:43.58,Default,,0,0,0,,不必再担心 什么时候需要显式地标注DELAY
Dialogue: 0,0:37:44.79,0:37:46.16,Default,,0,0,0,,为什么不这样做呢？
Dialogue: 0,0:37:47.16,0:37:48.81,Default,,0,0,0,,首先 已经有人这样做过了
Dialogue: 0,0:37:49.23,0:37:51.85,Default,,0,0,0,,有一些十分优雅的语言
Dialogue: 0,0:37:51.85,0:37:55.21,Default,,0,0,0,,其中最为人称道的是一门名为 Miranda 的语言
Dialogue: 0,0:37:55.77,0:37:56.76,Default,,0,0,0,,它是由
Dialogue: 0,0:37:57.44,0:37:59.80,Default,,0,0,0,,肯特大学的 David Turner 开发的
Dialogue: 0,0:38:00.71,0:38:01.93,Default,,0,0,0,,它就是用这样的原理实现的
Dialogue: 0,0:38:01.93,0:38:03.34,Default,,0,0,0,,Miranda是正则序求值语言
Dialogue: 0,0:38:04.27,0:38:05.55,Default,,0,0,0,,它的数据结构
Dialogue: 0,0:38:06.16,0:38:08.41,Default,,0,0,0,,看起来像表 实际上确实流
Dialogue: 0,0:38:08.96,0:38:10.91,Default,,0,0,0,,你不需要任何特殊的功能
Dialogue: 0,0:38:11.28,0:38:13.28,Default,,0,0,0,,就可以在Miranda中编写普通的过程
Dialogue: 0,0:38:13.32,0:38:14.97,Default,,0,0,0,,来解决质数、八皇后这样的问题
Dialogue: 0,0:38:14.97,0:38:16.35,Default,,0,0,0,,这些都是语言的内建功能
Dialogue: 0,0:38:17.93,0:38:18.91,Default,,0,0,0,,但这样做也要付出代价
Dialogue: 0,0:38:21.19,0:38:22.36,Default,,0,0,0,,还记得我们为什么引入流了吗？
Dialogue: 0,0:38:23.17,0:38:27.48,Default,,0,0,0,,我们分离了程序的时间和它实际执行的时间
Dialogue: 0,0:38:27.96,0:38:28.88,Default,,0,0,0,,如果我们引入了DELAY
Dialogue: 0,0:38:29.04,0:38:30.33,Default,,0,0,0,,这样就在所有的地方完成了解耦
Dialogue: 0,0:38:30.40,0:38:31.42,Default,,0,0,0,,而不单单是在流中
Dialogue: 0,0:38:32.19,0:38:33.14,Default,,0,0,0,,我们的初衷是什么？
Dialogue: 0,0:38:33.14,0:38:38.11,Default,,0,0,0,,我们把程序设计看做是指定计算过程
Dialogue: 0,0:38:39.30,0:38:40.62,Default,,0,0,0,,如果我们放弃了对时间的控制
Dialogue: 0,0:38:40.65,0:38:42.41,Default,,0,0,0,,尽管语言变得优雅起来
Dialogue: 0,0:38:43.74,0:38:45.87,Default,,0,0,0,,但是它的表达力却有所下降
Dialogue: 0,0:38:47.03,0:38:49.84,Default,,0,0,0,,这里面还有一些我们无法消除的区别
Dialogue: 0,0:38:51.48,0:38:53.15,Default,,0,0,0,,其中之一就是迭代
Dialogue: 0,0:38:53.98,0:38:56.44,Default,,0,0,0,,还记得这个程序吗？
Dialogue: 0,0:38:56.96,0:38:58.28,Default,,0,0,0,,迭代式的阶乘
Dialogue: 0,0:38:58.44,0:39:00.48,Default,,0,0,0,,这是我们很早之前就研究过的
Dialogue: 0,0:39:01.23,0:39:02.97,Default,,0,0,0,,过程FACT-ITER
Dialogue: 0,0:39:03.04,0:39:04.91,Default,,0,0,0,,有一个内部过程ITER
Dialogue: 0,0:39:05.18,0:39:07.50,Default,,0,0,0,,它含有两个状态PRODUCT和COUNTER
Dialogue: 0,0:39:08.70,0:39:10.96,Default,,0,0,0,,它们随着循环不断迭代
Dialogue: 0,0:39:12.12,0:39:13.68,Default,,0,0,0,,之所以说这个过程是迭代的
Dialogue: 0,0:39:13.71,0:39:14.83,Default,,0,0,0,,是因为它没有创建新状态
Dialogue: 0,0:39:15.73,0:39:17.45,Default,,0,0,0,,之所以没有创建新状态
Dialogue: 0,0:39:17.47,0:39:20.25,Default,,0,0,0,,是因为在调用ITER时
Dialogue: 0,0:39:20.30,0:39:22.86,Default,,0,0,0,,作为参数传递给它自己的始终是这些东西
Dialogue: 0,0:39:23.90,0:39:25.39,Default,,0,0,0,,在代换模型中
Dialogue: 0,0:39:25.55,0:39:27.79,Default,,0,0,0,,Gerald教授给你们讲解过
Dialogue: 0,0:39:28.72,0:39:30.01,Default,,0,0,0,,在迭代过程中
Dialogue: 0,0:39:30.03,0:39:31.44,Default,,0,0,0,,状态并不需要增长
Dialogue: 0,0:39:31.82,0:39:34.22,Default,,0,0,0,,因此这是一个迭代过程
Dialogue: 0,0:39:34.99,0:39:37.47,Default,,0,0,0,,但是如果用正则序语言
Dialogue: 0,0:39:37.47,0:39:39.10,Default,,0,0,0,,来运行这段程序
Dialogue: 0,0:39:41.15,0:39:42.17,Default,,0,0,0,,这就会导致
Dialogue: 0,0:39:42.88,0:39:44.96,Default,,0,0,0,,这个过程不再是迭代式了
Dialogue: 0,0:39:45.65,0:39:48.67,Default,,0,0,0,,如果你仔细地思考代换模型
Dialogue: 0,0:39:48.67,0:39:49.90,Default,,0,0,0,,在这里我就不细说了
Dialogue: 0,0:39:51.20,0:39:52.35,Default,,0,0,0,,这个表达式会不断增长
Dialogue: 0,0:39:52.36,0:39:53.18,Default,,0,0,0,,为什么会这样？
Dialogue: 0,0:39:53.28,0:39:55.20,Default,,0,0,0,,因为当ITER调用自己时
Dialogue: 0,0:39:55.85,0:39:57.31,Default,,0,0,0,,参数是这个乘法表达式
Dialogue: 0,0:39:58.08,0:39:59.36,Default,,0,0,0,,而在正则序语言中
Dialogue: 0,0:39:59.39,0:40:01.16,Default,,0,0,0,,这个乘法并不会在这里求值
Dialogue: 0,0:40:02.51,0:40:03.82,Default,,0,0,0,,传递给自己并代换的
Dialogue: 0,0:40:03.93,0:40:05.68,Default,,0,0,0,,只是这个乘法计算的PROMISE
Dialogue: 0,0:40:06.67,0:40:08.03,Default,,0,0,0,,然后继续代换下去
Dialogue: 0,0:40:09.76,0:40:11.55,Default,,0,0,0,,我调用自己
Dialogue: 0,0:40:11.84,0:40:14.04,Default,,0,0,0,,用的是计算这个乘法的PROMISE
Dialogue: 0,0:40:14.04,0:40:17.82,Default,,0,0,0,,但其中的一个因数也是个PROMISE
Dialogue: 0,0:40:18.40,0:40:19.43,Default,,0,0,0,,然后我又自调用
Dialogue: 0,0:40:19.43,0:40:21.13,Default,,0,0,0,,如果你用代换模型
Dialogue: 0,0:40:21.98,0:40:23.60,Default,,0,0,0,,来推演这个迭代步骤
Dialogue: 0,0:40:23.77,0:40:26.83,Default,,0,0,0,,你会发现同样的状态增长
Dialogue: 0,0:40:27.16,0:40:28.96,Default,,0,0,0,,所有的PROMISE都需要被记住
Dialogue: 0,0:40:28.97,0:40:30.76,Default,,0,0,0,,以便在最后被调用
Dialogue: 0,0:40:31.79,0:40:35.02,Default,,0,0,0,,所以 正则序的缺点之一
Dialogue: 0,0:40:35.05,0:40:36.86,Default,,0,0,0,,就是无法有效地表达迭代
Dialogue: 0,0:40:36.98,0:40:39.60,Default,,0,0,0,,也许这个理由有点偏理论
Dialogue: 0,0:40:39.61,0:40:43.90,Default,,0,0,0,,但事实上 那些使用这类语言来编写
Dialogue: 0,0:40:44.27,0:40:47.56,Default,,0,0,0,,实际操作系统的人 也都遇到了这类问题
Dialogue: 0,0:40:48.20,0:40:50.75,Default,,0,0,0,,当然 完全可以
Dialogue: 0,0:40:51.64,0:40:54.38,Default,,0,0,0,,用这类语言实现一个文本编辑器
Dialogue: 0,0:40:54.61,0:40:56.08,Default,,0,0,0,,但是你才用了一会儿
Dialogue: 0,0:40:56.72,0:40:59.39,Default,,0,0,0,,就发现已经占用了3MB空间
Dialogue: 0,0:40:59.44,0:41:02.04,Default,,0,0,0,,我想 那些遇到这类问题的人
Dialogue: 0,0:41:02.16,0:41:05.60,Default,,0,0,0,,把它叫做 “拖尾问题”
Dialogue: 0,0:41:05.82,0:41:08.20,Default,,0,0,0,,由于不能有效地表达迭代计算
Dialogue: 0,0:41:08.24,0:41:10.46,Default,,0,0,0,,导致堆积了一堆没有被调用的PROMISE
Dialogue: 0,0:41:10.72,0:41:14.81,Default,,0,0,0,,针对这类语言的一个研究方向就是
Dialogue: 0,0:41:14.83,0:41:17.48,Default,,0,0,0,,找出一种有效的编译器技术
Dialogue: 0,0:41:17.82,0:41:19.85,Default,,0,0,0,,来避免这种所谓的“拖尾问题”
Dialogue: 0,0:41:20.17,0:41:21.61,Default,,0,0,0,,这并不简单
Dialogue: 0,0:41:23.94,0:41:27.31,Default,,0,0,0,,但是 还有一个很突出的问题
Dialogue: 0,0:41:27.96,0:41:31.04,Default,,0,0,0,,使你的语言不能变成正则序
Dialogue: 0,0:41:32.51,0:41:33.29,Default,,0,0,0,,问题就在于
Dialogue: 0,0:41:35.05,0:41:38.09,Default,,0,0,0,,正则序和副作用
Dialogue: 0,0:41:38.89,0:41:40.19,Default,,0,0,0,,是不相容的
Dialogue: 0,0:41:42.00,0:41:43.96,Default,,0,0,0,,它们不能很好地相互配合
Dialogue: 0,0:41:45.44,0:41:46.65,Default,,0,0,0,,这是因为 你不能
Dialogue: 0,0:41:48.28,0:41:50.80,Default,,0,0,0,,你不能一边
Dialogue: 0,0:41:51.00,0:41:54.33,Default,,0,0,0,,建模具有局部状态的对象
Dialogue: 0,0:41:55.72,0:41:56.96,Default,,0,0,0,,同时又
Dialogue: 0,0:41:57.18,0:41:59.55,Default,,0,0,0,,使用正则序的技巧来解耦时间
Dialogue: 0,0:42:00.40,0:42:03.55,Default,,0,0,0,,我来举一个非常简单的例子
Dialogue: 0,0:42:03.79,0:42:05.50,Default,,0,0,0,,假设语言是正则序求值
Dialogue: 0,0:42:07.52,0:42:09.55,Default,,0,0,0,,例子是这样的
Dialogue: 0,0:42:09.55,0:42:10.52,Default,,0,0,0,,注意现在是正则序求值
Dialogue: 0,0:42:10.52,0:42:12.22,Default,,0,0,0,,(DEFINE X 0)
Dialogue: 0,0:42:13.57,0:42:15.56,Default,,0,0,0,,这只是变量的初始化
Dialogue: 0,0:42:15.75,0:42:17.69,Default,,0,0,0,,现在我要定义一个有趣的函数
Dialogue: 0,0:42:18.57,0:42:20.44,Default,,0,0,0,,它就是恒等函数ID
Dialogue: 0,0:42:22.64,0:42:23.90,Default,,0,0,0,,它所做的就是
Dialogue: 0,0:42:24.11,0:42:26.60,Default,,0,0,0,,用X来记录上一次调用它时N的值
Dialogue: 0,0:42:31.40,0:42:34.16,Default,,0,0,0,,因此(ID N)就返回N
Dialogue: 0,0:42:34.17,0:42:35.39,Default,,0,0,0,,但还要把X赋值为N
Dialogue: 0,0:42:36.76,0:42:38.54,Default,,0,0,0,,最后再定义一个过程INC
Dialogue: 0,0:42:39.55,0:42:42.30,Default,,0,0,0,,也非常简单
Dialogue: 0,0:42:42.58,0:42:45.34,Default,,0,0,0,,假设在正则序求值的语言里
Dialogue: 0,0:42:46.27,0:42:47.23,Default,,0,0,0,,求值下面的表达式
Dialogue: 0,0:42:47.23,0:42:52.83,Default,,0,0,0,,我输入 (DEFINE Y (INC (ID 3)))
Dialogue: 0,0:42:52.83,0:42:53.96,Default,,0,0,0,,因此Y的值应该是4
Dialogue: 0,0:42:57.41,0:42:58.35,Default,,0,0,0,,X应该是多少呢？
Dialogue: 0,0:42:59.52,0:43:02.16,Default,,0,0,0,,X应该是最后一次被记住的值
Dialogue: 0,0:43:02.64,0:43:04.01,Default,,0,0,0,,也就是我调用函数ID的时候
Dialogue: 0,0:43:04.71,0:43:06.73,Default,,0,0,0,,你可能会想 这里X应该是3
Dialogue: 0,0:43:06.91,0:43:07.52,Default,,0,0,0,,但是并不是这样
Dialogue: 0,0:43:08.53,0:43:11.15,Default,,0,0,0,,这是因为当我在这里定义Y的时候
Dialogue: 0,0:43:11.79,0:43:13.45,Default,,0,0,0,,Y的真正定义却是
Dialogue: 0,0:43:13.47,0:43:15.71,Default,,0,0,0,,一个调用函数ID的PROMISE的增量
Dialogue: 0,0:43:17.00,0:43:18.17,Default,,0,0,0,,因为我没有访问Y
Dialogue: 0,0:43:18.36,0:43:20.25,Default,,0,0,0,,所以ID没有运行
Dialogue: 0,0:43:21.56,0:43:23.20,Default,,0,0,0,,我输入这个定义之后
Dialogue: 0,0:43:23.31,0:43:24.80,Default,,0,0,0,,然后查询X得到的结果是0
Dialogue: 0,0:43:28.36,0:43:31.20,Default,,0,0,0,,现在 我输入Y查询它的值
Dialogue: 0,0:43:31.52,0:43:32.43,Default,,0,0,0,,就会得到结果4
Dialogue: 0,0:43:32.67,0:43:35.16,Default,,0,0,0,,对Y的主动查询
Dialogue: 0,0:43:35.29,0:43:37.42,Default,,0,0,0,,会导致ID运行
Dialogue: 0,0:43:38.72,0:43:40.48,Default,,0,0,0,,现在X=3就被记住
Dialogue: 0,0:43:40.74,0:43:41.87,Default,,0,0,0,,所以上面这里的X就应该是0
Dialogue: 0,0:43:41.93,0:43:42.96,Default,,0,0,0,,下面这里是3
Dialogue: 0,0:43:43.28,0:43:46.16,Default,,0,0,0,,这是一个非常简单的场景
Dialogue: 0,0:43:46.30,0:43:49.28,Default,,0,0,0,,但你会发现 调试正则序语言
Dialogue: 0,0:43:50.36,0:43:53.34,Default,,0,0,0,,的交互式程序
Dialogue: 0,0:43:54.12,0:43:55.88,Default,,0,0,0,,会变得相当混乱
Dialogue: 0,0:43:57.10,0:43:58.12,Default,,0,0,0,,很令人迷惑
Dialogue: 0,0:43:59.69,0:44:02.04,Default,,0,0,0,,导致这样的深层次的原因
Dialogue: 0,0:44:02.80,0:44:06.41,Default,,0,0,0,,也就是引入DELAY的根本理念
Dialogue: 0,0:44:06.92,0:44:08.43,Default,,0,0,0,,是因为我们抛弃了时间的概念
Dialogue: 0,0:44:09.78,0:44:11.75,Default,,0,0,0,,也因为如此我们可以处理一些无穷的情况
Dialogue: 0,0:44:11.75,0:44:12.97,Default,,0,0,0,,我们抛弃了时间
Dialogue: 0,0:44:12.99,0:44:14.27,Default,,0,0,0,,就没有必要等它们运行
Dialogue: 0,0:44:17.55,0:44:20.44,Default,,0,0,0,,我们把计算机中事件发生的顺序
Dialogue: 0,0:44:20.83,0:44:22.11,Default,,0,0,0,,与程序中的顺序 分离开来
Dialogue: 0,0:44:22.35,0:44:25.28,Default,,0,0,0,,但是当我们谈及状态、赋值和改变的时候
Dialogue: 0,0:44:25.48,0:44:27.42,Default,,0,0,0,,这些又都是我们想要控制的
Dialogue: 0,0:44:28.76,0:44:33.82,Default,,0,0,0,,我们的目的有着根本性的矛盾
Dialogue: 0,0:44:34.57,0:44:39.12,Default,,0,0,0,,这又让我们进入了一个哲学问题
Dialogue: 0,0:44:39.13,0:44:40.75,Default,,0,0,0,,用什么样的模型
Dialogue: 0,0:44:40.78,0:44:41.77,Default,,0,0,0,,和从什么角度来看这个世界
Dialogue: 0,0:44:42.41,0:44:44.30,Default,,0,0,0,,有时这也被称为
Dialogue: 0,0:44:44.76,0:44:46.60,Default,,0,0,0,,“函数式程序设计的争论”
Dialogue: 0,0:44:54.19,0:44:56.60,Default,,0,0,0,,所谓的“纯函数式语言”
Dialogue: 0,0:44:57.07,0:44:59.20,Default,,0,0,0,,是完全没有副作用的
Dialogue: 0,0:45:00.44,0:45:01.63,Default,,0,0,0,,不需要副作用
Dialogue: 0,0:45:01.64,0:45:03.02,Default,,0,0,0,,也就不需要赋值运算符
Dialogue: 0,0:45:03.34,0:45:05.72,Default,,0,0,0,,也就没有什么糟糕的后果
Dialogue: 0,0:45:06.36,0:45:07.93,Default,,0,0,0,,可以使用类似代换模型
Dialogue: 0,0:45:07.93,0:45:10.48,Default,,0,0,0,,程序更像是数学
Dialogue: 0,0:45:10.76,0:45:13.82,Default,,0,0,0,,而不像现实世界中的模型和对象
Dialogue: 0,0:45:15.05,0:45:17.17,Default,,0,0,0,,函数式语言有很多了不起的特性
Dialogue: 0,0:45:17.17,0:45:19.63,Default,,0,0,0,,没有时间的概念 所以完全不用担心同步的问题
Dialogue: 0,0:45:20.64,0:45:23.72,Default,,0,0,0,,如果你想在并行算法中应用一些东西
Dialogue: 0,0:45:24.72,0:45:28.20,Default,,0,0,0,,你可以在这些并行过程中随心所欲地使用
Dialogue: 0,0:45:29.40,0:45:31.44,Default,,0,0,0,,从来不担心同步问题
Dialogue: 0,0:45:31.50,0:45:33.34,Default,,0,0,0,,在这种环境下这样做是非常方便的
Dialogue: 0,0:45:33.64,0:45:35.71,Default,,0,0,0,,代价则是 放弃了赋值
Dialogue: 0,0:45:39.10,0:45:41.32,Default,,0,0,0,,函数式语言的支持者会认为
Dialogue: 0,0:45:41.34,0:45:43.04,Default,,0,0,0,,这点代价算不了什么
Dialogue: 0,0:45:44.52,0:45:46.51,Default,,0,0,0,,在大部分情况下 你都不应该使用赋值
Dialogue: 0,0:45:46.88,0:45:48.27,Default,,0,0,0,,如果用你放弃了赋值
Dialogue: 0,0:45:48.43,0:45:51.40,Default,,0,0,0,,你可以得到一个比对象世界
Dialogue: 0,0:45:51.96,0:45:53.24,Default,,0,0,0,,好得多的世界
Dialogue: 0,0:45:54.19,0:45:56.30,Default,,0,0,0,,怎么来反驳这个观点呢？
Dialogue: 0,0:45:56.30,0:45:58.59,Default,,0,0,0,,想想 我们如何走到这一步的
Dialogue: 0,0:46:00.06,0:46:03.79,Default,,0,0,0,,我们尝试建模具有局部状态的对象
Dialogue: 0,0:46:04.44,0:46:06.49,Default,,0,0,0,,想一想Gerald教授给你们讲的随机数生成器
Dialogue: 0,0:46:07.16,0:46:08.67,Default,,0,0,0,,这里有一个随机数生成器
Dialogue: 0,0:46:09.28,0:46:10.62,Default,,0,0,0,,它内部有一些状态
Dialogue: 0,0:46:10.83,0:46:12.08,Default,,0,0,0,,用来计算下一个随机数
Dialogue: 0,0:46:12.12,0:46:14.08,Default,,0,0,0,,下下一个 以及再下一个
Dialogue: 0,0:46:14.28,0:46:16.14,Default,,0,0,0,,我们想要把这些状态跟
Dialogue: 0,0:46:16.43,0:46:18.96,Default,,0,0,0,,计算π的Cesaro算法分离开来
Dialogue: 0,0:46:19.84,0:46:20.92,Default,,0,0,0,,这就是我们为什么需要赋值
Dialogue: 0,0:46:20.97,0:46:22.91,Default,,0,0,0,,我们想要把状态封装在模块中
Dialogue: 0,0:46:24.07,0:46:26.36,Default,,0,0,0,,函数式语言程序员可能会说
Dialogue: 0,0:46:26.38,0:46:27.56,Default,,0,0,0,,“你搞错了”
Dialogue: 0,0:46:27.56,0:46:29.84,Default,,0,0,0,,“我的意思是 你能写出另一种更具模块化的程序”
Dialogue: 0,0:46:29.84,0:46:32.46,Default,,0,0,0,,“你对模块化的认识并不正确”
Dialogue: 0,0:46:33.08,0:46:35.02,Default,,0,0,0,,你太执着于 “生成一个随机数
Dialogue: 0,0:46:35.07,0:46:36.88,Default,,0,0,0,,再生成一个 再生成一个” 这种范式了
Dialogue: 0,0:46:36.88,0:46:39.42,Default,,0,0,0,,为什么不写一个这样的程序
Dialogue: 0,0:46:40.09,0:46:41.29,Default,,0,0,0,,构造一个枚举器
Dialogue: 0,0:46:41.95,0:46:44.48,Default,,0,0,0,,它会生成一个随机数的无穷流
Dialogue: 0,0:46:49.01,0:46:50.91,Default,,0,0,0,,我们可以立即生成这个流
Dialogue: 0,0:46:52.64,0:46:54.54,Default,,0,0,0,,这样就可以用作随机数的源泉
Dialogue: 0,0:46:54.54,0:46:55.24,Default,,0,0,0,,如果有需要的话
Dialogue: 0,0:46:55.53,0:46:57.47,Default,,0,0,0,,你可以把它跟某个处理过程相连
Dialogue: 0,0:46:57.77,0:47:01.16,Default,,0,0,0,,比如说Cesaro测试
Dialogue: 0,0:47:04.94,0:47:06.22,Default,,0,0,0,,然后这个处理过程进行自己的计算
Dialogue: 0,0:47:06.88,0:47:08.56,Default,,0,0,0,,从这里出来的则是
Dialogue: 0,0:47:08.72,0:47:27.45,Default,,0,0,0,,其中是一串的对π的估计值组成的流
Dialogue: 0,0:47:28.14,0:47:30.65,Default,,0,0,0,,随着我们深入访问这个流
Dialogue: 0,0:47:30.76,0:47:32.38,Default,,0,0,0,,相当于去拽这个Cesaro盒子
Dialogue: 0,0:47:33.12,0:47:35.36,Default,,0,0,0,,它就会拉取出许多随机数
Dialogue: 0,0:47:35.54,0:47:37.21,Default,,0,0,0,,随着我们对流的深入访问
Dialogue: 0,0:47:37.23,0:47:38.96,Default,,0,0,0,,得到的对π的估计值就越准
Dialogue: 0,0:47:39.72,0:47:41.66,Default,,0,0,0,,具体的计算过程还是一样的
Dialogue: 0,0:47:41.66,0:47:43.79,Default,,0,0,0,,只不过使用了另一种模块化的方式
Dialogue: 0,0:47:43.89,0:47:45.55,Default,,0,0,0,,我们可以想象成一下子
Dialogue: 0,0:47:45.56,0:47:47.47,Default,,0,0,0,,就有了这所有的随机数
Dialogue: 0,0:47:49.28,0:47:52.24,Default,,0,0,0,,这个过程的细节在书上有
Dialogue: 0,0:47:53.61,0:47:57.85,Default,,0,0,0,,我们同样也陷于另外一些类似的事情中
Dialogue: 0,0:47:58.27,0:48:01.20,Default,,0,0,0,,这种关于 这个、下一个以及再下一个的范式
Dialogue: 0,0:48:01.37,0:48:02.81,Default,,0,0,0,,完全可以不这么来做
Dialogue: 0,0:48:03.28,0:48:06.54,Default,,0,0,0,,我们来思考一下银行系统
Dialogue: 0,0:48:07.68,0:48:08.90,Default,,0,0,0,,有个非常简单的场景
Dialogue: 0,0:48:08.90,0:48:12.21,Default,,0,0,0,,我们假设这个程序代表了银行帐户
Dialogue: 0,0:48:18.81,0:48:20.84,Default,,0,0,0,,银行账户中可能有
Dialogue: 0,0:48:22.78,0:48:26.22,Default,,0,0,0,,如果我们以消息传递的角度来看
Dialogue: 0,0:48:26.44,0:48:28.12,Default,,0,0,0,,我们认为银行账户是一个对象
Dialogue: 0,0:48:28.59,0:48:31.51,Default,,0,0,0,,内部保存着标识余额的局部状态BALANCE
Dialogue: 0,0:48:34.11,0:48:36.00,Default,,0,0,0,,如果一个用户使用这个系统
Dialogue: 0,0:48:36.44,0:48:38.14,Default,,0,0,0,,发出交易请求
Dialogue: 0,0:48:39.31,0:48:41.05,Default,,0,0,0,,用户发出的交易请求可能是
Dialogue: 0,0:48:41.07,0:48:42.20,Default,,0,0,0,,存一些钱
Dialogue: 0,0:48:42.28,0:48:43.53,Default,,0,0,0,,银行账户就会
Dialogue: 0,0:48:43.92,0:48:46.78,Default,,0,0,0,,我们假设银行账户总是以当前余额作为回应
Dialogue: 0,0:48:48.22,0:48:50.04,Default,,0,0,0,,用户存了一些钱
Dialogue: 0,0:48:50.06,0:48:53.21,Default,,0,0,0,,银行账户就会返回一个消息指明当前余额
Dialogue: 0,0:48:54.35,0:48:57.42,Default,,0,0,0,,用户再存一些钱
Dialogue: 0,0:48:57.45,0:48:58.81,Default,,0,0,0,,银行就再返回消息
Dialogue: 0,0:48:59.15,0:49:00.75,Default,,0,0,0,,就像生成随机数一样
Dialogue: 0,0:49:00.78,0:49:02.12,Default,,0,0,0,,我们想使用赋值来实现
Dialogue: 0,0:49:03.20,0:49:06.88,Default,,0,0,0,,帐户的内部保存了局部状态BALANCE
Dialogue: 0,0:49:06.88,0:49:08.40,Default,,0,0,0,,因为我们想要把用户状态
Dialogue: 0,0:49:08.41,0:49:09.57,Default,,0,0,0,,和银行账户的状态分离开来
Dialogue: 0,0:49:13.28,0:49:16.42,Default,,0,0,0,,这是从消息传递的角度来看
Dialogue: 0,0:49:16.42,0:49:18.20,Default,,0,0,0,,如果从流的角度来看
Dialogue: 0,0:49:19.48,0:49:22.19,Default,,0,0,0,,不需要赋值或副作用就可以达到同样的效果
Dialogue: 0,0:49:22.74,0:49:26.73,Default,,0,0,0,,再次强调 想法是这样的
Dialogue: 0,0:49:27.37,0:49:30.25,Default,,0,0,0,,我们认为它们都没有局部状态
Dialogue: 0,0:49:31.18,0:49:33.08,Default,,0,0,0,,我们把银行账户看作是
Dialogue: 0,0:49:33.40,0:49:37.71,Default,,0,0,0,,能够处理一系列交易请求的东西
Dialogue: 0,0:49:38.64,0:49:40.16,Default,,0,0,0,,不把银行账户看做
Dialogue: 0,0:49:40.22,0:49:42.00,Default,,0,0,0,,逐个消息地处理
Dialogue: 0,0:49:42.44,0:49:45.85,Default,,0,0,0,,而是处理某种交易请求流的东西
Dialogue: 0,0:49:45.87,0:49:48.49,Default,,0,0,0,,这个请求流可能是一些列的存款声明
Dialogue: 0,0:49:49.49,0:49:54.94,Default,,0,0,0,,比如 1 2 2 4 这样的连续存钱请求
Dialogue: 0,0:49:55.94,0:50:02.44,Default,,0,0,0,,从帐户出来的流应该是 1 3 5 9
Dialogue: 0,0:50:03.77,0:50:06.14,Default,,0,0,0,,我们不把银行账户看做某种具有状态的东西
Dialogue: 0,0:50:06.40,0:50:07.26,Default,,0,0,0,,而是某种能够处理
Dialogue: 0,0:50:08.92,0:50:10.82,Default,,0,0,0,,有关请求的无穷流的东西
Dialogue: 0,0:50:10.82,0:50:12.30,Default,,0,0,0,,但要注意 我们抛弃了时间
Dialogue: 0,0:50:12.37,0:50:14.27,Default,,0,0,0,,如果这里有一个用户
Dialogue: 0,0:50:16.12,0:50:19.13,Default,,0,0,0,,这个无穷请求流的元素
Dialogue: 0,0:50:19.18,0:50:22.54,Default,,0,0,0,,我们可以一次生成一个
Dialogue: 0,0:50:24.06,0:50:26.57,Default,,0,0,0,,而这个交易流
Dialogue: 0,0:50:26.57,0:50:28.80,Default,,0,0,0,,则会逐个打印在屏幕上
Dialogue: 0,0:50:30.01,0:50:31.37,Default,,0,0,0,,如果在这里画一条线
Dialogue: 0,0:50:32.56,0:50:33.08,Default,,0,0,0,,就在这里
Dialogue: 0,0:50:33.28,0:50:34.91,Default,,0,0,0,,对用户来说 他根本无法分辨
Dialogue: 0,0:50:36.19,0:50:37.71,Default,,0,0,0,,这个系统是否有内部状态
Dialogue: 0,0:50:39.56,0:50:41.13,Default,,0,0,0,,这个跟消息传递那种是一样的
Dialogue: 0,0:50:41.29,0:50:42.46,Default,,0,0,0,,只不过这个没有状态
Dialogue: 0,0:50:42.84,0:50:45.87,Default,,0,0,0,,哦 顺便提一下
Dialogue: 0,0:50:46.72,0:50:49.47,Default,,0,0,0,,这是具体的代码实现
Dialogue: 0,0:50:50.52,0:50:52.30,Default,,0,0,0,,我们把它叫做MAKE-DEPOSIT-ACCOUNT
Dialogue: 0,0:50:52.32,0:50:53.32,Default,,0,0,0,,因为它只能够存钱
Dialogue: 0,0:50:54.17,0:50:55.77,Default,,0,0,0,,这个过程接受一个初始余额
Dialogue: 0,0:50:56.09,0:50:58.09,Default,,0,0,0,,以及一个可能发起的存款流
Dialogue: 0,0:51:00.02,0:51:00.82,Default,,0,0,0,,具体怎么做呢？
Dialogue: 0,0:51:00.82,0:51:02.54,Default,,0,0,0,,它只是用CONS-STREAM把余额BALANCE
Dialogue: 0,0:51:03.23,0:51:05.31,Default,,0,0,0,,和一个新的存款账户流组合在一起
Dialogue: 0,0:51:06.24,0:51:07.32,Default,,0,0,0,,新存款流的初始余额
Dialogue: 0,0:51:07.48,0:51:10.27,Default,,0,0,0,,就是之前BALANCE的值加上存款流的第一个元素
Dialogue: 0,0:51:10.86,0:51:13.40,Default,,0,0,0,,而其余部分则是
Dialogue: 0,0:51:13.76,0:51:17.37,Default,,0,0,0,,存款流的尾部分
Dialogue: 0,0:51:18.30,0:51:23.84,Default,,0,0,0,,因此这种非常典型的消息传递式、面向对象的问题
Dialogue: 0,0:51:23.95,0:51:27.55,Default,,0,0,0,,完全可以不用副作用来解决
Dialogue: 0,0:51:29.05,0:51:30.76,Default,,0,0,0,,很多地方都可以这样做
Dialogue: 0,0:51:32.25,0:51:35.23,Default,,0,0,0,,那么 我们可以完全不用赋值么？
Dialogue: 0,0:51:36.40,0:51:39.00,Default,,0,0,0,,可以只用纯函数式语言吗？
Dialogue: 0,0:51:40.05,0:51:42.04,Default,,0,0,0,,这个问题谁也说不清
Dialogue: 0,0:51:42.27,0:51:43.44,Default,,0,0,0,,好像有些地方
Dialogue: 0,0:51:43.92,0:51:46.03,Default,,0,0,0,,纯函数式语言无法派上用场
Dialogue: 0,0:51:48.10,0:51:50.27,Default,,0,0,0,,当遇到像这样的系统时 问题就变得棘手起来
Dialogue: 0,0:51:50.43,0:51:52.32,Default,,0,0,0,,特别是当你
Dialogue: 0,0:51:52.60,0:51:54.27,Default,,0,0,0,,还需要考虑其它因素的时候
Dialogue: 0,0:51:54.30,0:51:55.64,Default,,0,0,0,,有关对象和共享
Dialogue: 0,0:51:55.90,0:51:58.52,Default,,0,0,0,,以及两个独立的主体共享同一个东西
Dialogue: 0,0:51:58.85,0:51:59.93,Default,,0,0,0,,举一个典型的例子
Dialogue: 0,0:51:59.96,0:52:01.63,Default,,0,0,0,,假如你来扩展这个帐户
Dialogue: 0,0:52:03.24,0:52:04.27,Default,,0,0,0,,这是一个帐户
Dialogue: 0,0:52:12.22,0:52:14.75,Default,,0,0,0,,帐户接受一个交易请求流
Dialogue: 0,0:52:15.20,0:52:18.44,Default,,0,0,0,,输出的流则是关于余额的回复
Dialogue: 0,0:52:18.78,0:52:20.16,Default,,0,0,0,,假设你所建模的是联合账户
Dialogue: 0,0:52:20.17,0:52:24.36,Default,,0,0,0,,而由两个独立用户共享
Dialogue: 0,0:52:25.68,0:52:28.65,Default,,0,0,0,,我们假设 假设有两个人
Dialogue: 0,0:52:28.97,0:52:30.96,Default,,0,0,0,,比如说Bill和Dave
Dialogue: 0,0:52:31.77,0:52:33.14,Default,,0,0,0,,他们俩共享一个帐户
Dialogue: 0,0:52:35.96,0:52:36.85,Default,,0,0,0,,怎么来建模呢？
Dialogue: 0,0:52:36.88,0:52:39.80,Default,,0,0,0,,你或许会让Bill输出一个交易请求流
Dialogue: 0,0:52:40.24,0:52:42.25,Default,,0,0,0,,Dave也产生一个这样的流
Dialogue: 0,0:52:42.25,0:52:45.16,Default,,0,0,0,,这两个流需要以某种方式合并到银行账户中
Dialogue: 0,0:52:45.88,0:52:47.85,Default,,0,0,0,,因此你需要编写一个MERGE过程
Dialogue: 0,0:52:47.90,0:52:50.65,Default,,0,0,0,,来处理这些流
Dialogue: 0,0:52:57.23,0:52:59.13,Default,,0,0,0,,它把这些流合并在一起
Dialogue: 0,0:52:59.34,0:53:01.19,Default,,0,0,0,,形成单个流 送入银行账户
Dialogue: 0,0:53:01.19,0:53:02.99,Default,,0,0,0,,现在他们就共享一个帐户了
Dialogue: 0,0:53:03.61,0:53:05.48,Default,,0,0,0,,看起来不错 问题是怎么来实现MERGE
Dialogue: 0,0:53:05.93,0:53:08.24,Default,,0,0,0,,MERGE怎么来合并？
Dialogue: 0,0:53:09.73,0:53:11.42,Default,,0,0,0,,需要合理的合并依据
Dialogue: 0,0:53:12.38,0:53:13.80,Default,,0,0,0,,你可能首先会想
Dialogue: 0,0:53:13.80,0:53:16.68,Default,,0,0,0,,我们从Bill和Dave中选一个请求来处理
Dialogue: 0,0:53:18.19,0:53:20.97,Default,,0,0,0,,但是如果在这中途
Dialogue: 0,0:53:21.18,0:53:23.08,Default,,0,0,0,,Dave突然外出度假两年 会怎么样？
Dialogue: 0,0:53:24.15,0:53:25.40,Default,,0,0,0,,Bill的交易就完全被阻塞了
Dialogue: 0,0:53:27.69,0:53:29.75,Default,,0,0,0,,你想要的是
Dialogue: 0,0:53:29.75,0:53:33.64,Default,,0,0,0,,是一种公平的合并
Dialogue: 0,0:53:38.41,0:53:40.17,Default,,0,0,0,,这个所谓公平的合并
Dialogue: 0,0:53:40.73,0:53:42.46,Default,,0,0,0,,应该是交替地一次处理一个
Dialogue: 0,0:53:42.49,0:53:43.92,Default,,0,0,0,,但是如果一个人没有了交易
Dialogue: 0,0:53:43.96,0:53:44.91,Default,,0,0,0,,应该继续去处理另一个人的交易
Dialogue: 0,0:53:46.01,0:53:48.45,Default,,0,0,0,,但是没有时间 我就不能这样做
Dialogue: 0,0:53:51.30,0:53:56.41,Default,,0,0,0,,函数式语言的另一个活跃研究领域就是
Dialogue: 0,0:53:56.43,0:53:59.48,Default,,0,0,0,,发明类似于“公平合并”的算法
Dialogue: 0,0:54:00.35,0:54:01.31,Default,,0,0,0,,又或者是其它的东西
Dialogue: 0,0:54:01.56,0:54:06.25,Default,,0,0,0,,用于取代原来需要副作用和对象的地方
Dialogue: 0,0:54:06.80,0:54:10.52,Default,,0,0,0,,用一种良好定义的模块化系统来隐藏它们
Dialogue: 0,0:54:10.86,0:54:13.50,Default,,0,0,0,,这样 系统中就不会到处产生
Dialogue: 0,0:54:13.52,0:54:15.34,Default,,0,0,0,,赋值所带来的问题
Dialogue: 0,0:54:15.40,0:54:17.88,Default,,0,0,0,,因为它可以被理解透彻的概念所描述
Dialogue: 0,0:54:20.78,0:54:22.70,Default,,0,0,0,,推而广之 我想你们也发现了
Dialogue: 0,0:54:23.12,0:54:24.06,Default,,0,0,0,,我们正面对 我所认为的
Dialogue: 0,0:54:24.08,0:54:26.67,Default,,0,0,0,,计算机科学中最基本的问题
Dialogue: 0,0:54:26.97,0:54:27.82,Default,,0,0,0,,也就是
Dialogue: 0,0:54:28.24,0:54:32.03,Default,,0,0,0,,我们如何定义一门支持延迟求值的语言
Dialogue: 0,0:54:34.14,0:54:35.08,Default,,0,0,0,,但同时又能够
Dialogue: 0,0:54:35.87,0:54:38.25,Default,,0,0,0,,又能够把事物看做对象来操作
Dialogue: 0,0:54:38.36,0:54:40.36,Default,,0,0,0,,怎么样才能两者兼有之？
Dialogue: 0,0:54:41.23,0:54:43.04,Default,,0,0,0,,我认为这个问题很困难
Dialogue: 0,0:54:43.04,0:54:45.52,Default,,0,0,0,,但是这个很困难的问题
Dialogue: 0,0:54:45.85,0:54:48.17,Default,,0,0,0,,却和计算机科学的关系不大
Dialogue: 0,0:54:48.59,0:54:50.24,Default,,0,0,0,,它真正涉及的是
Dialogue: 0,0:54:50.27,0:54:52.73,Default,,0,0,0,,两种不相容的看待世界的方式
Dialogue: 0,0:54:54.14,0:54:54.72,Default,,0,0,0,,有问题吗？
Dialogue: 0,0:55:17.55,0:55:19.20,Default,,0,0,0,,学生：你之前提到过
Dialogue: 0,0:55:20.11,0:55:21.32,Default,,0,0,0,,一旦引入了赋值
Dialogue: 0,0:55:21.32,0:55:25.89,Default,,0,0,0,,就不能使用代换模型了
Dialogue: 0,0:55:25.89,0:55:27.57,Default,,0,0,0,,除非你非常小心
Dialogue: 0,0:55:27.57,0:55:27.96,Default,,0,0,0,,教授：对的
Dialogue: 0,0:55:28.26,0:55:33.28,Default,,0,0,0,,学生：有什么技术或者指导方针
Dialogue: 0,0:55:33.42,0:55:35.92,Default,,0,0,0,,来确定赋值的影响
Dialogue: 0,0:55:36.52,0:55:40.30,Default,,0,0,0,,以便说清楚这个“很小心”是怎么回事吗？
Dialogue: 0,0:55:40.30,0:55:42.60,Default,,0,0,0,,教授：我不知道
Dialogue: 0,0:55:42.89,0:55:43.58,Default,,0,0,0,,我想想
Dialogue: 0,0:55:45.43,0:55:48.94,Default,,0,0,0,,当然 实现MEM-PROC也使用了赋值
Dialogue: 0,0:55:50.12,0:55:51.48,Default,,0,0,0,,但是它被隐藏了起来
Dialogue: 0,0:55:51.48,0:55:53.00,Default,,0,0,0,,因为它没有对结果造成影响
Dialogue: 0,0:55:53.48,0:55:56.44,Default,,0,0,0,,部分原因之一在于 一旦触发这个过程
Dialogue: 0,0:55:57.15,0:55:58.83,Default,,0,0,0,,它被求值并得到结果
Dialogue: 0,0:55:58.83,0:56:00.06,Default,,0,0,0,,这个结果不会再变化
Dialogue: 0,0:56:00.60,0:56:02.33,Default,,0,0,0,,有点像单次赋值
Dialogue: 0,0:56:02.35,0:56:03.85,Default,,0,0,0,,一个一般性原则就是
Dialogue: 0,0:56:04.30,0:56:06.35,Default,,0,0,0,,如果你只用这种单次赋值
Dialogue: 0,0:56:08.04,0:56:09.24,Default,,0,0,0,,并且它不再改变
Dialogue: 0,0:56:09.63,0:56:10.54,Default,,0,0,0,,我想应该不会有太大问题
Dialogue: 0,0:56:11.25,0:56:14.12,Default,,0,0,0,,还有一个问题在于MERGE --
Dialogue: 0,0:56:14.67,0:56:18.32,Default,,0,0,0,,让我想想对不对
Dialogue: 0,0:56:18.49,0:56:21.55,Default,,0,0,0,,我认为有了公平合并这一技术
Dialogue: 0,0:56:22.25,0:56:26.09,Default,,0,0,0,,你可以在语言的其它地方
Dialogue: 0,0:56:27.02,0:56:28.89,Default,,0,0,0,,有效地模拟赋值
Dialogue: 0,0:56:30.82,0:56:33.29,Default,,0,0,0,,这就像为了解决问题你会引入一些东西
Dialogue: 0,0:56:33.50,0:56:35.50,Default,,0,0,0,,我不清楚对公平合并来说是否成立
Dialogue: 0,0:56:35.53,0:56:39.31,Default,,0,0,0,,但是对人们正在尝试的一些一般性事情是成立的
Dialogue: 0,0:56:39.52,0:56:41.34,Default,,0,0,0,,所以 这可能是你引入的这一点点东西
Dialogue: 0,0:56:41.61,0:56:44.14,Default,,0,0,0,,突然间 使你能构建任何东西
Dialogue: 0,0:56:44.16,0:56:46.51,Default,,0,0,0,,这就几乎跟有了赋值一样糟糕了
Dialogue: 0,0:56:47.97,0:56:50.67,Default,,0,0,0,,这也是人们在研究的一个领域
Dialogue: 0,0:56:51.59,0:56:54.30,Default,,0,0,0,,学生：我还没有太明白MERGE的问题
Dialogue: 0,0:56:54.83,0:56:59.20,Default,,0,0,0,,如果我调用Bill它是个过程
Dialogue: 0,0:56:59.21,0:57:02.41,Default,,0,0,0,,那么Bill就会增加银行账户
Dialogue: 0,0:57:02.44,0:57:04.73,Default,,0,0,0,,或者创建一个表 用于放置下一个存款
Dialogue: 0,0:57:04.73,0:57:06.84,Default,,0,0,0,,如果我连续调用Dave两次 他肯定也会那样
Dialogue: 0,0:57:07.17,0:57:09.35,Default,,0,0,0,,我并不清楚为什么需要公平合并
Dialogue: 0,0:57:09.35,0:57:11.20,Default,,0,0,0,,教授：关键在于你得把这些当作真人一样
Dialogue: 0,0:57:11.20,0:57:14.20,Default,,0,0,0,,这里有一个用户在操作帐户
Dialogue: 0,0:57:14.85,0:57:17.07,Default,,0,0,0,,请求一次 得到结果
Dialogue: 0,0:57:17.20,0:57:17.56,Default,,0,0,0,,学生：对
Dialogue: 0,0:57:18.20,0:57:20.62,Default,,0,0,0,,教授：如果我只能通过从两个流中选择一个
Dialogue: 0,0:57:20.65,0:57:22.25,Default,,0,0,0,,来处理请求的话
Dialogue: 0,0:57:22.91,0:57:24.22,Default,,0,0,0,,学生：为什么要二选一呢？
Dialogue: 0,0:57:24.22,0:57:25.23,Default,,0,0,0,,教授：为什么不呢？
Dialogue: 0,0:57:25.45,0:57:25.80,Default,,0,0,0,,学生：对啊 为什么要这样呢？
Dialogue: 0,0:57:26.60,0:57:27.72,Default,,0,0,0,,教授：假设这些是现实中的人 对吗？
Dialogue: 0,0:57:27.76,0:57:28.97,Default,,0,0,0,,这个人外出一年
Dialogue: 0,0:57:29.28,0:57:31.74,Default,,0,0,0,,你只能在银行账户窗口旁边等待
Dialogue: 0,0:57:32.43,0:57:33.72,Default,,0,0,0,,就是不能处理两个请求
Dialogue: 0,0:57:33.74,0:57:34.94,Default,,0,0,0,,因为你还得等这个人
Dialogue: 0,0:57:35.48,0:57:37.07,Default,,0,0,0,,学生：为什么非得等他呢？
Dialogue: 0,0:57:37.38,0:57:39.11,Default,,0,0,0,,教授：因为这里是在计算一个函数
Dialogue: 0,0:57:39.11,0:57:40.92,Default,,0,0,0,,我必须定义一个函数
Dialogue: 0,0:57:41.72,0:57:42.60,Default,,0,0,0,,换种方式来说
Dialogue: 0,0:57:42.84,0:57:44.99,Default,,0,0,0,,这个MERGE盒子的输出
Dialogue: 0,0:57:46.24,0:57:49.48,Default,,0,0,0,,并不是输入的函数
Dialogue: 0,0:57:51.69,0:57:53.49,Default,,0,0,0,,明白了吗？再来看看这个MERGE是怎么运行的
Dialogue: 0,0:57:53.49,0:57:58.86,Default,,0,0,0,,假设Bill输入 1 1 1 1
Dialogue: 0,0:57:59.82,0:58:02.78,Default,,0,0,0,,Dave输入2 2 2 2
Dialogue: 0,0:58:03.47,0:58:04.80,Default,,0,0,0,,MERGE应该输出什么呢？
Dialogue: 0,0:58:05.58,0:58:08.74,Default,,0,0,0,,这里并不一定是 1 2 1 2 1 2
Dialogue: 0,0:58:08.74,0:58:09.39,Default,,0,0,0,,学生：我明白了
Dialogue: 0,0:58:09.39,0:58:11.56,Default,,0,0,0,,当Bill输入1 1也就进去了
Dialogue: 0,0:58:11.56,0:58:13.95,Default,,0,0,0,,Dave再输入两个2 MERGE就输出两个2
Dialogue: 0,0:58:13.95,0:58:14.73,Default,,0,0,0,,学生：当Bill输入
Dialogue: 0,0:58:14.76,0:58:15.08,Default,,0,0,0,,教授：对的
Dialogue: 0,0:58:15.13,0:58:18.43,Default,,0,0,0,,学生：为什么不能在输入的数据上
Dialogue: 0,0:58:18.59,0:58:20.06,Default,,0,0,0,,加上时间信息呢？
Dialogue: 0,0:58:20.12,0:58:21.84,Default,,0,0,0,,教授：因为这里没有时间这个概念
Dialogue: 0,0:58:23.98,0:58:26.90,Default,,0,0,0,,我只是定义一个函数
Dialogue: 0,0:58:26.90,0:58:28.15,Default,,0,0,0,,没有时间概念
Dialogue: 0,0:58:32.00,0:58:34.19,Default,,0,0,0,,如果是二选一的话
Dialogue: 0,0:58:34.19,0:58:36.54,Default,,0,0,0,,如果选中的流没有人 就得等待它
Dialogue: 0,0:58:38.42,0:58:41.36,Default,,0,0,0,,它只会说 我有一个请求流
Dialogue: 0,0:58:41.74,0:58:43.34,Default,,0,0,0,,这是是Dave生成的
Dialogue: 0,0:58:43.36,0:58:45.29,Default,,0,0,0,,没有时刻的、无穷长度的请求流
Dialogue: 0,0:58:47.55,0:58:50.41,Default,,0,0,0,,Bill可能生成 没有时刻的无穷请求流
Dialogue: 0,0:58:50.54,0:58:51.69,Default,,0,0,0,,我想对这些东西做运算
Dialogue: 0,0:58:51.69,0:58:53.51,Default,,0,0,0,,这就是银行帐户的工作原理
Dialogue: 0,0:58:56.71,0:58:57.58,Default,,0,0,0,,问题是
Dialogue: 0,0:58:57.61,0:59:00.75,Default,,0,0,0,,这些坐在银行窗口前的倒霉蛋们
Dialogue: 0,0:59:00.76,0:59:03.82,Default,,0,0,0,,来得并不是时候
Dialogue: 0,0:59:05.29,0:59:07.13,Default,,0,0,0,,它们才看不到这个无穷流
Dialogue: 0,0:59:07.69,0:59:09.53,Default,,0,0,0,,什么时候其中会有请求
Dialogue: 0,0:59:10.07,0:59:11.55,Default,,0,0,0,,他们只是等着 等待帐户的响应
Dialogue: 0,0:59:14.48,0:59:15.76,Default,,0,0,0,,假设你坐在屏幕前
Dialogue: 0,0:59:16.24,0:59:20.86,Default,,0,0,0,,操作着一台分时系统的计算机
Dialogue: 0,0:59:21.52,0:59:22.60,Default,,0,0,0,,而且它还是函数式的
Dialogue: 0,0:59:22.64,0:59:24.59,Default,,0,0,0,,输入指令后你就希望看到结果
Dialogue: 0,0:59:25.29,0:59:27.42,Default,,0,0,0,,但是你并不想主机在处理完所有其它人的命令
Dialogue: 0,0:59:27.45,0:59:29.92,Default,,0,0,0,,之后再来处理你的命令
Dialogue: 0,0:59:30.91,0:59:31.92,Default,,0,0,0,,这就是问题所在
Dialogue: 0,0:59:34.00,0:59:36.38,Default,,0,0,0,,我的意思就是 用户的世界当然是存在时间概念的
Dialogue: 0,0:59:37.21,0:59:38.62,Default,,0,0,0,,如果没有 这就不构成问题
Dialogue: 0,0:59:49.10,0:59:51.02,Default,,0,0,0,,学生：我想我还是不太理解
Dialogue: 0,0:59:51.08,0:59:54.24,Default,,0,0,0,,银行交易中为什么没有时间概念这一要点
Dialogue: 0,0:59:54.74,0:59:56.65,Default,,0,0,0,,难道时间不是非常重要吗？
Dialogue: 0,0:59:56.88,0:59:59.05,Default,,0,0,0,,举例说 有一系列事件
Dialogue: 0,0:59:59.95,1:00:05.02,Default,,0,0,0,,比如Dave取款$100
Dialogue: 0,1:00:06.30,1:00:08.40,Default,,0,0,0,,这些顺序应该很重要才对
Dialogue: 0,1:00:08.40,1:00:10.86,Default,,0,0,0,,你怎么能把它们看作是流呢？
Dialogue: 0,1:00:11.26,1:00:14.26,Default,,0,0,0,,教授：这就是我一直在强调的
Dialogue: 0,1:00:14.26,1:00:15.61,Default,,0,0,0,,在这个例子中确实做不到那一点
Dialogue: 0,1:00:17.51,1:00:18.12,Default,,0,0,0,,做不到
Dialogue: 0,1:00:18.16,1:00:20.08,Default,,0,0,0,,关键在于 这里的输出
Dialogue: 0,1:00:20.24,1:00:21.88,Default,,0,0,0,,并不是这两个输入流
Dialogue: 0,1:00:21.92,1:00:23.60,Default,,0,0,0,,的函数
Dialogue: 0,1:00:24.17,1:00:25.98,Default,,0,0,0,,这个函数跟这个输入流有关
Dialogue: 0,1:00:26.19,1:00:27.26,Default,,0,0,0,,还跟这个输入流有关
Dialogue: 0,1:00:27.36,1:00:29.07,Default,,0,0,0,,还包括某种有关时间的信息
Dialogue: 0,1:00:29.37,1:00:32.36,Default,,0,0,0,,这也正是正则序语言不想让你知道的
Dialogue: 0,1:00:34.81,1:00:37.95,Default,,0,0,0,,学生：为了让这个系统更加函数式
Dialogue: 0,1:00:38.54,1:00:42.04,Default,,0,0,0,,我们能不能把Bill和Dave的交易请求附上时间戳
Dialogue: 0,1:00:42.54,1:00:46.40,Default,,0,0,0,,而使用时间戳作为公平合并的依据？
Dialogue: 0,1:00:48.41,1:00:49.55,Default,,0,0,0,,教授：当然 当然可以
Dialogue: 0,1:00:49.55,1:00:50.60,Default,,0,0,0,,你可以那样做
Dialogue: 0,1:00:50.60,1:00:52.56,Default,,0,0,0,,或者 我们可以这样来想象
Dialogue: 0,1:00:52.76,1:00:54.44,Default,,0,0,0,,我们把这个函数看作是
Dialogue: 0,1:00:54.78,1:00:56.88,Default,,0,0,0,,MERGE每毫秒读一次输入
Dialogue: 0,1:00:58.86,1:00:59.93,Default,,0,0,0,,如果没有读到东西
Dialogue: 0,1:00:59.93,1:01:00.97,Default,,0,0,0,,就认为没有请求
Dialogue: 0,1:01:00.97,1:01:03.39,Default,,0,0,0,,这和你刚刚说的那种方式是等价的
Dialogue: 0,1:01:03.61,1:01:06.08,Default,,0,0,0,,当然可以这样做 但有点旁门左道
Dialogue: 0,1:01:07.11,1:01:10.14,Default,,0,0,0,,我们不只是关心函数的具体实现
Dialogue: 0,1:01:10.76,1:01:12.73,Default,,0,0,0,,我们关心的是语言的表达力
Dialogue: 0,1:01:12.75,1:01:14.67,Default,,0,0,0,,我们遇到的困难是
Dialogue: 0,1:01:14.99,1:01:17.44,Default,,0,0,0,,我们不能很容易地表达我们想要表达的东西
Dialogue: 0,1:01:19.88,1:01:22.01,Default,,0,0,0,,学生：听起来好像如果两个人同时发出请求
Dialogue: 0,1:01:22.06,1:01:26.09,Default,,0,0,0,,这个方法就会出问题
Dialogue: 0,1:01:26.12,1:01:28.43,Default,,0,0,0,,教授：并不只是这个 只要是你定义的都可能出问题
Dialogue: 0,1:01:28.53,1:01:30.57,Default,,0,0,0,,你当然可以说Dave经常发起两个请求
Dialogue: 0,1:01:30.72,1:01:32.32,Default,,0,0,0,,但是你如果预先定义了什么
Dialogue: 0,1:01:32.68,1:01:33.87,Default,,0,0,0,,这样做也不正确
Dialogue: 0,1:01:36.11,1:01:40.70,Default,,0,0,0,,你不能确定某些特定函数的输入请求
Dialogue: 0,1:01:41.93,1:01:43.37,Default,,0,0,0,,但是还有更坏的情况
Dialogue: 0,1:01:44.12,1:01:45.72,Default,,0,0,0,,有一些情况甚至MERGE也处理不了
Dialogue: 0,1:01:47.29,1:01:49.69,Default,,0,0,0,,比如突然有一天你想要
Dialogue: 0,1:01:50.24,1:01:52.47,Default,,0,0,0,,把另一个人关联在这个银行帐户上
Dialogue: 0,1:01:52.47,1:01:54.51,Default,,0,0,0,,假如这个人是John
Dialogue: 0,1:01:56.03,1:01:58.89,Default,,0,0,0,,现在图上就要多一个流
Dialogue: 0,1:01:58.91,1:02:00.70,Default,,0,0,0,,在一个我们未曾指定的时候
Dialogue: 0,1:02:02.04,1:02:04.00,Default,,0,0,0,,这种情况甚至公平合并也无法给出合理的合并
Dialogue: 0,1:02:04.00,1:02:08.25,Default,,0,0,0,,还需要有MANAGER一类的东西
Dialogue: 0,1:02:08.86,1:02:11.79,Default,,0,0,0,,需要一种更一般性的公平合并来解决
Dialogue: 0,1:02:11.79,1:02:13.98,Default,,0,0,0,,有很多研究都在讨论
Dialogue: 0,1:02:14.00,1:02:16.30,Default,,0,0,0,,通过不断引入新机制
Dialogue: 0,1:02:16.59,1:02:18.72,Default,,0,0,0,,函数式思维能应用到哪种程度？
Dialogue: 0,1:02:19.58,1:02:21.79,Default,,0,0,0,,在我们不得不使用赋值之前
Dialogue: 0,1:02:21.82,1:02:23.40,Default,,0,0,0,,函数式程序设计能干成什么样？
Dialogue: 0,1:02:25.98,1:02:28.00,Default,,0,0,0,,学生：看来自动存款就不行
Dialogue: 0,1:02:39.32,1:02:40.49,Default,,0,0,0,,教授：好的 下课
Dialogue: 0,1:02:41.32,1:03:00.08,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:02:41.32,1:03:00.08,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP